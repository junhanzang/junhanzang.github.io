---
title: "Beyond Memorization: The Challenge of Random Memory Access in Language Models"
date: 2024-08-04 16:55:18
categories:
  - 인공지능
---

<https://arxiv.org/abs/2403.07805>

[Beyond Memorization: The Challenge of Random Memory Access in Language Models](https://arxiv.org/abs/2403.07805)

### 요약(Abstract)

최근 언어 모델(Language Models, LMs)의 발전은 특히 지식 집약적인 작업에서 자연어 처리(NLP) 작업의 효과를 보여주었습니다. 그러나 이러한 모델의 파라미터 내에서 지식 저장과 메모리 접근 메커니즘은 여전히 명확하지 않습니다. 이 논문에서는 생성형 언어 모델(예: GPT-2)이 메모리에 순차적으로 접근할 수 있는지 아니면 무작위로 접근할 수 있는지를 조사합니다. 전반적인 암송, 선택적 암송 및 기초 질문 답변 시나리오를 다루는 신중하게 설계된 인공 작업을 통해 언어 모델이 메모리에 순차적으로 접근하는 데 성공하면서도 암기된 내용을 무작위로 접근하는 데 어려움을 겪고 있음을 밝힙니다. 우리는 암송 및 순열을 포함한 기술이 언어 모델의 무작위 메모리 접근 능력을 향상시킨다는 것을 발견했습니다. 또한, 이러한 개입을 실제 시나리오인 오픈 도메인 질문 답변에 적용함으로써, 암송을 통한 무작위 접근 향상이 질문 답변 성능을 현저히 개선한다는 것을 검증했습니다. 우리의 실험을 재현할 수 있는 코드는 <https://github.com/sail-sg/lm-random-memory-access에서> 찾을 수 있습니다.

### 1. 서론 (Introduction)

언어 모델(Language Models, LMs)은 최근 자연어 처리(NLP) 작업에서 뛰어난 능력을 보여주며, 파라미터에 대량의 메모리를 저장하고 있습니다 (Brown et al., 2020; Ouyang et al., 2022). 대규모 텍스트 코퍼스를 사전 학습(pre-training)함으로써, LMs는 세상에 대한 사실적 지식을 암기합니다 (Zhou et al., 2023). 그 결과, 오픈 도메인 질문 답변(Kamalloo et al., 2023; Ziems et al., 2023; Mallen et al., 2023)과 같은 지식 집약적 작업에서 우수한 성능을 보입니다 (Petroni et al., 2021). LMs를 지식 베이스로 간주하려는 관심이 증가하고 있습니다 (Wang et al., 2021; Heinzerling and Inui, 2021; Petroni et al., 2019; Cao et al., 2021; AlKhamissi et al., 2022). LMs를 활용하여 다운스트림 작업을 해결하는 최근의 발전에도 불구하고, LMs가 파라미터에 지식을 저장하고 메모리에 접근하는 기본 메커니즘은 여전히 지속적인 연구와 관심의 대상입니다 (Tirumala et al., 2022; Zhu and Li, 2023; Allen-Zhu and Li, 2023; Berglund et al., 2023).

![](/assets/images/posts/235/img.png)

### 그림 1: 언어 모델에서의 메모리 접근 패턴 조사의 일러스트레이션

우리의 연구는 모델이 주로 순차적으로 파라메트릭 메모리에 접근하며, 암기된 문자열의 중간에 있는 내용을 무작위로 접근하는 데 어려움을 겪는다는 것을 보여줍니다.

본 논문에서는 컴퓨터 시스템에서 관찰된 메모리 접근 패턴에서 영감을 받아 언어 모델(LMs)이 파라메트릭 메모리에 순차적으로 또는 무작위로 접근할 수 있는지 탐구합니다. 이러한 개념을 확장하여 언어 모델의 두 가지 메모리 접근 패턴을 조사합니다. 순차적 메모리 접근은 모델이 암기된 시퀀스의 시작부터 시작하여 연속적인 순서로 내용을 진행하는 것을 의미합니다. 반면, 무작위 메모리 접근은 모델이 암기된 내용의 어느 위치에서든 시작할 수 있으며, 시작부터 시작할 필요가 없는 것을 의미합니다. 예를 들어, 암기된 시를 한 줄씩 낭독하는 것은 순차적 접근으로 간주되며, 세 번째 줄부터 바로 시작하는 것은 무작위 접근을 포함합니다.

이 개념을 바탕으로, 우리는 언어 모델이 암기된 내용에 순차적으로 또는 무작위로 접근할 수 있는 능력을 평가하기 위해 합성 및 실제 데이터를 사용한 실험을 설계합니다. 우리는 디코더 전용 언어 모델에 대해 연구를 제한하는데, 이는 이 모델들이 점점 인기를 얻고 능력이 증가하고 있기 때문입니다 (Radford et al., 2019; Brown et al., 2020; Touvron et al., 2023a, b; Jiang et al., 2023). 먼저 모델에게 다양한 유형의 키-값 쌍을 암기하도록 요청하고, 모델이 암기된 내용을 만족스러운 정도로 순차적으로 읽을 수 있음을 보여줍니다. 다음으로, 문장을 암송하거나 암기된 구절에서 질문에 대한 답을 찾도록 훈련시켜 모델의 무작위 접근 능력을 테스트합니다. 이러한 작업에서, 구절의 중간에서 스팬을 추출해야 할 때 모델의 성능이 급격히 떨어져 모델이 무작위로 메모리에 접근할 수 없는 것을 드러냅니다.

언어 모델이 메모리에 무작위로 접근하는 데 어려움을 겪는다는 사실을 고려하여, 우리는 두 가지 해결책을 모색합니다: 추론 시 낭독(recitation)과 훈련 시 순열(permutation). 낭독은 모델이 작업을 수행하기 전에 먼저 파라메트릭 메모리를 순차적으로 읽을 수 있게 합니다. 모델의 성능은 낭독된 내용을 컨텍스트 윈도우에서 활용하여 향상될 수 있습니다. 또한, 훈련 중에 구절의 문장을 단순히 순열하여 암기하는 것도 성능을 향상시킨다는 것을 보여줍니다.

마지막으로, 오픈 도메인 질문 답변에 대한 사례 연구를 통해 무작위 접근의 어려움을 검증합니다. 우리는 모델이 정답이 포함된 구절을 암기하도록 하여 작업의 난이도를 줄이지만, 관련 구절을 낭독한 후 질문에 답변할 수 있을 때 모델이 가장 큰 혜택을 본다는 것을 발견합니다. 전체적으로, 우리는 디코더 전용 언어 모델의 메모리 접근 메커니즘을 더 잘 이해하기 위해 여러 기여를 합니다:

- 언어 모델이 메모리에 순차적으로 접근하고 암기된 내용을 재현할 수 있지만 무작위 메모리 접근에서는 큰 어려움을 겪음을 보여줍니다.
- 암기된 내용을 순열하거나 작업을 수행하기 전에 명시적으로 메모리를 낭독하여 무작위 접근의 어려움을 완화하는 솔루션을 발견합니다.
- 무작위 메모리 접근 능력의 부족이 오픈 도메인 질문 답변에 미치는 영향을 시연하며, 이 어려움이 언어 모델의 응용에 더 넓은 영향을 미칠 수 있음을 보여줍니다.

### 2. 관련 연구 (Related Work)

#### 언어 모델에서의 암기

대규모 언어 모델은 파라미터에 상당한 양의 지식을 저장합니다 (Petroni et al., 2019; Heinzerling and Inui, 2021). 이들은 사실과 상식(Zhao et al., 2023)과 같은 유용한 지식을 암기하지만, 이메일이나 전화번호와 같은 민감한 개인 정보도 암기합니다 (Carlini et al., 2020; Huang et al., 2022). 암기에 대한 기존 접근 방식은 지식과 관련된 뉴런을 찾기 위한 세밀한 분석(Meng et al., 2022; Liu et al., 2024)이나 암기의 전체적인 역학을 이해하기 위한 거시적 분석(Tirumala et al., 2022; Speicher et al., 2024)을 포함합니다. 본 연구에서는 언어 모델의 메모리에 쓰는 메커니즘을 분석하는 것을 목표로 하지 않습니다. 대신, 우리는 언어 모델을 블랙박스 메모리 저장소로 간주하고 주로 모델이 메모리에 접근하는 방식을 중심으로 연구합니다.

#### 지식 주입 (Knowledge Injection)

우리의 연구는 모델의 파라메트릭 메모리에 새로운 내용을 쓰는 것을 필요로 합니다. 모델 아키텍처를 변경하지 않고 이러한 지식 주입을 수행하는 주요 방법은 두 가지입니다 (Ovadia et al., 2024; Balaguer et al., 2024): 파인 튜닝(fine-tuning) 또는 검색 증강(retrieval augmentation). 검색 증강(Lewis et al., 2020; Shi et al., 2023)은 관련 정보를 검색하여 모델의 컨텍스트에 넣는 것이며, 파인 튜닝은 직접적으로 모델 파라미터를 업데이트합니다. 본 연구의 목표는 메모리에 쓴 후 모델이 파라메트릭 메모리에 어떻게 접근하는지를 조사하는 것이므로, 새로운 지식을 모델에 도입하는 방법으로 파인 튜닝을 선택합니다.

#### 지식 검색 (Knowledge Retrieval)

이전 연구들은 프롬프트를 사용하여 대규모 언어 모델에 저장된 지식을 효과적으로 검색할 수 있음을 보여주었습니다 (Bouraoui et al., 2019; Jiang et al., 2021; Wang et al., 2021). 우리는 이전 연구를 따라 프롬프트를 사용하여 모델에 암기된 내용을 접근하고 재생성하도록 요청합니다. 그러나 주목할 만한 차이점은 이전 연구들이 사전 학습 동안 모델이 얻은 지식을 이끌어내는 최적화된 방법을 찾는 데 중점을 두는 반면(Youssef et al., 2023; Liu et al., 2023; Yu et al., 2023), 우리는 고유 키를 사용하여 내용을 암기하고 검색하는 것을 직접적으로 사용한다는 점입니다.

#### 문서 색인으로서의 언어 모델 (Language Model as a Document Index)

우리는 언어 모델을 구절의 메모리 저장소로 간주합니다. 이는 문서 저장 및 검색을 위한 색인으로 언어 모델을 채택하는 최근의 발전과 관련이 있습니다 (Metzler et al., 2021; Tay et al., 2022; Wang et al., 2023; Zeng et al., 2023). 이러한 색인에서는 각 문서가 문서 식별자(ID)와 연결되며, 이는 키워드(Ren et al., 2023; Bevilacqua et al., 2022; Lee et al., 2023b, a) 또는 숫자(Tay et al., 2022; Wang et al., 2023; Zhuang et al., 2022; Zhou et al., 2022)일 수 있습니다. 우리도 이러한 관행을 따르며 문서를 저장하고 검색하기 위해 각 문서에 ID를 할당합니다. 그러나 우리는 질문에 대해 관련 ID를 검색하도록 모델에 요청하지 않습니다. 대신, 입력에 ID를 제공하고 해당 문서 내용을 순차적으로 또는 무작위로 접근할 가능성을 조사합니다.

### 3. 순차 및 무작위 메모리 접근 조사 (Investigating Sequential and Random Memory Access)

이 섹션에서는 언어 모델이 파라미터에 저장된 메모리에 순차적으로 또는 무작위로 접근할 수 있는 능력을 조사합니다. 먼저, 구절의 메모리 뱅크로서 언어 모델을 설명하는 공식을 제시합니다 (§3.1). 이 프레임워크 내에서 순차적 메모리 접근은 암기된 구절의 시작부터 시작하여 연속적으로 이후 내용을 생성하는 과정으로 정의됩니다. 반면, 무작위 메모리 접근은 모델이 암기된 구절의 임의의 위치에서 시작하여 정확하게 이후 내용을 재생성할 수 있는 능력으로 개념화됩니다. 이러한 정의를 바탕으로, 모델이 구절 전체를 단어 단위로 암송하도록 요구하여 순차적 메모리 접근 능력을 조사합니다 (§3.2). 다음으로, 암기된 구절에서 선택된 문장을 암송하도록 요구하여 모델의 무작위 접근 능력을 테스트합니다 (§3.3). 우리는 또한 질문 답변을 포함한 더 어려운 작업을 통해 모델의 무작위 접근 능력을 평가합니다 (§3.4).

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600">
<defs>
<marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
<polygon points="0 0, 10 3.5, 0 7" />
</marker>
</defs>
<!-- Title -->
<text x="400" y="30" text-anchor="middle" font-size="24" font-weight="bold">언어 모델의 메모리 접근 조사</text>
<!-- Main box -->
<rect x="50" y="50" width="700" height="500" fill="none" stroke="black" stroke-width="2"/>
<!-- Memory bank -->
<rect x="100" y="100" width="200" height="400" fill="lightblue" stroke="black"/>
<text x="200" y="90" text-anchor="middle" font-size="16">언어 모델의 메모리 뱅크</text>
<!-- Sequential Access -->
<rect x="400" y="100" width="300" height="180" fill="lightgreen" stroke="black"/>
<text x="550" y="125" text-anchor="middle" font-size="16">순차적 메모리 접근 (3.2)</text>
<text x="550" y="150" text-anchor="middle" font-size="14">시작부터 순차적으로 내용 생성</text>
<path d="M 300 200 L 400 200" stroke="black" stroke-width="2" marker-end="url(#arrowhead)"/>
<!-- Random Access -->
<rect x="400" y="320" width="300" height="180" fill="lightyellow" stroke="black"/>
<text x="550" y="345" text-anchor="middle" font-size="16">임의 메모리 접근 (3.3, 3.4)</text>
<text x="550" y="370" text-anchor="middle" font-size="14">임의의 위치에서 시작하여 내용 재생성</text>
<path d="M 300 400 L 400 400" stroke="black" stroke-width="2" marker-end="url(#arrowhead)"/>
<!-- Tasks -->
<text x="420" y="230" font-size="14">전체 구절 암송</text>
<text x="420" y="450" font-size="14">1. 선택된 문장 암송</text>
<text x="420" y="470" font-size="14">2. 질문 답변 태스크</text>
</svg>

### 3.1 작업 공식화 (Task Formulation)

우리는 언어 모델을 메모리 뱅크로 추상화하고 순차적 또는 무작위 접근 능력을 조사합니다. 메모리 뱅크를 키-값 저장소로 간단히 정의합니다 ? = {k\_i: p\_i} 여기서 k\_i 는 i 번째 구절에 할당된 고유 식별자(ID)를 나타냅니다.1 1 우리는 “문서”와 “구절”을 텍스트 조각을 가리키는 용어로 상호 교환하여 사용합니다.

메모리 뱅크는 읽기와 쓰기 두 가지 핵심 기능을 지원해야 합니다. 우리의 메모리 뱅크가 언어 모델로 구현되었기 때문에 모델의 메모리에 쓰고 읽는 것은 간단하지 않습니다. 이전 연구(Zhu and Li, 2023; Wang et al., 2021)를 따라, 메모리 뱅크에 쓰기 위해 우리는 파인 튜닝을 사용하여 모델의 파라미터를 업데이트합니다. 읽기 위해서는 프롬프트를 사용하여 모델의 메모리를 유도합니다. 구체적으로, 각 구절 p\_i 와 해당 식별자 k\_i 에 대해 쓰기 데이터 인스턴스 S\_write(k\_i, p\_i) 와 읽기 데이터 인스턴스 S\_read(k\_i) → p\_i 를 만듭니다. 여기서 S\_write 와 S\_read 는 부록 A.1에 상세히 설명된 프롬프트를 나타냅니다.

우리 연구의 주요 목표는 모델이 저장된 내용을 순차적으로 또는 무작위로 읽을 수 있는지 테스트하는 것입니다. 우리는 다양한 실험에서 읽기 기능을 변형합니다. M 개의 구절로 구성된 코퍼스를 고려하여, 우리는 코퍼스를 T 개의 훈련 구절과 V = M - T 개의 검증 구절로 나눕니다. Zhu와 Li(2023)의 설명에 따라 혼합 훈련 전략을 채택합니다. 훈련 단계에서 우리는 T 훈련 구절의 S\_write 및 S\_read 인스턴스와 V 검증 구절의 S\_write 인스턴스를 포함합니다. 우리의 목표는 모델이 훈련 구절의 읽기 및 쓰기 인스턴스를 통해 각 식별자와 구절 내용을 연관시키는 것을 학습하도록 하는 것입니다. 평가 시, 우리는 V 검증 구절의 S\_read 인스턴스로 모델에 프롬프트를 제공하여 모델의 메모리 접근 패턴을 테스트합니다.

<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600">
<defs>
<marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
<polygon points="0 0, 10 3.5, 0 7" />
</marker>
</defs>
<!-- Title -->
<text x="400" y="30" text-anchor="middle" font-size="24" font-weight="bold">언어 모델을 메모리 뱅크로 사용</text>
<!-- Memory Bank -->
<rect x="50" y="70" width="700" height="460" fill="none" stroke="black" stroke-width="2"/>
<text x="400" y="60" text-anchor="middle" font-size="18">메모리 뱅크 ? = {k\_i: p\_i}</text>
<!-- Write Operation -->
<rect x="100" y="100" width="250" height="180" fill="lightblue" stroke="black"/>
<text x="225" y="120" text-anchor="middle" font-size="16">쓰기 연산</text>
<text x="225" y="150" text-anchor="middle" font-size="14">S\_write(k\_i, p\_i)</text>
<text x="225" y="180" text-anchor="middle" font-size="14">파인 튜닝으로</text>
<text x="225" y="200" text-anchor="middle" font-size="14">파라미터 업데이트</text>
<!-- Read Operation -->
<rect x="450" y="100" width="250" height="180" fill="lightgreen" stroke="black"/>
<text x="575" y="120" text-anchor="middle" font-size="16">읽기 연산</text>
<text x="575" y="150" text-anchor="middle" font-size="14">S\_read(k\_i) → p\_i</text>
<text x="575" y="180" text-anchor="middle" font-size="14">프롬프트로</text>
<text x="575" y="200" text-anchor="middle" font-size="14">메모리 유도</text>
<!-- Corpus Division -->
<rect x="100" y="320" width="600" height="180" fill="lightyellow" stroke="black"/>
<text x="400" y="340" text-anchor="middle" font-size="16">코퍼스 분할</text>
<rect x="120" y="360" width="280" height="120" fill="lightpink" stroke="black"/>
<text x="260" y="380" text-anchor="middle" font-size="14">T 훈련 구절</text>
<text x="260" y="400" text-anchor="middle" font-size="12">S\_write 및 S\_read 포함</text>
<rect x="420" y="360" width="260" height="120" fill="lightcyan" stroke="black"/>
<text x="550" y="380" text-anchor="middle" font-size="14">V 검증 구절</text>
<text x="550" y="400" text-anchor="middle" font-size="12">S\_write만 포함 (훈련)</text>
<text x="550" y="420" text-anchor="middle" font-size="12">S\_read로 테스트 (평가)</text>
<!-- Arrows -->
<path d="M 225 280 L 225 320" stroke="black" stroke-width="2" marker-end="url(#arrowhead)"/>
<path d="M 575 280 L 575 320" stroke="black" stroke-width="2" marker-end="url(#arrowhead)"/>
</svg>

### 3.2 순차 접근: 전체 암송 (Sequential Access: Full Recitation)

우리는 언어 모델이 전체 구절 내용을 재생성하도록 요청하여 순차 접근 능력을 테스트합니다. 구체적으로, ID를 주어지면, 모델은 해당 암기된 구절의 시작부터 연속적으로 토큰을 생성하도록 프롬프트를 받습니다. 우리는 모델의 성능을 평가하여 제공된 키로 메모리의 구절 내용을 순차적으로 접근할 수 있는지 확인합니다.

#### 설정 (Setup)

모델이 다양한 유형의 식별자와 구절 내용을 처리할 수 있는지 조사하기 위해, 우리는 T = 400 및 V = 40 으로 설정하고 다음 변형을 고려합니다. 구절 내용 p 의 유형에 대해 두 가지 범주를 조사합니다: (1) 자연 언어(NL), SQuAD(Rajpurkar et al., 2016)에서 가져온 위키피디아 단락, (2) 랜덤 문자열(Rand), 각 NL 구절을 동일한 수의 토큰을 유지하며 공백으로 구분된 영숫자 문자열로 대체한 것. k 의 유형(즉, 구절 ID)에 대해 세 가지 형식을 탐구합니다: (1) 숫자 문자열(Num), 예를 들어 ‘#123’; (2) 드문 랜덤 토큰(Rare), Ruiz et al.(2022)의 접근 방식을 채택하여 세 개의 드문 토큰을 무작위로 샘플링한 것; (3) 구절이 속한 위키피디아 페이지의 기사 제목(Title).

우리는 GPT2-large 모델(Radford et al., 2019)을 기본 모델로 채택합니다. 더 나은 문자열 암기 능력을 위해(Stevens and Su, 2023), 우리는 모델을 처음부터 훈련시키는 대신 사전 훈련된 체크포인트2를 사용합니다.  <https://huggingface.co/gpt2> 모델이 완전히 수렴하도록 100 에포크 동안 파인 튜닝하며, 학습률은 3 × 10^{-5} 입니다. 우리는 BLEU 점수(Papineni et al., 2002)와 정확 일치(EM) 점수를 사용하여 암기된 내용과 실제 구절 사이의 유사성을 측정합니다.

### 표 1: 다양한 유형의 ID와 구절 내용으로 메모리에서 읽은 결과의 BLEU 및 정확 일치(Exact Match) 점수

|  |  |  |
| --- | --- | --- |
|  |  |  |
| 제목 (ID) | 숫자 (ID) | 희귀 (ID) |
| psg=NL | 96.2 / 85.0 | 96.7 / 95.0 |
| psg=Rand | 96.7 / 95.0 | 96.7 / 95.0 |

### 토론 (Discussion)

표 1은 모델이 암기된 내용을 순차적으로 접근할 수 있으며, 검증 구절에서 높은 BLEU 및 정확 일치(EM) 점수를 기록했음을 보여줍니다. 모델의 순차 접근 능력은 다양한 유형의 ID와 구절에 적응할 수 있음을 통해 더욱 입증됩니다. 구체적으로, 자연 언어 구절에 대한 키로 제목이나 숫자를 사용하는 것이 희귀 토큰을 사용하는 것보다 더 높은 성능을 보입니다. 우리는 모델이 희귀 토큰을 자연 언어 내용과 연관 짓는 데 어려움을 겪을 수 있다고 추측합니다. 주목할 만하게도, 모델의 접근 능력은 무작위 문자로 구성된 구절(Rand)에도 확장됩니다.

![](/assets/images/posts/235/img_1.png)

#### 그림 2: 검증 구절을 읽을 때의 EM 및 BLEU, 훈련 구절 수의 변동

우리는 모델이 최대 구절 길이(25)를 초과하여 생성을 계속하는 경향이 있기 때문에 EM을 계산할 때 처음 25개의 토큰만 사용합니다.

모델의 메모리 용량을 추가로 테스트하기 위해, 구절 유형을 Rand 로 설정하고 식별자 유형을 Rare 로 설정하여 각 구절에 25개의 무작위 토큰을 포함하는 추가 실험을 수행합니다. 그림 2에 나타난 바와 같이, V 를 1천으로 고정하고 T 를 1천에서 50만까지 점진적으로 증가시켜 순차 메모리 접근 능력을 검사합니다.

우리는 훈련 구절 수가 5만일 때에도 GPT2-large 모델이 암기된 검증 구절의 70% 이상을 정확히 재현하는 것을 관찰합니다. 그러나 파라메트릭 메모리에는 병목 현상이 있습니다: 구절 수가 10만을 초과하면 성능이 거의 0으로 떨어집니다. 이 병목 현상은 모델이 모든 구절을 암기하는 데 실패하면서 훈련이 수렴하지 못하기 때문이라고 생각합니다. 따라서 이후 실험에서는 모델이 모든 구절을 암기할 수 있도록 코퍼스 크기를 신중하게 관리합니다.

### 3.3 무작위 접근: 선택적 암송 (Random Access: Selective Recitation)

선택적 암송은 언어 모델에게 암기된 구절의 특정 문장을 재현하도록 요청하는 간단한 인공 작업입니다. 이 작업은 구절 내용에 대한 모델의 이해를 요구하지 않기 때문에 단순성을 위해 설계되었습니다. 초점은 오로지 모델이 암기된 구절의 특정 부분에 접근할 수 있는 능력에 있습니다. 성공적인 무작위 접근은 모델이 암기된 구절의 위치에 상관없이 임의의 문장을 재현할 수 있는 능력으로 나타납니다.

#### 설정 (Setup)

우리는 Mallick et al. (2023)을 따라 각 문장의 경계에 마커를 배치합니다. 이는 NLTK 문장 분할기를 통해 얻어집니다

3: {<https://www.nltk.org/api/nltk.tokenize.sent_tokenize.html>}

구절은 “[0] sent0 [0] [1] sent1 [1], …” 형식으로 구성됩니다. 이 경우 모델은 이러한 마커 사이의 내용을 복사하는 방법만 학습하면 됩니다. 우리의 선택적 암송 작업은 주어진 구절 ID k\_i​ 에 따라 구절 p\_i​ 의 j 번째 문장을 암송하도록 요구합니다. 읽기 함수는

![](/assets/images/posts/235/img_2.png)

와 같이 구성됩니다. 예를 들어, "Document #2033의 문장 [1]은 무엇입니까?"라는 질문으로 표현됩니다(그림 1 참조). 참조용으로, 우리는 구절 내용이 컨텍스트 창에 제공되는 기본 설정에서 모델의 성능도 테스트합니다.

우리가 정확한 암기를 테스트하고 있기 때문에, 모델을 평가하기 위해 BLEU 및 EM 점수를 사용합니다. §3.2와 유사하게, 우리는 T = 400 개의 훈련 구절과 V = 40 개의 검증 구절을 사용하며, 각각 1994개의 문장과 200개의 문장을 포함합니다. ID 유형은 {Title}로 설정하고 3개 이상의 문장을 포함하는 구절만 포함합니다. 다른 모든 하이퍼파라미터는 §3.2와 동일하게 유지합니다.

![](/assets/images/posts/235/img_3.png)

#### 그림 3: 마커 숫자에 따른 ID 기반 문장 암송의 정확도를 보여주는 누적 막대 그래프

문장 인덱스가 커질수록 성능이 크게 감소하여 모델이 중간 문장에 접근하는 데 어려움을 겪고 있음을 나타냅니다.

![](/assets/images/posts/235/img_4.png)

#### 표 2: 근거 기반 질문 답변 작업에 대한 EM 및 F1 점수, 그리고 폐쇄형 책 및 개방형 책 QA에 대한 기준 점수

굵게 표시된 숫자는 근거 기반 QA 설정에서 최고의 성능을 나타냅니다.

### 토론 (Discussion)

구절 ID를 제공해도 모델이 요청된 문장을 선택적으로 암송하는 데는 도움이 되지 않는다는 것을 발견했습니다. 구절 내용이 컨텍스트에 포함된 경우 EM 97.0 및 BLEU 97.3의 매우 높은 점수와 대조적으로, EM 34.5 및 BLEU 47.1의 낮은 점수를 기록했습니다. 그림 3의 상세 분석은 정확한 예측이 주로 첫 번째 문장을 암송하는 것임을 보여줍니다 ( j = 0 ). 이는 모델이 첫 번째 문장을 재현하기 위해 내용을 순차적으로 접근할 수 있음을 확인합니다. 그러나 마커 인덱스가 증가함에 따라 모델은 앞의 문장을 건너뛰고 구절 중간의 문장에 직접 접근해야 합니다. 모델의 성능이 급격히 떨어져 암기된 구절의 중간 또는 이후 문장에 무작위로 접근할 수 없음을 나타냅니다.

### 3.4 무작위 접근: 근거 기반 질문 답변 (Random Access: Grounded Question Answering)

모델이 고유 ID와 연결된 여러 구절을 암기할 수 있다는 §3.2의 이전 발견을 바탕으로, 우리는 더 실용적인 작업인 특정 구절 ID에 근거한 질문 답변에 착수합니다. 이 작업은 모델이 메모리에서 스팬을 추출하여 질문에 답할 수 있는지 평가하는 것을 목표로 합니다. 예를 들어, 질문이 “Document #3022에 따르면 쇼팽이 프랑스 시민이 된 해는 언제인가?”와 같이 구성될 수 있으며, 답은 ID #3022를 가진 구절에 있는 “1835”입니다. 우리는 언어 모델이 무작위 메모리 접근이 가능하다면 제공된 ID를 사용하여 해당 구절로 이동하고 관련 스팬을 추출하여 질문에 답할 수 있어야 한다고 가정합니다.

#### 설정 (Setup)

우리는 많은 질문이 구절에 강하게 의존하는 것으로 알려진 SQuAD-v1 (Rajpurkar et al., 2016) 데이터셋을 사용하여 실험을 수행합니다. 예를 들어, “전쟁은 어떻게 시작되었는가?”와 같은 질문은 기사를 참조하지 않으면 모호하고 답할 수 없습니다. 이 설계는 모델이 기존 지식이 아닌 암기된 ID와 구절에 의존하도록 강제합니다. 우리는 (1) 정답이 있는 황금 구절의 ID를 제공하는 경우, (2) 무작위로 잘못된 ID를 제공하는 경우, (3) ID를 제공하지 않는 경우의 변형으로 근거 기반 QA 작업을 탐구합니다. 비교를 위해, 모델의 파라메트릭 메모리에 구절을 쓰지 않는 설정도 고려합니다. 여기에는 QA 쌍에만 파인 튜닝하여 모델이 질문에 답하기 위해 사전 학습 동안 저장된 사전 지식에 의존하는 하한 기준인 폐쇄형 책 QA와, 질문과 황금 구절 내용을 연결하여 추출적 QA 성능의 상한을 설정하는 개방형 책 QA가 포함됩니다.

우리는 다양한 유형의 구절 ID로 실험을 수행합니다. 제목을 구절 ID로 사용하여 고유성을 보장하기 위해, 전체 SQuAD 데이터셋에서 T = 442 개의 구절과 V = 48 개의 구절을 선택하고 각각 2,000개 이상의 질문과 300개의 질문을 포함합니다. 모델은 원래 SQuAD 평가 스크립트를 따라 F1 및 EM으로 평가됩니다. 다른 하이퍼파라미터는 §3.2에서 언급한 것과 동일합니다.

### 토론 (Discussion)

결과는 표 2에 제시되어 있습니다(“+Recitation” 설정은 이후 섹션에서 논의됩니다). 예상대로 모델은 황금 구절에서 답을 찾아야 하는 개방형 책 설정에서 가장 높은 성능을 보입니다. 반면, 폐쇄형 책 QA 설정은 모델이 구절에 접근할 수 없고 사전 학습 동안 저장된 파라메트릭 지식에만 의존하기 때문에 가장 낮은 성능을 보입니다.

흥미롭게도 제공된 구절 ID의 형태는 성능에 거의 영향을 미치지 않습니다. 제목이 ID인 경우를 제외하고는, 황금 ID가 제공되든 아니든 성능은 유사합니다. 이 경우 무작위 잘못된 ID를 제공하면 성능이 저하됩니다. 이는 제목이 구절 주제와 관련된 엔터티인 경우가 많아 유용한 단서를 제공하기 때문일 수 있습니다. 의미론적 의미를 갖지 않는 ID(즉, Rare와 Num)인 경우, ID의 정확성이나 존재 여부는 성능에 큰 영향을 미치지 않으며, 이는 모델이 모든 구절을 암기했음에도 불구하고 여전히 개방형 책 설정보다 상당히 낮은 성능을 보입니다. 이는 모델이 올바른 구절 ID가 제공되더라도 답을 추출하는 데 어려움을 겪고 있어 무작위 메모리 접근 능력이 효과적이지 않음을 더욱 확인해줍니다.

요약하자면, 우리의 연구 결과는 언어 모델이 순차적으로 메모리에 접근할 수 있게 하여 메모리 뱅크로 효과적으로 기능할 수 있음을 확인합니다. 그러나 모델의 무작위 메모리 접근 능력에는 상당한 한계가 있습니다. 단순한 선택적 암송 작업과 복잡한 근거 기반 질문 답변 작업 모두에서 모델은 해당 구절 ID가 명시적으로 제공되었음에도 불구하고 메모리를 활용하여 작업을 수행하는 데 일관되게 실패합니다.

![](/assets/images/posts/235/img_5.png)

### 표 3: 구절 암송 및 순열 도입 후 선택적 문장 암송 실험의 BLEU 점수 및 EM 점수

### 4. 무작위 접근 문제 완화 (Mitigating Random Access Challenge)

이전 실험들은 일반적으로 언어 모델이 파라메트릭 메모리에 순차적으로 접근하는 데는 잘 수행하지만, 무작위 메모리 접근에서는 어려움을 겪는다는 것을 보여줍니다. 이는 자연스럽게 "무작위 메모리 접근의 단점을 어떻게 완화할 수 있을까?"라는 질문을 제기합니다.

### 4.1 제안된 방법 (Proposed Method)

이 문제를 해결하기 위해, 우리는 메모리 저장소로서의 언어 모델이 지원하는 두 가지 작업인 읽기와 쓰기에서 시작합니다. 쓰기 단계에서 우리는 구절 내용을 순열(permutation) 수행하는 것이 모델의 무작위 접근 능력을 자연스럽게 향상시킬 수 있다고 가정합니다. 즉, 내용의 어느 부분이든 암기된 시퀀스의 시작점이 될 수 있습니다. 이 설정에서는 구절 내용의 순차적 순서를 변경하여 무작위 접근을 달성합니다.

![](/assets/images/posts/235/img_6.png)

#### 그림 4: 낭독 방법의 일러스트레이션

모델이 질문에 직접 답하는 대신 먼저 해당 구절 내용을 암송한 후, 컨텍스트에서 답을 추출하는 과정을 보여줍니다.

읽기 단계에서는 모델의 컨텍스트 윈도우를 활용하는 것이 유효한 전략입니다. 주의 메커니즘(Vaswani et al., 2017)은 모델이 컨텍스트 윈도우 내의 모든 토큰에 접근할 수 있게 하여, 본질적으로 무작위 접근을 지원합니다(Packer et al., 2023; Ge et al., 2023). 주어진 ID가 있는 작업의 경우, 모델에게 먼저 구절을 순차적으로 암송하도록 한 다음 이를 컨텍스트에 배치하고, 이후 컨텍스트를 활용하여 스팬 추출 작업을 수행하도록 요청할 수 있습니다. 이는 그림 4에 설명되어 있습니다. 우리의 후속 실험은 이 두 방법의 효과를 평가하도록 설계되었습니다. 실증적 평가를 통해, 쓰기 단계에서의 내용 순열 또는 읽기 단계에서의 낭독이 무작위 메모리 접근 문제를 크게 완화하고 성능을 향상시킬 수 있음을 확인합니다.

#### 설정 (Setup)

우리는 읽기 및 쓰기 단계에 낭독과 순열을 통합하여 이전 실험을 확장합니다.

먼저, 선택적 문장 암송 작업에 설정을 추가합니다: 주어진 ID를 기반으로 모델이 먼저 해당 구절의 전체 내용을 암송한 후 특정 문장을 암송하도록 하여, 읽기 작업을

![](/assets/images/posts/235/img_7.png)

로 변경합니다. 유사하게, 근거 기반 QA 작업에서는 질문에 답하기 전에 입력된 구절 ID와 연관된 구절을 암송하도록 모델에게 요청합니다. ID가 없는 설정에서는 모델이 황금 구절을 암송하도록 훈련합니다.

쓰기 단계에서의 순열 효과를 탐구하기 위해, 우리는 구절 내 문장 사이에 순열을 수행하여 다양한

​

![](/assets/images/posts/235/img_8.png)

인스턴스를 만듭니다. J 문장 구절에 대해, 우리는 다음을 테스트합니다: (1) 첫 번째, 각 문장을 구절의 시작으로 이동하여 J 개의 고유 인스턴스를 만듭니다; (2) random-k, 문장을 무작위로 k 번 섞어 k 개의 인스턴스를 생성합니다. 여기서 k 는 기본적으로 4로 설정됩니다. 순열 효과가 단순히 더 많은 훈련 데이터 때문이 아니라는 것을 보여주기 위해, 각 구절을 훈련 데이터에서 J 번 중복하는 기준도 포함합니다.

### 토론 (Discussion)

표 3에 나타난 바와 같이, 구절 내용을 암송하는 것은 선택적 암송의 성능을 효과적으로 향상시킵니다. 암송을 통해 모델은 제공된 구절 ID를 사용하여 메모리에서 내용을 순차적으로 접근한 후 이를 컨텍스트에 로드하여 무작위 접근을 가능하게 합니다. 컨텍스트에서 암송된 내용을 조건으로 하여, 모델은 올바른 문장을 쉽게 식별할 수 있습니다.

유사하게, 명시적으로 황금 구절을 암송하는 것은 질문 답변 성능을 크게 향상시킵니다. 이는 표 2(+Recitation)에서 볼 수 있습니다. 이 관찰은 세 가지 구절 ID 유형 모두에서 일관됩니다. 반대로, 모델이 무작위 구절을 암송하도록 의도적으로 프롬프트하면 성능이 저하됩니다. 이는 무작위 구절이 관련 없는 정보를 도입하여 모델을 혼란스럽게 하기 때문일 가능성이 큽니다. 놀랍게도, 관련 구절을 암송하는 것은 ID 없이도 성능에 도움이 되지만, 황금 ID와 함께한 경우보다 개선 정도는 적습니다. 이는 질문 답변의 더 일반적인 설정에서 암송의 효과를 확인해줍니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

1. **황금 구절 (Golden Passage)**
   - **정의**: 질문에 대한 정답을 포함하고 있는 구절을 의미합니다. 질문이 이 구절에 기반하여 만들어졌기 때문에, 이 구절을 참조하면 정확한 답변을 얻을 수 있습니다.
   - **예시**: 질문이 "쇼팽이 프랑스 시민이 된 해는 언제인가?"라면, "1835년"이라는 답변을 포함하는 구절이 황금 구절입니다.
2. **황금이 아닌 구절 (Non-Golden Passage)**
   - **정의**: 질문에 대한 정답을 포함하지 않는 구절을 의미합니다. 질문에 직접적인 관련이 없는 정보가 포함된 구절입니다.
   - **예시**: 같은 질문에 대해 "쇼팽의 음악적 영향은 그의 전 생애에 걸쳐 느껴진다."와 같은 정보를 포함하는 구절은 황금이 아닌 구절입니다.

따라서 이는 당연한 걸 지도...

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

또 다른 무작위 접근을 향상시키는 방법은 문장의 순열을 수행하는 것입니다. 표 3에 제시된 바와 같이, 각 문장을 한 번씩 구절의 시작으로 가져오거나 여러 번 문장을 무작위로 섞는 것만으로도 구절 중간 내용을 접근하는 문제를 해결하는 데 도움이 됩니다. 반면, 원래 구절을 단순히 복제하는 것은 무작위 접근 향상에 기여하지 않습니다. 우리는 쓰기 단계에서의 순열이 근거 기반 QA 성능을 향상시킨다는 것도 관찰합니다. 이는 무작위 순열 횟수가 증가함에 따라 단조롭게 증가합니다. 그러나 순열이 파라메트릭 메모리의 본질적인 순차 접근 패턴을 변경하지 않는다는 점에 유의해야 합니다. 대신, 문장을 순열하고 원래 순서를 방해함으로써 구절의 중간이나 끝 부분에 있는 더 많은 문장이 ID를 통해 순차적으로 접근할 수 있게 합니다.

우리는 또한 이러한 결론이 더 큰 디코더 전용 언어 모델에도 일반화될 수 있음을 확인합니다. 부록 D에서 우리는 Qwen1.5-4b(Bai et al., 2023)와 Llama2-7B(Touvron et al., 2023b)에서 무작위 접근의 유사한 문제를 관찰하며, 이러한 문제는 우리의 제안된 낭독 및 순열 방법에 의해 효과적으로 완화될 수 있음을 확인합니다.

![](/assets/images/posts/235/img_9.png)

#### 표 4: 쓰기 단계에서 문장 순열을 수행한 결과의 EM 및 F1 점수

random-k는 순열이 k 번 수행됨을 의미합니다.

### 5. 사례 연구: 오픈 도메인 질문 답변 (Case Study: Open-Domain Question Answering)

![](/assets/images/posts/235/img_10.png)

#### 표 5: 오픈 도메인 질문 답변 데이터셋의 EM 및 F1 점수

모델이 먼저 구절을 암송한 후 답변을 제공하도록 훈련된 경우, 암송의 BLEU 점수를 보고합니다. 최고 성능은 굵게 표시되어 있습니다.

### 해석 (Translation)

우리의 연구 결과는 언어 모델이 메모리를 명시적으로 암송하여 컨텍스트에 로드하지 않는 한, 무작위 메모리 접근에 어려움을 겪는다는 것을 나타냅니다. 이러한 통찰을 바탕으로, 우리는 모델이 관련 기억을 먼저 검색하고 이를 바탕으로 추론해야 하는 도전적인 작업인 오픈 도메인 질문 답변으로 연구를 확장합니다. 이는 이전 실험과 다르게 구절 ID가 입력으로 제공되지 않습니다. 읽기 작업은

![](/assets/images/posts/235/img_11.png)

가 됩니다. 따라서 모델은 구절 ID의 도움 없이 쿼리에 대한 관련 구절을 찾아야 하며, 이는 간단한 작업이 아닙니다

(Pradeep et al., 2023). 우리의 연구 목표는 검색 성능에 있지 않으며, 이전 결과(§3.3)는 모델이 제한된 암기 용량을 가지고 있음을 보여주기 때문에, 우리는 모델의 메모리에 쓰인 구절 수를 제한하여 검색의 난이도를 낮춥니다: 최소 하나의 질문에 대한 답변을 포함하는 긍정적인 구절만 포함합니다.

우리는 실제 응용 프로그램에서 모델이 무작위 접근을 수행할 수 있는 능력을 테스트하고자 합니다. 구체적으로, 많은 구절을 암기한 모델이 메모리에서 정확하게 답변을 추출할 수 있는지를 조사합니다. 이전 실험과 유사하게, 우리는 모델이 관련 구절을 암송하도록 훈련된 후 질문에 답변하는 경우의 성능 차이를 관찰하고자 합니다. 우리는 많은 구절에 걸쳐 문장 순열을 수행하는 데 따른 높은 훈련 비용 때문에 순열 실험은 수행하지 않으며, 이는 향후 연구로 남깁니다.

#### 5.1 실험 설정 (Experimental Setup)

우리는 Karpukhin et al. (2020)에 의해 처리된 Natural Questions(Kwiatkowski et al., 2019)를 단일 홉 QA(single-hop QA)로 사용하여, 6000개의 훈련 질문과 모든 6489개의 검증 질문을 선택합니다. 총 10.9k 구절이 있습니다. 다중 홉 질문 답변(multi-hop QA)에는 각 질문에 두 개의 황금 구절이 있는 HotpotQA(Yang et al., 2018)를 사용합니다. 우리는 8k 훈련 질문과 distractor subset에서 모든 7405 검증 질문을 선택하며, 총 26.9k 구절이 있습니다.

기본 설정으로 QA 쌍만 포함된 훈련(즉, 폐쇄형 책 QA)에서 시작하여, 모델의 사전 학습에서 얻은 사전 지식을 평가합니다. 다음으로, 구절을 메모리에 쓰는 두 가지 유형의 훈련 전략을 고려합니다. 혼합 설정에서는 모델이 모든 구절의

![](/assets/images/posts/235/img_12.png)

인스턴스와 훈련 QA 쌍의 혼합물에 대해 파인 튜닝됩니다. 연속 설정에서는 모델이 먼저 모든 구절의

![](/assets/images/posts/235/img_13.png)

인스턴스에 대해 파인 튜닝된 후, QA에 대해 파인 튜닝됩니다. 암송의 효과를 테스트하기 위해, 모델이 답변하기 전에 황금 구절을 암송하도록 훈련된 설정도 포함합니다.

이 작업은 모델이 구절 검색과 질문 답변을 모두 수행해야 하기 때문에, 모델의 크기가 충분히 커야 합니다. 따라서 우리는 GPT2-XL(1.5B 파라미터)로 언어 모델을 업그레이드합니다. 혼합 설정에서는 모델을 학습률 3e-5로 20 에포크 동안 훈련합니다. 연속 설정에서는 먼저 구절에 대해 20 에포크 동안 훈련한 후, QA 쌍에 대해 추가로 20 에포크 동안 훈련합니다. 우리는 검증 질문에서 EM 점수에 기반하여 최고의 성능을 보고합니다.

### 5.2 결과 및 토론 (Results and Discussion)

표 5는 황금 구절을 모델의 메모리에 쓰는 것이 혼합 또는 연속 훈련 모두에서 기본 폐쇄형 책 설정보다 성능을 향상시킨다는 것을 보여줍니다. 이는 우리의 기대와 일치하며, 질문에 대한 답을 포함하는 구절을 메모리에 주입함으로써 모델의 지식을 풍부하게 합니다.

또한, 낭독(recitation)은 모델이 암기된 구절을 활용하고 접근하는 능력을 크게 향상시켜 성능의 눈에 띄는 개선을 가져옵니다. 이는 혼합 및 연속 훈련 설정 모두에서 관찰됩니다. 정확 일치(EM) 점수는 단일 및 다중 홉 QA 모두에서 3% 이상 증가합니다. 모델이 구절을 명시적으로 암송하고 이를 무작위 접근을 위해 컨텍스트에 로드할 때, 원래의 오픈 도메인 QA 작업은 추출적 QA의 더 쉬운 작업으로 축소됩니다. 그러나 낮은 낭독 BLEU 점수는 모델이 항상 황금 구절을 정확하게 암송하지 않는다는 것을 시사합니다. 만약 모델이 관련 구절을 정확하게 메모리에서 검색할 수 있다면 성능이 더욱 향상될 것이라고 기대합니다.

혼합 훈련 전략은 연속 훈련 설정보다 뛰어난 성능을 보입니다. 이는 혼합 훈련에서는 모델의 구절 내용 메모리가 지속적으로 갱신되기 때문일 가능성이 큽니다. 반면, 연속 훈련 동안 두 번째 단계는 훈련 구절에서의 QA 쌍만을 포함하여 검증 구절의 메모리가 희미해질 수 있습니다. 결과적으로, 낭독의 정확성이 떨어지며, 이는 BLEU 점수의 감소로 나타납니다.

우리의 결과는 Wei et al. (2023)와 Sun et al. (2023)의 발견과 일치하며, 중간 단계를 도입하거나 관련 구절을 생성하는 것이 다양한 작업에서 모델 성능을 향상시키는 데 도움이 된다는 것을 보여줍니다. 우리는 이 현상에 대한 대안을 제시합니다: 파라메트릭 메모리를 컨텍스트 윈도우에 로드하는 것이 암기된 정보에 대한 무작위 접근을 향상시키며, 모델이 이러한 향상에서 이익을 얻는다는 것입니다.

### 결론 (Conclusion)

우리는 언어 모델이 파라메트릭 메모리에 어떻게 접근하는지 경험적으로 연구합니다. 합성 및 현실 데이터에 대한 실험은 언어 모델이 암기된 내용을 순차적으로 충분히 재현할 수 있지만, 암기된 내용의 중간 부분에 대한 무작위 접근에서는 어려움을 겪는다는 것을 보여줍니다. 우리는 무작위 메모리 접근의 한계를 완화하기 위한 두 가지 효과적인 전략인 낭독과 순열을 식별합니다. 또한, 오픈 도메인 질문 답변에 대한 통제된 사례 연구를 통해 모델이 메모리를 암송하고 무작위로 접근할 수 있게 허용하면 성능이 크게 향상된다는 것을 보여줍니다. 전체적으로, 우리의 연구는 언어 모델에서 메모리 접근 패턴에 대한 더 깊은 이해를 제공할 뿐만 아니라, 실질적인 응용에서 무작위 메모리 접근 능력의 제한이 미치는 영향을 강조합니다.

### 한계 (Limitation)

이 연구에서는 디코더 전용 언어 모델의 메모리 접근 패턴을 주로 탐구합니다. 우리의 결론이 트랜스포머 기반의 다른 유형의 언어 모델(예: 인코더 전용 모델, 인코더-디코더 모델)에도 적용되는지 이해하기 위해서는 추가 연구가 필요합니다. 또한, 우리는 컴퓨팅 자원 제한으로 인해 7억 개 이상의 파라미터를 가진 더 큰 모델로 연구를 확장하지 않았습니다. 더 큰 언어 모델에서 메모리 접근 패턴의 확장 동작을 탐구하는 것도 가치가 있을 것입니다. 우리는 주로 고정된 크기의 텍스트 코퍼스에 대한 통제된 실험을 수행합니다. 대규모 사전 학습 코퍼스에 이러한 발견이 어떻게 적용될 수 있는지, 그리고 사전 학습된 언어 모델에 미치는 영향을 탐구하는 추가 연구가 필요할 수 있습니다.

### 윤리적 고려 사항 (Ethical Considerations)

이 방법은 모델의 메모리 접근을 강화하는 기술을 제안하기 때문에, 민감한 개인 정보를 모델의 메모리에서 추출하는 데 악용될 수 있습니다. 우리는 SQuAD-v1 (Rajpurkar et al., 2016), Natural Questions (Kwiatkowski et al., 2019), 그리고 Hotpot QA (Yang et al., 2018)와 같은 공개된 영어 데이터셋을 사용하며, GPT2와 같은 공개된 영어 언어 모델을 다양한 크기로 사용합니다 (Radford et al., 2019). 이러한 데이터셋과 모델에는 잠재적인 편향이 있을 수 있습니다.

### 감사의 글 (Acknowledgements)

Do Xuan Long, Yanxia Qin, Yisong Miao 및 NUS WING의 다른 멤버들의 제안과 의견에 감사드립니다. Tongyao Zhu는 Sea AI Lab의 산업 박사 과정 프로그램의 지원을 받습니다.

[2403.07805v3.pdf

0.63MB](./file/2403.07805v3.pdf)
