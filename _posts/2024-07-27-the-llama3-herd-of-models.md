---
title: "The Llama3 Herd of Models"
date: 2024-07-27 21:12:01
categories:
  - 인공지능
---

<https://ai.meta.com/research/publications/the-llama-3-herd-of-models/>

[The Llama 3 Herd of Models | Research - AI at Meta](https://ai.meta.com/research/publications/the-llama-3-herd-of-models/)

현대 인공지능(AI) 시스템은 기초 모델에 의해 구동됩니다. 이 논문에서는 Llama 3라는 새로운 기초 모델 세트를 소개합니다. Llama 3는 다중 언어 지원, 코딩, 추론 및 도구 사용을 원주적으로 지원하는 언어 모델의 군집입니다. 우리의 가장 큰 모델은 4050억 개의 매개변수를 가진 조밀한 Transformer이며 최대 128K 토큰의 컨텍스트 창을 가지고 있습니다. 이 논문에서는 Llama 3의 광범위한 실험적 평가를 제시합니다. 우리는 Llama 3가 다양한 작업에서 GPT-4와 같은 선도적인 언어 모델과 비교할 만한 품질을 제공한다는 것을 발견했습니다. 우리는 4050억 개 매개변수를 가진 언어 모델의 사전 훈련 및 사후 훈련 버전과 입력 및 출력 안전성을 위한 Llama Guard 3 모델을 포함하여 Llama 3를 공개적으로 출시합니다. 또한 이 논문에서는 Llama 3에 이미지, 비디오 및 음성 기능을 통합하는 실험 결과를 제시합니다. 우리는 이 접근법이 이미지, 비디오 및 음성 인식 작업에서 최첨단과 경쟁할 수 있는 성능을 보인다는 것을 관찰했습니다.

결과 모델은 아직 개발 중이기 때문에 광범위하게 출시되지는 않았습니다. 날짜: 2024년 7월 23일 웹사이트: <https://llama.meta.com/>

[Llama 3.1](https://llama.meta.com/)

### 1. 서론

기초 모델은 언어, 시각, 음성 등 다양한 모달리티를 지원하도록 설계된 일반 모델로, 많은 현대 AI 시스템의 기반을 형성합니다. 현대 기초 모델의 개발은 두 가지 주요 단계로 구성됩니다. 첫째, 대규모 데이터로 간단한 작업(예: 다음 단어 예측이나 캡션 작성)을 통해 모델을 훈련하는 사전 훈련 단계가 있습니다. 둘째, 모델을 조정하여 명령을 따르고, 인간의 선호와 일치시키며, 특정 능력(예: 코딩 및 추론)을 향상시키는 사후 훈련 단계가 있습니다.

이 논문에서는 Llama 3라는 새로운 언어 기초 모델 세트를 소개합니다. Llama 3 모델 군집은 다중 언어 지원, 코딩, 추론 및 도구 사용을 원주적으로 지원합니다. 우리의 가장 큰 모델은 4050억 개의 매개변수를 가진 조밀한 Transformer로, 최대 128K 토큰의 컨텍스트 창을 처리합니다. 이 논문에 제시된 모든 결과는 Llama 3.1 모델에 대한 것이며, 간단히 Llama 3로 지칭합니다.

우리는 고품질 기초 모델 개발의 세 가지 주요 요인으로 데이터를 꼽습니다: 데이터, 규모, 복잡성 관리. 우리는 이러한 세 가지 요인을 최적화하려고 합니다:

- **데이터**: 이전 버전의 Llama (Touvron et al., 2023a,b)와 비교하여, 우리는 사전 훈련 및 사후 훈련에 사용하는 데이터의 양과 질을 개선했습니다. 이러한 개선에는 사전 훈련 데이터에 대한 더 신중한 전처리 및 큐레이션 파이프라인 개발과 사후 훈련 데이터에 대한 더 엄격한 품질 보증 및 필터링 접근법 개발이 포함됩니다. 우리는 Llama 3를 약 15조 개의 다중 언어 토큰 코퍼스를 사용하여 사전 훈련했으며, 이는 Llama 2의 1.8조 토큰과 비교됩니다.
- **규모**: 우리는 이전 Llama 모델보다 훨씬 더 큰 규모로 모델을 훈련합니다. 우리의 대표 언어 모델은 3.8 × 10²⁵ FLOPs를 사용하여 사전 훈련되었으며, 이는 Llama 2의 가장 큰 버전보다 거의 50배 더 큽니다. 구체적으로, 우리는 4050억 개의 매개변수를 가진 대표 모델을 15.6조 개의 텍스트 토큰으로 사전 훈련했습니다. 기초 모델의 스케일링 법칙에 따라, 우리의 대표 모델은 같은 절차로 훈련된 작은 모델보다 성능이 뛰어납니다. 우리는 대표 모델을 사용하여 사후 훈련 중에 작은 모델의 품질을 더욱 향상시킵니다.
- **복잡성 관리**: 우리는 모델 개발 과정을 확장할 수 있는 설계를 선택합니다. 예를 들어, 혼합 전문가 모델(Shazeer et al., 2017)보다는 표준 조밀한 Transformer 모델(Vaswani et al., 2017) 아키텍처를 소규모로 채택하여 훈련 안정성을 극대화합니다. 마찬가지로, 우리는 감독된 미세 조정(SFT), 거부 샘플링(RS), 직접 선호 최적화(DPO; Rafailov et al., 2023)를 기반으로 한 비교적 간단한 사후 훈련 절차를 채택하여 복잡한 강화 학습 알고리즘(Ouyang et al., 2022; Schulman et al., 2017)을 사용하는 것보다 안정성이 높고 확장 가능성이 크도록 합니다.

우리의 작업 결과는 Llama 3로, 8B, 70B 및 405B 매개변수를 가진 세 가지 다중 언어 언어 모델의 군집입니다. 우리는 Llama 3의 성능을 다양한 언어 이해 작업을 포함한 광범위한 벤치마크 데이터 세트에서 평가합니다. 또한 Llama 3를 경쟁 모델과 비교하는 광범위한 인간 평가를 수행합니다. 대표적인 Llama 3 모델의 주요 벤치마크 성능 개요는 Table 2에 제시되어 있습니다. 우리의 실험적 평가는 대표 모델이 다양한 작업에서 GPT-4(OpenAI, 2023a)와 같은 선도적인 언어 모델과 동등한 성능을 제공하며, 최신 기술 수준에 근접하고 있음을 시사합니다. 우리의 작은 모델은 유사한 매개변수를 가진 대안 모델(Bai et al., 2023; Jiang et al., 2023)을 능가합니다. Llama 3는 이전 버전(Touvron et al., 2023b)보다 유용성과 무해성의 균형이 훨씬 좋습니다. Llama 3의 안전성에 대한 상세 분석은 섹션 5.4에 제시되어 있습니다.

우리는 세 가지 Llama 3 모델을 업데이트된 Llama 3 커뮤니티 라이선스 하에 공개합니다; 자세한 내용은 <https://llama.meta.com>을 참조하세요. 여기에는 405B 매개변수 언어 모델의 사전 훈련 및 사후 훈련 버전과 입력 및 출력 안전을 위한 새로운 버전의 Llama Guard 모델(Inan et al., 2023)이 포함됩니다. 우리는 대표 모델의 공개가 연구 커뮤니티에서 혁신의 물결을 일으키고 인공지능의 발전을 가속화할 것을 기대합니다.

Llama 3 개발 과정의 일환으로 이미지 인식, 비디오 인식, 음성 이해 기능을 가능하게 하는 다중 모달 확장을 개발했습니다. 이러한 모델은 아직 개발 중이며 공개 준비가 되지 않았습니다. 우리의 언어 모델링 결과 외에도, 이 논문은 이러한 다중 모달 모델에 대한 초기 실험 결과를 제시합니다.

![](/assets/images/posts/219/img.png)

Table 1: Llama 3 모델 군집 개요. 이 논문의 모든 결과는 Llama 3.1 모델에 대한 것입니다.

#### 주요 벤치마크 평가에서의 성능

![](/assets/images/posts/219/img_1.png)

|  |  |  |  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  |  | Llama 3 8B | Gemma 2 9B | Mistral 7B | Llama 3 70B | Mixtral 8x22B | GPT 3.5 Turbo | Llama 3 405B | Nemotron 4 340B | GPT-4 (0125) | GPT-4o | Claude 3.5 Sonnet |
| 일반 | MMLU (5-shot) | 69.4 | 72.3 | 61.1 | 83.6 | 76.9 | 70.7 | 87.3 | 82.6 | 85.1 | 89.1 | 89.9 |
|  | MMLU (0-shot, CoT) | 73.0 | 72.34 | 60.5 | 86.0 | 79.9 | 69.8 | 88.6 | 78.7/ 85.4 | 88.7 | 88.3 |  |
|  | MMLU-Pro (5-shot, CoT) | 48.3 | - | 36.9 | 66.4 | 56.3 | 49.2 | 73.3 | 62.7 | 64.8 | 74.0 | 77.0 |
|  | IFEval | 80.4 | 73.6 | 57.6 | 87.5 | 72.7 | 69.9 | 88.6 | 85.1 | 84.3 | 85.6 | 88.0 |
| 코드 | HumanEval (0-shot) | 72.6 | 54.3 | 40.2 | 80.5 | 75.6 | 68.0 | 89.0 | 73.2 | 86.6 | 90.2 | 92.0 |
|  | MBPP EvalPlus (0-shot) | 72.8 | 71.7 | 49.5 | 86.0 | 78.6 | 82.0 | 88.6 | 72.8 | 83.6 | 87.8 | 90.5 |
| 수학 | Math GSM8K (8-shot, CoT) | 84.5 | 76.7 | 53.2 | 95.1 | 88.2 | 81.6 | 96.8 | 92.3} | 94.2 | 96.1 | 96.4} |
|  | MATH (0-shot, CoT) | 51.9 | 44.3 | 13.0 | 68.0 | 54.1 | 43.1 | 73.8 | 41.1 | 64.5 | 76.6 | 71.1 |
| 추론 | ARC Challenge (0-shot) | 83.4 | 87.6 | 74.2 | 94.8 | 88.7 | 83.7 | 96.9 | 94.6 | 96.4 | 96.7 | 96.7 |
|  | GPQA (0-shot, CoT) | 32.8 | - | 28.8 | 46.7 | 33.3 | 30.8 | 51.1 | - | 41.4 | 53.6 | 59.4 |
| 도구 사용 | BFCL | 76.1 | - | 60.4 | 84.8 | - | 85.9 | 88.5 | 86.5 | 88.3 | 80.5 | 90.2 |
|  | Nexus | 38.5 | 30.0 | 24.7 | 56.7 | 48.5 | 37.2 | 58.7 | - | 50.3 | 56.1 | 45.7 |
| 긴 컨텍스트 | ZeroSCROLLS/QuALITY | 81.0 | - | - | 90.5 | - | - | 95.2 | - | 95.2 | 90.5 | 90.5 |
|  | InfiniteBench/En.MC | 65.1 | - | - | 78.2 | - | - | 83.4 | - | 72.1 | 82.5 | - |
|  | NIH/Multi-needle | 98.8 | - | - | 97.5 | - | - | 98.1 | - | 100.0 | 100.0 | 90.8 |
| 다중 언어 | MGSM (0-shot, CoT) | 68.9 | 53.2 | 29.9 | 86.9 | 71.1 | 51.4 | 91.6 | - | 85.9 | 90.5 | 91.6 |

Table 2: 주요 벤치마크 평가에서 세부 조정된 Llama 3 모델의 성능. 표는 8B, 70B 및 405B 버전의 Llama 3 성능을 경쟁 모델과 비교합니다. 세 가지 모델 크기 동등성 클래스에서 최고 성능을 나타내는 모델을 볼드체로 표시했습니다. 결과는 5-shot 프롬프팅(일부는 CoT 제외), zero-shot 프롬프팅을 사용한 결과를 포함합니다.

### 2. 개요

Llama 3의 모델 아키텍처는 그림 1에 설명되어 있습니다. Llama 3 언어 모델의 개발은 두 가지 주요 단계로 구성됩니다:

- **언어 모델 사전 훈련**: 우리는 대규모 다중 언어 텍스트 코퍼스를 이산 토큰으로 변환한 후, 생성된 데이터를 사용하여 대규모 언어 모델(LLM)을 사전 훈련하여 다음 토큰을 예측하도록 합니다. 언어 모델 사전 훈련 단계에서 모델은 언어 구조를 배우고, 읽는 텍스트에서 세상에 대한 많은 지식을 얻습니다. 이를 효과적으로 수행하기 위해 사전 훈련은 대규모로 수행됩니다. 우리는 4050억 개의 매개변수를 가진 모델을 15.6조 개의 토큰과 8K 토큰의 컨텍스트 창을 사용하여 사전 훈련합니다. 이 표준 사전 훈련 단계 후, 지원되는 컨텍스트 창을 128K 토큰으로 확장하는 지속 사전 훈련 단계가 이어집니다. 자세한 내용은 섹션 3을 참조하세요.
- **언어 모델 사후 훈련**: 사전 훈련된 언어 모델은 풍부한 언어 이해력을 가지고 있지만, 우리가 기대하는 방식으로 명령을 따르거나 동작하지 않습니다. 우리는 여러 라운드의 인간 피드백을 통해 모델을 조정합니다. 각 라운드에는 명령 조정 데이터를 통한 감독된 미세 조정(SFT)과 직접 선호 최적화(DPO; Rafailov et al., 2024)가 포함됩니다. 이 사후 훈련 단계에서는 도구 사용과 같은 새로운 기능도 통합하며, 코딩 및 추론과 같은 다른 영역에서도 큰 개선을 관찰합니다. 자세한 내용은 섹션 4를 참조하세요. 마지막으로, 사후 훈련 단계에서 모델에 안전성 완화 조치도 통합되며, 이에 대한 자세한 내용은 섹션 5.4에 설명되어 있습니다.

이러한 과정으로 생성된 모델은 풍부한 기능 세트를 갖추게 됩니다. 이 모델들은 최소 8개 언어로 질문에 답하고, 고품질의 코드를 작성하며, 복잡한 추론 문제를 해결하고, 도구를 바로 사용하거나 제로샷 방식으로 사용할 수 있습니다. 또한, 우리는 Llama 3에 이미지, 비디오 및 음성 기능을 추가하는 실험을 수행하였으며, 이는 조합적 접근법을 사용합니다. 우리가 연구한 접근법은 그림 28에 설명된 세 가지 추가 단계를 포함합니다:

- **다중 모달 인코더 사전 훈련**: 우리는 이미지와 음성을 위한 별도의 인코더를 훈련합니다. 우리의 이미지 인코더는 대규모의 이미지-텍스트 쌍으로 훈련됩니다. 이를 통해 모델은 시각적 콘텐츠와 자연 언어로 된 설명 간의 관계를 학습합니다. 우리의 음성 인코더는 음성 입력의 일부를 마스킹하고, 이 마스킹된 부분을 이산 토큰 표현을 통해 재구성하려는 자기지도 접근법을 사용하여 훈련됩니다. 결과적으로 모델은 음성 신호의 구조를 학습합니다. 이미지 인코더에 대한 자세한 내용은 섹션 7을, 음성 인코더에 대한 자세한 내용은 섹션 8을 참조하세요.
- **비전 어댑터 훈련**: 우리는 사전 훈련된 이미지 인코더를 사전 훈련된 언어 모델에 통합하는 어댑터를 훈련합니다. 어댑터는 이미지 인코더 표현을 언어 모델에 전달하는 일련의 크로스 어텐션 레이어로 구성됩니다. 어댑터는 텍스트-이미지 쌍으로 훈련되며, 이는 이미지 표현을 언어 표현과 정렬시킵니다. 어댑터 훈련 중에는 이미지 인코더의 매개변수도 업데이트하지만, 의도적으로 언어 모델의 매개변수는 업데이트하지 않습니다. 또한 우리는 텍스트-비디오 데이터 쌍으로 이미지 어댑터 위에 비디오 어댑터를 훈련합니다. 이는 모델이 프레임 간의 정보를 통합할 수 있게 합니다. 자세한 내용은 섹션 7을 참조하세요.
- **음성 어댑터 훈련**: 마지막으로, 우리는 음성 인코더를 모델에 통합하는 어댑터를 훈련합니다. 이 어댑터는 음성 인코딩을 미세 조정된 언어 모델에 직접 입력할 수 있는 토큰 표현으로 변환합니다. 어댑터와 인코더의 매개변수는 고품질의 음성 이해를 가능하게 하기 위해 감독된 미세 조정 단계에서 공동으로 업데이트됩니다. 음성 어댑터 훈련 중에는 언어 모델을 변경하지 않습니다. 우리는 또한 텍스트-음성 시스템을 통합합니다. 자세한 내용은 섹션 8을 참조하세요.

우리의 다중 모달 실험 결과, 이미지와 비디오의 콘텐츠를 인식하고 음성 인터페이스를 통해 상호작용할 수 있는 모델이 만들어졌습니다. 이러한 모델들은 아직 개발 중이며 출시 준비가 되어 있지 않습니다.

![](/assets/images/posts/219/img_2.png)

그림 1: Llama 3의 전체 아키텍처 및 훈련에 대한 설명. Llama 3는 텍스트 시퀀스의 다음 토큰을 예측하도록 훈련된 Transformer 언어 모델입니다. 자세한 내용은 본문을 참조하세요.

### 3. 사전 훈련

언어 모델 사전 훈련은 다음과 같은 작업을 포함합니다: (1) 대규모 훈련 코퍼스의 큐레이션 및 필터링, (2) 모델 아키텍처 개발 및 모델 크기를 결정하기 위한 스케일링 법칙 개발, (3) 대규모 효율적 사전 훈련 기법 개발, (4) 사전 훈련 레시피 개발. 이들 각 구성 요소를 아래에 각각 제시합니다.

#### 3.1 사전 훈련 데이터

우리는 2023년 말까지의 지식을 포함하는 다양한 데이터 소스에서 언어 모델 사전 훈련을 위한 데이터셋을 만듭니다. 각 데이터 소스에 여러 중복 제거 방법과 데이터 정리 메커니즘을 적용하여 고품질의 토큰을 얻습니다. 개인 식별 정보(PII)가 많이 포함된 도메인과 성인 콘텐츠가 알려진 도메인은 제거합니다.

3.1.1 웹 데이터 큐레이션

우리가 사용하는 데이터의 대부분은 웹에서 얻은 것이며, 아래에 우리의 정리 과정을 설명합니다.

- **PII 및 안전 필터링**: 우리는 불안전한 콘텐츠나 많은 PII가 포함될 가능성이 높은 웹사이트의 데이터를 제거하기 위한 필터를 구현합니다. Meta 안전 기준에 따라 해로운 것으로 분류된 도메인과 성인 콘텐츠가 포함된 도메인을 제거합니다.
- **텍스트 추출 및 정리**: 우리는 비축약 웹 문서의 원시 HTML 콘텐츠를 처리하여 고품질의 다양한 텍스트를 추출합니다. 이를 위해, HTML 콘텐츠를 추출하고, 보일러플레이트 제거 및 콘텐츠 회수를 최적화하는 맞춤 파서를 구축합니다. 우리의 파서는 인기 있는 서드파티 HTML 파서와 비교하여 인간 평가에서 우수한 성능을 보였습니다. 수학 및 코드 콘텐츠가 포함된 HTML 페이지는 해당 콘텐츠의 구조를 유지하도록 신중하게 처리합니다. 수학 콘텐츠는 종종 사전 렌더링된 이미지로 제공되며 alt 속성에 수학이 포함되어 있기 때문에 이미지의 alt 속성 텍스트를 유지합니다. 다양한 정리 구성 실험을 수행한 결과, 웹 데이터를 주로 훈련하는 모델에서는 마크다운이 성능에 해롭다는 것을 발견하여 모든 마크다운 마커를 제거합니다.
- **중복 제거**: URL, 문서, 라인 수준에서 여러 차례의 중복 제거를 적용합니다:
  - **URL 수준 중복 제거**: 전체 데이터셋에서 URL 수준의 중복 제거를 수행합니다. 각 URL에 해당하는 페이지의 최신 버전을 유지합니다.
  - **문서 수준 중복 제거**: 전체 데이터셋에서 글로벌 MinHash (Broder, 1997) 중복 제거를 수행하여 거의 중복 문서를 제거합니다.
  - **라인 수준 중복 제거**: ccNet (Wenzek et al., 2019)과 유사한 공격적인 라인 수준 중복 제거를 수행합니다. 각 3천만 문서의 버킷에서 6회 이상 나타난 라인을 제거합니다. 우리의 수동 질적 분석에서는 라인 수준 중복 제거가 탐색 메뉴, 쿠키 경고 등 다양한 웹사이트의 남은 보일러플레이트뿐만 아니라 빈번한 고품질 텍스트도 제거된다는 것을 보여주었지만, 우리의 경험적 평가에서는 강력한 개선을 보였습니다.
- **휴리스틱 필터링**: 추가적인 저품질 문서, 이상치, 과도한 반복을 포함한 문서를 제거하기 위한 휴리스틱을 개발합니다. 예를 들어:
  - 우리는 중복된 n-그램 커버리지 비율(Rae et al., 2021)을 사용하여 로그나 오류 메시지와 같은 반복된 콘텐츠로 구성된 라인을 제거합니다. 이러한 라인은 매우 길고 독특할 수 있어 라인 중복 제거로는 필터링할 수 없습니다.
  - 도메인 차단 목록에 포함되지 않은 성인 웹사이트를 필터링하기 위해 "더러운 단어" 카운팅(Raffel et al., 2020)을 사용합니다.
  - 훈련 코퍼스 분포와 비교하여 과도한 수의 이상치 토큰을 포함한 문서를 필터링하기 위해 토큰 분포 Kullback-Leibler 다이버전스를 사용합니다.
- **모델 기반 품질 필터링**: 다양한 모델 기반 품질 분류기를 적용하여 고품질 토큰을 선택하는 실험을 수행합니다. 여기에는 Wikipedia에서 참조될 가능성이 있는 텍스트를 인식하도록 훈련된 fasttext (Joulin et al., 2017)와 Llama 2 예측에 대해 훈련된 Roberta 기반 분류기(Liu et al., 2019a)를 사용합니다. Llama 2를 기반으로 품질 분류기를 훈련하기 위해, 정리된 웹 문서의 훈련 세트를 만들고 품질 요구사항을 설명하며, Llama 2의 채팅 모델에게 문서가 이러한 요구사항을 충족하는지 여부를 결정하도록 지시합니다. 효율성 이유로 DistilRoberta (Sanh et al., 2019)를 사용하여 각 문서에 대한 품질 점수를 생성합니다. 다양한 품질 필터링 구성의 효능을 실험적으로 평가합니다.
- **코드 및 추론 데이터**: DeepSeek-AI et al. (2024)와 유사하게, 우리는 코드 및 수학 관련 웹 페이지를 추출하는 도메인별 파이프라인을 구축합니다. 특히, 코드 및 추론 분류기는 Llama 2가 주석을 달아놓은 웹 데이터를 기반으로 훈련된 DistilledRoberta 모델입니다. 일반 품질 분류기와 달리, 우리는 수학 추론, STEM 영역의 추론 및 자연 언어와 코드가 혼합된 웹 페이지를 대상으로 하는 프롬프트 튜닝을 수행합니다. 코드와 수학의 토큰 분포가 자연 언어와 상당히 다르기 때문에, 이러한 파이프라인은 도메인별 HTML 추출, 맞춤 텍스트 특성 및 필터링을 위한 휴리스틱을 구현합니다.

### 다중 언어 데이터

영어 처리 파이프라인과 유사하게, 우리는 개인 식별 정보(PII)나 불안전한 콘텐츠가 포함될 가능성이 높은 웹사이트의 데이터를 제거하기 위한 필터를 구현합니다. 우리의 다중 언어 텍스트 처리 파이프라인은 다음과 같은 고유한 특징을 가지고 있습니다:

- 우리는 fasttext 기반 언어 식별 모델을 사용하여 문서를 176개의 언어로 분류합니다.
- 각 언어의 데이터 내에서 문서 수준 및 라인 수준 중복 제거를 수행합니다.

우리는 언어별 휴리스틱과 모델 기반 필터를 적용하여 저품질 문서를 제거합니다. 또한, 다중 언어 Llama 2 기반 분류기를 사용하여 다중 언어 문서의 품질 순위를 매겨 고품질 콘텐츠가 우선되도록 합니다. 우리는 영어와 다중 언어 벤치마크에서 모델 성능을 균형 있게 유지하기 위해 사전 훈련에 사용되는 다중 언어 토큰의 양을 실험적으로 결정합니다.

#### 3.1.2 데이터 믹스 결정

고품질 언어 모델을 얻기 위해서는 사전 훈련 데이터 믹스에서 다양한 데이터 소스의 비율을 신중하게 결정하는 것이 중요합니다. 데이터 믹스를 결정하는 주요 도구는 지식 분류와 스케일링 법칙 실험입니다.

- **지식 분류**: 우리는 웹 데이터에 포함된 정보 유형을 분류하기 위해 분류기를 개발하여 데이터 믹스를 보다 효과적으로 결정합니다. 이 분류기를 사용하여 예술과 엔터테인먼트와 같이 웹에서 과도하게 대표되는 데이터 범주를 다운샘플링합니다.
- **데이터 믹스를 위한 스케일링 법칙**: 최적의 데이터 믹스를 결정하기 위해, 우리는 여러 작은 모델을 데이터 믹스에서 훈련하고 이를 사용하여 큰 모델의 성능을 예측하는 스케일링 법칙 실험을 수행합니다(섹션 3.2.1 참조). 이 과정을 여러 번 반복하여 새로운 데이터 믹스 후보를 선택합니다. 이후, 이 후보 데이터 믹스에서 큰 모델을 훈련하고 여러 주요 벤치마크에서 해당 모델의 성능을 평가합니다.
- **데이터 믹스 요약**: 우리의 최종 데이터 믹스는 일반 지식에 해당하는 토큰 50%, 수학 및 추론 토큰 25%, 코드 토큰 17%, 다중 언어 토큰 8%로 구성됩니다.

#### 3.1.3 데이터 어닐링

경험적으로, 소량의 고품질 코드 및 수학 데이터를 어닐링(annealing, 섹션 3.4.3 참조)하면 주요 벤치마크에서 사전 훈련된 모델의 성능을 향상시킬 수 있다는 것을 발견했습니다. Li et al. (2024b)와 유사하게, 우리는 선택된 도메인의 고품질 데이터를 업샘플링한 데이터 믹스로 어닐링을 수행합니다. 우리의 어닐링 데이터에는 일반적으로 사용되는 벤치마크의 훈련 세트를 포함하지 않습니다. 이는 Llama 3의 진정한 몇 샷 학습 능력과 도메인 외 일반화를 평가할 수 있게 합니다.

OpenAI (2023a)를 따라, 우리는 GSM8k (Cobbe et al., 2021) 및 MATH (Hendrycks et al., 2021b) 훈련 세트에서 어닐링의 효과를 평가합니다. 어닐링은 사전 훈련된 Llama 3 8B 모델의 GSM8k 및 MATH 검증 세트에서 성능을 각각 24.0% 및 6.4% 향상시켰습니다. 그러나 405B 모델에서는 향상이 미미하여 우리의 주력 모델이 강력한 인컨텍스트 학습 및 추론 능력을 가지고 있으며, 특정 도메인의 훈련 샘플 없이도 우수한 성능을 발휘할 수 있음을 시사합니다.

데이터 품질 평가를 위한 어닐링 사용: Blakeney et al. (2024)와 유사하게, 우리는 어닐링을 통해 소규모 도메인별 데이터셋의 가치를 판단할 수 있다는 것을 발견했습니다. 우리는 50% 훈련된 Llama 3 8B 모델의 학습률을 400억 토큰에서 0으로 선형 어닐링하여 이러한 데이터셋의 가치를 측정합니다. 이 실험에서 새로운 데이터셋에 30% 가중치를, 기본 데이터 믹스에 70% 가중치를 할당합니다. 새로운 데이터 소스를 평가하기 위해 어닐링을 사용하는 것은 모든 소규모 데이터셋에 대해 스케일링 법칙 실험을 수행하는 것보다 더 효율적입니다.

### 3.2 모델 아키텍처

Llama 3는 표준 조밀형 Transformer 아키텍처(Vaswani et al., 2017)를 사용합니다. 모델 아키텍처 측면에서 Llama와 Llama 2(Touvron et al., 2023a, b)와 크게 다르지 않으며, 우리의 성능 향상은 주로 데이터 품질과 다양성의 개선 및 훈련 규모의 증가에 의해 이루어졌습니다. 우리는 Llama 3와 비교하여 몇 가지 작은 수정 사항을 적용했습니다:

- 8개의 키-값 헤드를 가진 그룹화된 쿼리 어텐션(GQA; Ainslie et al. (2023))을 사용하여 추론 속도를 개선하고 디코딩 중 키-값 캐시의 크기를 줄였습니다.
- 동일한 시퀀스 내의 다른 문서 간의 자기 주의를 방지하는 어텐션 마스크를 사용합니다. 이 변경은 표준 사전 훈련 중에는 제한된 영향을 미쳤지만, 매우 긴 시퀀스에 대한 지속 사전 훈련에서는 중요하다는 것을 발견했습니다.

#### 주요 하이퍼파라미터 개요

|  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  |  |  |  |  |  |  |  |  |  |
| 모델 | 레이어 수 | 모델 차원 | FFN 차원 | 어텐션 헤드 | 키/값 헤드 | 최대 학습률 | 활성화 함수 | 어휘 크기 | 위치 임베딩 |
| Llama 3 8B | 32 | 4096 | 6144 | 32 | 8 | 3 × 10⁻⁴ | SwiGLU | 128,000 | RoPE (θ = 500,000) |
| Llama 3 70B | 80 | 8192 | 12,288 | 64 | 8 | 1.5 × 10⁻⁴ | SwiGLU | 128,000 | RoPE (θ = 500,000) |
| Llama 3 405B | 126 | 16,384 | 20,480 | 128 | 8 | 8 × 10⁻⁵ | SwiGLU | 128,000 | RoPE (θ = 500,000) |

- 우리는 128K 토큰을 가진 어휘를 사용합니다. 우리의 토큰 어휘는 tiktoken3 토크나이저에서 100K 토큰과 비영어권 언어를 더 잘 지원하기 위해 추가된 28K 토큰을 결합한 것입니다. Llama 2 토크나이저와 비교하여, 우리의 새로운 토크나이저는 샘플 영어 데이터에서 압축률을 3.17에서 3.94 문자/토큰으로 개선합니다. 이는 동일한 훈련 컴퓨팅으로 더 많은 텍스트를 "읽을" 수 있게 합니다. 또한 선택된 비영어권 언어에서 28K 토큰을 추가하면 영어 토크나이제이션에 영향을 주지 않으면서 압축 비율과 다운스트림 성능이 향상된다는 것을 발견했습니다.
- 우리는 RoPE 기본 주파수 하이퍼파라미터를 500,000으로 증가시켰습니다. 이는 더 긴 컨텍스트를 더 잘 지원할 수 있게 합니다; Xiong et al. (2023)은 이 값이 최대 32,768 컨텍스트 길이에 효과적임을 보여주었습니다.

Llama 3 405B는 126개의 레이어, 16,384 토큰 표현 차원 및 128 어텐션 헤드를 가진 아키텍처를 사용합니다. 자세한 내용은 표 3을 참조하세요. 이는 우리의 훈련 예산인 3.8 × 10²⁵ FLOPs에 대한 데이터 스케일링 법칙에 따라 대략적으로 컴퓨팅 최적 모델 크기를 이끌어냅니다.

### 3.2.1 스케일링 법칙

우리는 사전 훈련 컴퓨팅 예산에 따라 주력 모델의 최적 모델 크기를 결정하기 위해 스케일링 법칙(Hoffmann et al., 2022; Kaplan et al., 2020)을 개발합니다. 최적 모델 크기를 결정하는 것 외에도, 주력 모델이 다운스트림 벤치마크 작업에서의 성능을 예측하는 것이 주요 과제입니다. 이는 몇 가지 문제로 인해 발생합니다: (1) 기존 스케일링 법칙은 특정 벤치마크 성능보다는 다음 토큰 예측 손실만 예측하는 경향이 있습니다. (2) 스케일링 법칙은 작은 컴퓨팅 예산으로 수행된 사전 훈련을 기반으로 개발되기 때문에 노이즈가 많고 신뢰할 수 없습니다(Wei et al., 2022b).

이러한 문제를 해결하기 위해, 우리는 다운스트림 벤치마크 성능을 정확하게 예측할 수 있는 스케일링 법칙을 개발하기 위해 두 단계 방법론을 구현합니다:

1. 먼저, 컴퓨팅 최적 모델의 다운스트림 작업에 대한 음의 로그 우도와 훈련 FLOPs 간의 상관관계를 설정합니다.
2. 다음으로, 스케일링 법칙 모델과 더 높은 컴퓨팅 FLOPs로 훈련된 이전 모델을 활용하여 다운스트림 작업에 대한 음의 로그 우도와 작업 정확도 간의 상관관계를 설정합니다. 이 단계에서 우리는 특히 Llama 2 모델 군을 활용합니다.

이 접근법을 통해 특정 훈련 FLOPs 수에 대해 컴퓨팅 최적 모델의 다운스트림 작업 성능을 예측할 수 있습니다. 우리는 유사한 방법을 사용하여 사전 훈련 데이터 믹스를 선택합니다(섹션 3.4 참조).

#### 스케일링 법칙 실험

구체적으로, 우리는 컴퓨팅 예산이 6 × 10¹⁸ FLOPs에서 10²² FLOPs 사이인 모델을 사전 훈련하여 스케일링 법칙을 구성합니다. 각 컴퓨팅 예산에서 우리는 40M에서 16B 매개변수 사이의 모델 크기로 사전 훈련을 수행하며, 각 컴퓨팅 예산에서 모델 크기의 하위 집합을 사용합니다. 이 훈련 실행에서는 2,000 훈련 단계 동안 선형 워밍업을 포함한 코사인 학습률 스케줄을 사용합니다. 피크 학습률은 모델 크기에 따라 2 × 10⁻⁴에서 4 × 10⁻⁴ 사이로 설정됩니다. 코사인 감쇠는 피크 값의 0.1로 설정됩니다. 각 단계의 가중치 감쇠는 해당 단계의 학습률의 0.1로 설정됩니다. 우리는 각 컴퓨팅 스케일에 대해 250K에서 4M 사이의 고정 배치 크기를 사용합니다.

![](/assets/images/posts/219/img_3.png)

그림 2: 6 × 10¹⁸에서 10²² FLOPs 사이의 스케일링 법칙 IsoFLOPs 곡선. 손실은 보류된 검증 세트에서의 음의 로그우도입니다. 각 컴퓨팅 스케일에서 2차 다항식을 사용하여 측정을 근사합니다.

![](/assets/images/posts/219/img_4.png)

그림 3: 사전 훈련 컴퓨팅 예산의 함수로서 식별된 컴퓨팅 최적 모델의 훈련 토큰 수. 맞춤 스케일링 법칙 예측도 포함됩니다. 컴퓨팅 최적 모델은 그림 2의 포물선 최소값에 해당합니다.

### 실험 결과 및 해석

이 실험은 그림 2의 IsoFLOPs 곡선을 도출합니다. 이 곡선의 손실은 별도의 검증 세트에서 측정됩니다. 우리는 측정된 손실 값을 2차 다항식으로 맞추고, 각 포물선의 최솟값을 식별합니다. 각 포물선의 최솟값을 해당 사전 훈련 컴퓨팅 예산에서의 컴퓨팅 최적 모델이라고 합니다.

![](/assets/images/posts/219/img_5.png)

중요한 관찰은 컴퓨팅 예산이 증가함에 따라 IsoFLOPs 곡선이 최솟값 주위에서 평평해진다는 것입니다. 이는 주력 모델의 성능이 모델 크기와 훈련 토큰 간의 무역 오프에 대한 작은 변화에 대해 상대적으로 강건하다는 것을 의미합니다. 이 관찰에 기반하여, 우리는 궁극적으로 405B 매개변수를 가진 주력 모델을 훈련하기로 결정했습니다.

#### 다운스트림 작업 성능 예측

결과적으로 얻어진 컴퓨팅 최적 모델을 사용하여 주력 Llama 3 모델이 벤치마크 데이터 세트에서의 성능을 예측합니다. 먼저, 벤치마크에서 정답의 (정규화된) 음의 로그 우도와 훈련 FLOPs 간의 선형 상관관계를 설정합니다. 이 분석에서는 위에서 설명한 데이터 믹스로 최대 10²² FLOPs로 훈련된 스케일링 법칙 모델만 사용합니다. 다음으로, 로그 우도와 정확도 간의 시그모이드 관계를 스케일링 법칙 모델과 Llama 2 모델을 사용하여 설정합니다. 이 결과는 ARC 챌린지 벤치마크에서 그림 4에 나타나 있습니다. 이 두 단계 스케일링 법칙 예측은 4차례의 외삽을 통해 상당히 정확하다는 것을 발견했으며, 주력 Llama 3 모델의 최종 성능을 약간 과소 평가할 뿐입니다.

### 3.3 인프라, 확장 및 효율성

우리는 Llama 3 405B 사전 훈련을 대규모로 지원한 하드웨어와 인프라를 설명하고, 훈련 효율성을 개선하는 데 기여한 여러 최적화 방법을 논의합니다.

#### 3.3.1 훈련 인프라

Llama 1 및 2 모델은 Meta의 AI Research SuperCluster (Lee and Sengupta, 2022)에서 훈련되었습니다. 더 확장하면서, Llama 3의 훈련은 Meta의 프로덕션 클러스터(Lee et al., 2024)로 이전되었습니다. 이 설정은 훈련을 확장함에 따라 중요한 프로덕션 등급의 신뢰성을 최적화합니다.

- **컴퓨팅**: Llama 3 405B는 Meta의 Grand Teton AI 서버 플랫폼(Matt Bowman, 2022)을 사용하여 최대 16K H100 GPU에서 훈련됩니다. 각 GPU는 700W TDP에서 80GB HBM3 메모리를 사용하며, 각 서버는 8개의 GPU와 2개의 CPU를 탑재하고 있습니다. 서버 내에서 8개의 GPU는 NVLink로 연결됩니다. 훈련 작업은 Meta의 글로벌 규모 훈련 스케줄러인 MAST (Choudhury et al., 2024)를 사용하여 예약됩니다.
- **스토리지**: Tectonic (Pan et al., 2021), Meta의 범용 분산 파일 시스템은 Llama 3 사전 훈련을 위한 스토리지 패브릭(Battey and Gupta, 2024)을 구축하는 데 사용됩니다. 이는 7,500개의 SSD 장착 서버에서 240 PB의 스토리지를 제공하며, 지속 가능한 처리량은 2 TB/s, 최대 처리량은 7 TB/s를 지원합니다. 주요 과제는 짧은 시간 동안 스토리지 패브릭을 포화시키는 매우 버스트한 체크포인트 쓰기를 지원하는 것입니다. 체크포인트는 각 GPU의 모델 상태를 저장하며, GPU당 1MB에서 4GB까지 범위가 있습니다. 이는 복구 및 디버깅을 위해 필요합니다. 우리는 체크포인트 중 GPU 일시 중지 시간을 최소화하고, 복구 후 손실되는 작업량을 줄이기 위해 체크포인트 빈도를 증가시키고자 합니다.

![](/assets/images/posts/219/img_6.png)

그림 4: ARC 챌린지에 대한 스케일링 법칙 예측. 왼쪽: 사전 훈련 FLOPs의 함수로서 ARC 챌린지 벤치마크에서의 정답의 정규화된 음의 로그우도. 오른쪽: ARC 챌린지 벤치마크 정확도를 정답의 정규화된 음의 로그우도의 함수로서 나타냅니다. 이 분석은 사전 훈련 시작 전에 ARC 챌린지 벤치마크에서 모델 성능을 예측할 수 있게 합니다. 자세한 내용은 본문을 참조하세요.

이 분석은 우리가 사전 훈련을 시작하기 전에 ARC 챌린지 벤치마크에서 모델 성능을 예측할 수 있게 해줍니다.

### 네트워크

Llama 3 405B는 Arista 7800과 Minipack2 Open Compute Project(OCP) 랙 스위치를 기반으로 하는 RoCE(RDMA over Converged Ethernet) 패브릭을 사용했습니다. Llama 3 계열의 더 작은 모델은 Nvidia Quantum2 Infiniband 패브릭을 사용하여 훈련되었습니다. RoCE와 Infiniband 클러스터 모두 GPU 간 400 Gbps 인터커넥트를 활용합니다. 이러한 클러스터들 간의 네트워크 기술 차이에도 불구하고, 우리는 이들 모두가 대규모 훈련 작업에 대해 동등한 성능을 제공하도록 조정했습니다. 우리는 RoCE 네트워크의 설계를 완전히 소유하고 있기 때문에 이에 대해 더 자세히 설명합니다.

- **네트워크 토폴로지**: RoCE 기반 AI 클러스터는 24K GPUs로 구성되며, 세 개의 레이어로 된 Clos 네트워크로 연결됩니다(Lee et al., 2024). 하단 레이어에서는 각 랙이 두 개의 서버로 나뉜 16개의 GPU를 호스팅하며, 단일 Minipack2 랙 상단(ToR) 스위치로 연결됩니다. 중간 레이어에서는 192개의 랙이 클러스터 스위치를 통해 연결되어 3,072개의 GPU로 구성된 풀 바이섹션 대역폭을 가진 팟을 형성합니다. 이 팟은 과다가입 없이 연결됩니다. 상단 레이어에서는 동일한 데이터센터 건물 내에 있는 8개의 팟이 집계 스위치를 통해 연결되어 24K GPUs 클러스터를 형성합니다. 그러나 집계 레이어의 네트워크 연결은 풀 바이섹션 대역폭을 유지하지 않으며, 대신 1:7의 과다가입 비율을 가집니다. 우리의 모델 병렬화 방법(섹션 3.3.2 참조)과 훈련 작업 스케줄러(Choudhury et al., 2024)는 네트워크 토폴로지를 인지하도록 최적화되어 팟 간 네트워크 통신을 최소화합니다.
- **로드 밸런싱**: LLM 훈련은 전통적인 방법(예: ECMP 라우팅)을 사용하여 모든 네트워크 경로에 걸쳐 로드 밸런싱하기 어려운 대규모 네트워크 흐름을 생성합니다. 이 문제를 해결하기 위해 두 가지 기술을 사용합니다. 첫째, 우리의 집합 라이브러리는 두 GPU 간에 하나가 아닌 16개의 네트워크 흐름을 생성하여 흐름당 트래픽을 줄이고 로드 밸런싱을 위한 더 많은 흐름을 제공합니다. 둘째, 우리의 Enhanced-ECMP (E-ECMP) 프로토콜은 RoCE 헤더의 추가 필드를 해싱하여 이러한 16개의 흐름을 다양한 네트워크 경로에 효과적으로 분산시킵니다.
- **혼잡 제어**: 집합 통신 패턴으로 인해 발생하는 일시적인 혼잡과 버퍼링을 수용하기 위해 스파인(Gangidi et al., 2024)에 딥 버퍼 스위치를 사용합니다. 이 설정은 느린 서버로 인해 발생하는 지속적인 혼잡과 네트워크 백 프레셔의 영향을 제한하는 데 도움이 됩니다. 최종적으로, E-ECMP를 통한 향상된 로드 밸런싱은 혼잡의 가능성을 크게 줄입니다. 이러한 최적화로 인해 우리는 DCQCN(Data Center Quantized Congestion Notification)과 같은 전통적인 혼잡 제어 방법 없이 24K GPU 클러스터를 성공적으로 운영할 수 있습니다.

|  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  |  |  |  |  |  |  |  |  |  |
| GPUs | TP | CP | PP | DP | Seq. Len. | Batch size/DP | Tokens/Batch | TFLOPs/GPU | BF16 MFU |
| 8,192 | 8 | 1 | 16 | 64 | 8,192 | 32 | 16M | 430 | 43% |
| 16,384 | 8 | 1 | 16 | 128 | 8,192 | 16 | 16M | 400 | 41% |
| 16,384 | 8 | 16 | 16 | 4 | 131,072 | 16 | 16M | 380 | 38% |

표 4: Llama 3 405B 사전 훈련의 각 단계에 대한 확장 구성 및 MFU. 각 병렬화 유형의 설명은 본문과 그림 5를 참조하세요.

### 3.3.2 모델 확장을 위한 병렬화

우리의 가장 큰 모델 훈련을 확장하기 위해, 우리는 모델을 분할하는 네 가지 다른 병렬화 방법의 조합인 4D 병렬화를 사용합니다. 이 접근법은 많은 GPU에 연산을 효율적으로 분산시키고, 각 GPU의 모델 매개변수, 최적화 상태, 그래디언트, 활성화가 그들의 HBM에 맞도록 보장합니다. 우리의 4D 병렬화 구현은 그림 5에 설명되어 있습니다. 여기에는 텐서 병렬화(TP; Krizhevsky et al., 2012; Shoeybi et al., 2019; Korthikanti et al., 2023), 파이프라인 병렬화(PP; Huang et al., 2019; Narayanan et al., 2021; Lamy-Poirier, 2023), 컨텍스트 병렬화(CP; Liu et al., 2023a), 데이터 병렬화(DP; Rajbhandari et al., 2020; Ren et al., 2021; Zhao et al., 2023b)가 결합됩니다.

- **텐서 병렬화(TP)**: 개별 가중치 텐서를 여러 장치에 여러 청크로 나눕니다.
- **파이프라인 병렬화(PP)**: 모델을 레이어로 수직 분할하여 다른 장치들이 전체 모델 파이프라인의 다른 단계를 병렬로 처리할 수 있게 합니다.
- **컨텍스트 병렬화(CP)**: 입력 컨텍스트를 세그먼트로 나누어 매우 긴 시퀀스 길이 입력에 대한 메모리 병목 현상을 줄입니다.
- **완전 분할 데이터 병렬화(FSDP)**: 모델, 최적화 상태, 그래디언트를 샤딩하면서 데이터를 병렬로 처리하고 각 훈련 단계 후에 동기화합니다. Llama 3의 FSDP 사용은 최적화 상태와 그래디언트를 샤딩하지만, 후방 전달 중 추가 all-gather 통신을 피하기 위해 모델 샤드는 전달 후 재분할하지 않습니다.

#### GPU 활용도

병렬화 구성, 하드웨어, 소프트웨어를 신중하게 조정하여, 표 4에 표시된 구성에 대해 BF16 모델 FLOPs 활용도(MFU; Chowdhery et al., 2023) 38-43%를 달성합니다. 8K GPUs에서 DP=64일 때 43%에 비해 16K GPUs에서 DP=128일 때 MFU가 41%로 약간 떨어지는 것은 훈련 중 전역 배치당 토큰 수를 일정하게 유지하기 위해 DP 그룹당 배치 크기를 줄여야 하기 때문입니다.

#### 파이프라인 병렬화 개선

기존 구현에서 몇 가지 문제를 겪었습니다:

- **배치 크기 제약**: 현재 구현은 GPU당 지원되는 배치 크기에 제약이 있으며, 이는 파이프라인 단계 수로 나누어져야 합니다. 그림 6의 예에서, 파이프라인 병렬화의 깊이 우선 스케줄(DFS; Narayanan et al., 2021)은 N=PP=4를 요구하며, 넓이 우선 스케줄(BFS; Lamy-Poirier, 2023)은 N=M을 요구합니다. 여기서 M은 총 마이크로 배치 수이고, N은 동일한 단계의 전방 또는 후방에 대한 연속 마이크로 배치 수입니다. 그러나 사전 훈련은 배치 크기를 조정할 수 있는 유연성이 필요합니다.
- **메모리 불균형**: 기존 파이프라인 병렬화 구현은 불균형한 자원 소비로 이어집니다. 첫 번째 단계는 임베딩 및 워밍업 마이크로 배치 때문에 더 많은 메모리를 소비합니다.
- **계산 불균형**: 모델의 마지막 레이어 후, 출력과 손실을 계산해야 하므로 이 단계가 실행 지연 병목 현상이 됩니다.

![](/assets/images/posts/219/img_7.png)

그림 5: 4D 병렬화의 설명. GPU는 [TP, CP, PP, DP] 순서로 병렬화 그룹으로 나뉘며, 여기서 DP는 FSDP를 의미합니다. 이 예에서는 16개의 GPU가 |TP|=2, |CP|=2, |PP|=2, |DP|=2의 그룹 크기로 구성됩니다. GPU의 4D 병렬화 위치는 벡터 [D1, D2, D3, D4]로 표현되며, Di는 i번째 병렬화 차원의 인덱스입니다. 이 예에서는 GPU0[TP0, CP0, PP0, DP0]와 GPU1[TP1, CP0, PP0, DP0]가 동일한 TP 그룹에 있으며, GPU0과 GPU2는 동일한 CP 그룹에, GPU0과 GPU4는 동일한 PP 그룹에, GPU0과 GPU8은 동일한 DP 그룹에 속합니다.

![](/assets/images/posts/219/img_8.png)

#### 긴 시퀀스를 위한 컨텍스트 병렬화

우리는 Llama 3의 컨텍스트 길이를 확장할 때 메모리 효율성을 높이고, 최대 128K 길이의 매우 긴 시퀀스에서 훈련할 수 있도록 컨텍스트 병렬화(CP)를 활용합니다. CP에서는 시퀀스 차원을 따라 분할하며, 특히 입력 시퀀스를 2 × CP 청크로 나누어 각 CP 순위가 더 나은 로드 밸런싱을 위해 두 개의 청크를 받도록 합니다. i번째 CP 순위는 i번째와 (2 × CP - 1 - i)번째 청크를 받습니다.

![](/assets/images/posts/219/img_9.png)

![](/assets/images/posts/219/img_10.png)

그림 6: Llama 3의 파이프라인 병렬화 설명. 파이프라인 병렬화는 네 개의 파이프라인 순위(PP 랭크 0에서 3)에 걸쳐 여덟 개의 파이프라인 단계를 분할합니다. 랭크 0의 GPU는 단계 0과 4를 실행하고, 랭크 1의 GPU는 단계 1과 5를 실행하는 등입니다. 색상 블록(0에서 9)은 마이크로 배치의 시퀀스를 나타내며, M은 총 마이크로 배치 수, N은 동일한 단계의 전방 또는 후방에 대한 연속 마이크로 배치 수입니다. 우리의 주요 통찰은 N을 조정 가능하게 만드는 것입니다.

### 네트워크 인식 병렬화 구성

병렬화 차원의 순서인 [TP, CP, PP, DP]는 네트워크 통신을 최적화하기 위해 설계되었습니다. 가장 안쪽의 병렬화는 가장 높은 네트워크 대역폭과 가장 낮은 지연 시간이 필요하므로 일반적으로 동일한 서버 내에 제한됩니다. 가장 바깥쪽의 병렬화는 멀티 홉 네트워크에 걸쳐 있을 수 있으며, 더 높은 네트워크 지연을 견딜 수 있어야 합니다. 따라서 네트워크 대역폭과 지연 시간 요구 사항에 따라 병렬화 차원을 [TP, CP, PP, DP] 순서로 배치합니다. DP(FSDP)는 비동기적으로 분할된 모델 가중치를 미리 가져오고 그래디언트를 줄임으로써 더 긴 네트워크 지연을 견딜 수 있기 때문에 가장 바깥쪽 병렬화로 배치합니다. 통신 오버헤드를 최소화하면서 GPU 메모리 오버플로를 방지하기 위한 최적의 병렬화 구성을 식별하는 것은 어렵습니다. 우리는 메모리 소비 추정기와 성능 예측 도구를 개발하여 다양한 병렬화 구성을 탐색하고 전체 훈련 성능을 예측하며 메모리 격차를 효과적으로 식별했습니다.

#### 수치적 안정성

다양한 병렬화 설정 간의 훈련 손실을 비교함으로써 훈련 안정성에 영향을 미치는 몇 가지 수치적 문제를 해결했습니다. 훈련 수렴을 보장하기 위해, 우리는 여러 마이크로 배치 동안 역전파 계산 중에 FP32 그래디언트 누적을 사용하고, FSDP의 데이터 병렬 작업자 간에 FP32로 그래디언트를 reduce-scatter합니다. 중간 텐서(예: 비전 인코더 출력)와 같이 전방 계산에서 여러 번 사용되는 경우, 역전파 그래디언트도 FP32로 누적됩니다.

### 집합 통신

Llama 3를 위한 우리의 집합 통신 라이브러리는 Nvidia의 NCCL 라이브러리를 포크한 NCCLX를 기반으로 합니다. NCCLX는 특히 더 높은 지연 네트워크에서 NCCL의 성능을 크게 향상시킵니다. 병렬화 차원의 순서는 [TP, CP, PP, DP]이며, 여기서 DP는 FSDP에 해당합니다. 가장 바깥쪽 병렬화 차원인 PP와 DP는 멀티 홉 네트워크를 통해 통신할 수 있으며, 지연 시간이 수십 마이크로초에 이를 수 있습니다. 원래의 NCCL 집합 통신은 FSDP의 all-gather 및 reduce-scatter, 그리고 PP의 점대점 통신에서 데이터 청킹 및 단계적 데이터 복사를 필요로 합니다. 이 접근 방식은 (1) 데이터 전송을 용이하게 하기 위해 네트워크를 통해 많은 수의 작은 제어 메시지를 교환해야 하고, (2) 추가 메모리 복사 작업을 필요로 하며, (3) 통신을 위해 추가 GPU 사이클을 사용하는 등 여러 비효율성을 초래합니다. Llama 3 훈련을 위해 우리는 데이터 청킹과 전송을 조정하여 큰 클러스터에서 수십 마이크로초에 이르는 네트워크 지연에 맞추어 이러한 비효율성의 일부를 해결했습니다. 또한, 작은 제어 메시지가 네트워크를 더 높은 우선 순위로 통과하도록 허용하여 깊은 버퍼 코어 스위치에서 헤드 오브 라인 차단을 피했습니다. 미래 Llama 버전을 위한 우리의 진행 중인 작업은 위에서 언급한 모든 문제를 전반적으로 해결하기 위해 NCCLX에 더 깊은 변화를 도입하는 것입니다.

### 예기치 않은 중단의 원인 분석

54일 동안 Llama 3 405B 사전 훈련 중 발생한 예기치 않은 중단의 원인 분류:

|  |  |  |
| --- | --- | --- |
|  |  |  |
| 구성 요소 카테고리 | 중단 횟수 | 중단 비율 (%) |
| 결함 있는 GPU | 148 | 30.1% |
| GPU HBM3 메모리 | 72 | 17.2% |
| 소프트웨어 버그 | 54 | 12.9% |
| 네트워크 스위치/케이블 | 35 | 8.4% |
| 호스트 유지보수 | 32 | 7.6% |
| GPU SRAM 메모리 | 19 | 4.5% |
| GPU 시스템 프로세서 | 17 | 4.1% |
| NIC | 7 | 1.7% |
| NCCL 워치독 타임아웃 | 7 | 1.7% |
| 데이터 손상 | 6 | 1.4% |
| GPU 열 인터페이스 + 센서 | 6 | 1.4% |
| SSD | 3 | 0.7% |
| 전원 공급 장치 | 3 | 0.7% |
| 서버 섀시 | 2 | 0.5% |
| IO 확장 보드 | 2 | 0.5% |
| 종속성 | 2 | 0.5% |
| CPU | 2 | 0.5% |
| 시스템 메모리 | 2 | 0.5% |

약 78%의 예기치 않은 중단이 확인된 또는 의심되는 하드웨어 문제로 인한 것이었습니다.

### 3.3.4 신뢰성 및 운영 과제

16K GPU 훈련의 복잡성과 잠재적인 고장 시나리오는 우리가 운영한 훨씬 더 큰 CPU 클러스터의 복잡성과 비교할 수 없습니다. 또한, 훈련의 동기적 특성 때문에 단일 GPU 고장으로 인해 전체 작업을 다시 시작해야 하는 경우가 많아 내결함성이 떨어집니다. 이러한 도전에도 불구하고, Llama 3 훈련에서는 90% 이상의 실효 훈련 시간을 달성했으며, 이는 펌웨어와 리눅스 커널 업그레이드(Vigraham and Leonhardi, 2024)와 같은 자동 클러스터 유지보수를 지원하면서도 하루에 최소한 한 번의 훈련 중단을 초래했습니다. 실효 훈련 시간은 경과 시간 동안 유용한 훈련에 소비된 시간을 측정합니다.

#### 중단 및 문제 해결

54일 동안의 사전 훈련 기간 동안 총 466번의 작업 중단이 발생했습니다. 이 중 47번은 펌웨어 업그레이드나 구성 또는 데이터셋 업데이트와 같은 자동 유지보수 작업이나 운영자 주도의 작업으로 인한 계획된 중단이었습니다. 나머지 419번은 예기치 않은 중단으로, 표 5에 분류되어 있습니다. 약 78%의 예기치 않은 중단은 GPU 또는 호스트 구성 요소 고장과 같은 확인된 하드웨어 문제 또는 무음 데이터 손상 및 계획되지 않은 개별 호스트 유지보수 이벤트와 같은 하드웨어 관련 문제로 인한 것입니다. GPU 문제는 가장 큰 범주로, 모든 예기치 않은 문제의 58.7%를 차지합니다. 이러한 많은 실패에도 불구하고, 이 기간 동안 수동 개입이 필요한 경우는 세 번에 불과했으며, 나머지 문제는 자동화로 처리되었습니다.

#### 훈련 시간 증가를 위한 조치

효과적인 훈련 시간을 늘리기 위해, 우리는 작업 시작 및 체크포인팅 시간을 줄이고, 빠른 진단 및 문제 해결 도구를 개발했습니다. PyTorch의 내장된 NCCL 비행 기록기(Ansel et al., 2024)를 광범위하게 사용하여 집합 메타데이터와 스택 추적을 링 버퍼에 캡처하여 대규모에서 행이나 성능 문제를 빠르게 진단할 수 있습니다. 이를 통해 모든 통신 이벤트와 각 집합 연산의 지속 시간을 효율적으로 기록하고, NCCLX 워치독이나 하트비트 타임아웃 시 자동으로 추적 데이터를 덤프합니다. 우리는 코드 릴리스나 작업 재시작 없이 실시간으로 온라인 구성 변경을 통해 필요에 따라 선택적으로 더 많은 계산 집약적인 추적 작업 및 메타데이터 수집을 활성화합니다(Tang et al., 2015).

#### 대규모 훈련에서의 디버깅

대규모 훈련에서 NVLink와 RoCE의 혼합 사용은 디버깅을 복잡하게 만듭니다. NVLink를 통한 데이터 전송은 일반적으로 CUDA 커널에서 발생하는 로드/스토어 작업을 통해 이루어지며, 원격 GPU 또는 NVLink 연결의 실패는 명확한 오류 코드를 반환하지 않고 CUDA 커널 내에서 로드/스토어 작업이 중단된 것으로 나타납니다. NCCLX는 PyTorch와의 긴밀한 공동 설계를 통해 고장 감지 및 위치 추적의 속도와 정확성을 향상시켜, PyTorch가 NCCLX의 내부 상태에 접근하고 관련 정보를 추적할 수 있게 합니다. NVLink 실패로 인한 중단을 완전히 방지할 수는 없지만, 우리 시스템은 통신 라이브러리의 상태를 모니터링하고 이러한 중단이 감지되면 자동으로 타임아웃합니다. 또한, NCCLX는 각 NCCLX 통신의 커널 및 네트워크 활동을 추적하고, 모든 랭크 간의 완료된 및 대기 중인 데이터 전송을 포함하여 실패한 NCCLX 집합의 내부 상태를 스냅샷으로 제공합니다. 우리는 이 데이터를 분석하여 NCCLX 확장 문제를 디버깅합니다.

#### 느린 작업자 문제 해결

하드웨어 문제는 여전히 작동하지만 느린 작업자를 유발할 수 있으며, 이는 감지하기 어렵습니다. 단일 느린 작업자도 수천 개의 다른 GPU를 느리게 만들 수 있으며, 이는 종종 작동하지만 느린 통신으로 나타납니다. 우리는 선택된 프로세스 그룹에서 잠재적으로 문제가 있는 통신을 우선적으로 조사하는 도구를 개발했습니다. 몇 가지 주요 의심 대상만 조사함으로써, 우리는 대개 느린 작업자를 효과적으로 식별할 수 있었습니다.

#### 환경 요인의 영향

Llama 3 405B의 경우, 훈련 성능에 대한 환경 요인의 영향을 관찰했습니다. 우리는 하루 중 시간에 따라 1-2%의 처리량 변동이 발생하는 것을 관찰했으며, 이는 중간 낮 온도가 GPU 동적 전압 및 주파수 스케일링에 영향을 미치기 때문입니다.

훈련 중에는 수만 개의 GPU가 동시에 전력 소비를 증가시키거나 감소시킬 수 있으며, 예를 들어 모든 GPU가 체크포인팅 또는 집합 통신이 완료되기를 기다리거나 전체 훈련 작업이 시작 또는 종료되는 경우가 있습니다. 이로 인해 데이터 센터 전역에서 전력 소비가 순간적으로 수십 메가와트 범위로 변동할 수 있으며, 이는 전력망의 한계를 초과할 수 있습니다. 이는 더 큰 미래 Llama 모델의 훈련을 확장함에 따라 계속되는 도전 과제입니다.

### 3.4 훈련 레시피

Llama 3 405B 사전 훈련에 사용된 레시피는 세 가지 주요 단계로 구성됩니다: (1) 초기 사전 훈련, (2) 긴 컨텍스트 사전 훈련, (3) 어닐링. 이 세 가지 단계는 아래에 각각 설명되어 있습니다. 우리는 8B 및 70B 모델을 사전 훈련하는 데 유사한 레시피를 사용합니다.

![](/assets/images/posts/219/img_11.png)

#### 데이터 믹스 조정

우리는 특정 다운스트림 작업에서 모델 성능을 향상시키기 위해 훈련 중 사전 훈련 데이터 믹스를 몇 가지 조정했습니다. 특히, Llama 3의 다중 언어 성능을 향상시키기 위해 사전 훈련 중 비영어 데이터의 비율을 증가시켰습니다. 또한 모델의 수학적 추론 성능을 향상시키기 위해 수학 데이터를 업샘플링하고, 사전 훈련 후반 단계에서 모델의 지식 컷오프를 높이기 위해 최신 웹 데이터를 추가했으며, 나중에 저품질로 식별된 사전 훈련 데이터의 하위 집합을 다운샘플링했습니다.

#### 3.4.2 긴 컨텍스트 사전 훈련

사전 훈련의 마지막 단계에서 최대 128K 토큰의 컨텍스트 창을 지원하기 위해 긴 시퀀스를 훈련합니다. 자기 주의 레이어에서의 계산이 시퀀스 길이에 따라 제곱으로 증가하기 때문에 초기에는 긴 시퀀스에서 훈련하지 않습니다. 모델이 증가된 컨텍스트 길이에 성공적으로 적응할 때까지 사전 훈련을 반복하며, 이를 통해 지원되는 컨텍스트 길이를 단계적으로 증가시킵니다. 성공적인 적응을 평가하는 방법은 (1) 짧은 컨텍스트 평가에서 모델 성능이 완전히 회복되었는지, (2) 모델이 해당 길이까지의 "건초 더미 속 바늘" 작업을 완벽하게 해결하는지 여부를 측정하는 것입니다. Llama 3 405B 사전 훈련에서 우리는 초기 8K 컨텍스트 창에서 시작하여 최종 128K 컨텍스트 창에 도달할 때까지 컨텍스트 길이를 여섯 단계에 걸쳐 점진적으로 증가시켰습니다. 이 긴 컨텍스트 사전 훈련 단계는 약 800B 훈련 토큰을 사용하여 수행되었습니다.

![](/assets/images/posts/219/img_12.png)

그림 7: Llama 3의 전체 사후 훈련 접근법을 설명합니다. 우리의 사후 훈련 전략에는 거부 샘플링, 감독된 미세 조정, 직접 선호 최적화가 포함됩니다. 자세한 내용은 본문을 참조하세요.

### 3.4.3 어닐링 (Annealing)

최종 4000만 개의 토큰에 대한 사전 훈련 동안, 우리는 학습률을 선형으로 0으로 어닐링하며 컨텍스트 길이를 128K 토큰으로 유지했습니다. 이 어닐링 단계 동안, 우리는 고품질의 데이터 소스를 업샘플링하기 위해 데이터 믹스를 조정했습니다. 자세한 내용은 섹션 3.1.3을 참조하세요. 마지막으로, 어닐링 동안 모델 체크포인트의 평균을 계산하여 최종 사전 훈련 모델을 생성했습니다(Polyak 평균화).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

어닐링(annealing)은 학습률을 점진적으로 줄여가는 과정을 말합니다. 기계 학습 및 최적화 알고리즘에서 어닐링은 모델 훈련의 마지막 단계에서 학습률을 천천히 감소시켜 모델이 최종 최적화 단계에서 안정적으로 수렴하도록 도와주는 기법입니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

### 4. 사후 훈련 (Post-Training)

우리는 여러 라운드의 사후 훈련을 통해 사전 훈련된 체크포인트 위에 모델을 인간 피드백과 정렬시키는 방법으로 Llama 3 모델을 생성합니다(Ouyang et al., 2022; Rafailov et al., 2024). 각 사후 훈련 라운드는 감독된 미세 조정(SFT)과 인간 주석이나 합성된 예제를 통해 수집된 예제에 대한 직접 선호 최적화(DPO; Rafailov et al., 2024)를 포함합니다. 우리의 사후 훈련 모델링 및 데이터 접근 방식은 각각 섹션 4.1과 4.2에 설명되어 있습니다. 우리는 또한 추론, 코딩, 사실성, 다중 언어, 도구 사용, 긴 컨텍스트, 정확한 명령 수행을 개선하기 위한 맞춤 데이터 큐레이션 전략을 섹션 4.3에서 자세히 설명합니다.

#### 4.1 모델링 (Modeling)

우리의 사후 훈련 전략의 핵심은 보상 모델과 언어 모델입니다. 우리는 먼저 인간이 주석을 단 선호 데이터(섹션 4.1.2 참조)를 사용하여 사전 훈련된 체크포인트 위에 보상 모델을 훈련합니다. 그런 다음 감독된 미세 조정(SFT; 섹션 4.1.3 참조)을 통해 사전 훈련된 체크포인트를 미세 조정하고, 직접 선호 최적화(DPO; 섹션 4.1.4 참조)로 체크포인트를 추가로 정렬합니다. 이 과정은 그림 7에 설명되어 있습니다. 별도로 언급하지 않는 한, 우리의 모델링 절차는 Llama 3 405B에 적용되며, 간단히 Llama 3로 언급합니다.

#### 4.1.1 대화 형식 (Chat Dialog Format)

LLM을 인간-AI 상호 작용에 맞추기 위해, 모델이 인간 명령을 이해하고 대화 작업을 수행할 수 있도록 대화 프로토콜을 정의해야 합니다. 이전 모델과 비교하여, Llama 3는 도구 사용(섹션 4.3.5)과 같은 새로운 기능이 있어, 단일 대화 턴 내에서 여러 메시지를 생성하고 이를 다른 위치(예: 사용자, ipython)로 보낼 수 있어야 합니다. 이를 지원하기 위해, 우리는 다양한 특수 헤더 및 종료 토큰을 사용하는 새로운 다중 메시지 대화 프로토콜을 설계했습니다. 헤더 토큰은 대화에서 각 메시지의 출처와 목적지를 나타내는 데 사용됩니다. 마찬가지로, 종료 토큰은 인간과 AI가 번갈아가며 발언할 때를 나타냅니다.

#### 4.1.2 보상 모델링 (Reward Modeling)

우리는 사전 훈련된 체크포인트 위에 다양한 기능을 포함하는 보상 모델(RM)을 훈련합니다. 훈련 목표는 Llama 2와 동일하지만, 데이터 확장 후 개선이 감소하는 것을 관찰하여 손실의 마진 항을 제거했습니다. Llama 2를 따라, 우리는 유사한 응답을 필터링한 후 모든 선호 데이터를 보상 모델링에 사용합니다. 표준 선호 응답 쌍(선택된 응답, 거부된 응답) 외에도, 주석은 일부 프롬프트에 대해 선택된 응답을 개선하기 위해 추가로 편집된 "편집된 응답"을 생성합니다(섹션 4.2.1 참조). 따라서 각 선호 순위 샘플에는 명확한 순위(편집된 응답 > 선택된 응답 > 거부된 응답)를 가진 두 개 또는 세 개의 응답이 있습니다. 우리는 훈련 중 프롬프트와 여러 응답을 하나의 행으로 연결하고, 응답을 무작위로 섞습니다. 이는 응답을 개별 행에 넣고 점수를 계산하는 표준 시나리오의 근사치이며, 우리의 실험에서는 정확도 손실 없이 훈련 효율성을 향상시켰습니다.

#### 4.1.3 감독된 미세 조정 (Supervised Finetuning)

보상 모델은 인간 주석 프롬프트에 대해 거부 샘플링을 수행하는 데 사용됩니다. 자세한 내용은 섹션 4.2에 설명되어 있습니다. 이러한 거부 샘플링된 데이터와 기타 데이터 소스(합성 데이터 포함)를 사용하여 사전 훈련된 언어 모델을 타겟 토큰에 대한 표준 교차 엔트로피 손실을 사용하여 미세 조정합니다(프롬프트 토큰에 대한 손실은 마스킹). 데이터 믹스에 대한 자세한 내용은 섹션 4.2에서 찾을 수 있습니다. 우리는 이 단계를 감독된 미세 조정(SFT; Wei et al., 2022a; Sanh et al., 2022; Wang et al., 2022b)이라고 합니다. 비록 많은 훈련 타겟이 모델 생성이긴 하지만 말입니다. 우리의 가장 큰 모델은 8,500에서 9,000 단계 동안 1e-5의 학습률로 미세 조정되었습니다. 우리는 이러한 하이퍼파라미터 설정이 다양한 라운드와 데이터 믹스에서 잘 작동함을 발견했습니다.

### 4.1.4 직접 선호 최적화 (Direct Preference Optimization)

우리는 SFT(Supervised Finetuning) 모델을 인간 선호도 정렬을 위해 직접 선호 최적화(DPO; Rafailov et al., 2024)를 통해 추가로 훈련합니다. 훈련을 위해 주로 이전 정렬 라운드에서 가장 성능이 좋은 모델을 사용하여 수집한 최신 선호 데이터 배치를 사용합니다. 그 결과, 우리의 훈련 데이터는 각 라운드에서 최적화되는 정책 모델의 분포에 더 잘 맞게 됩니다. 우리는 PPO(Schulman et al., 2017)와 같은 정책 기반 알고리즘도 탐색했지만, DPO가 대규모 모델에서는 더 적은 계산을 요구하며, 특히 IFEval(Zhou et al., 2023)과 같은 명령 수행 벤치마크에서 더 나은 성능을 보였습니다. Llama 3의 경우, 우리는 1e-5의 학습률과 0.1의 하이퍼파라미터 값을 사용합니다. 또한, 우리는 DPO에 다음과 같은 알고리즘적 수정을 적용합니다:

- **DPO 손실에서 포맷팅 토큰 마스킹**: 우리는 DPO 훈련의 안정성을 위해 선택된 응답과 거부된 응답 모두에서 헤더 및 종료 토큰을 포함한 특수 포맷팅 토큰을 마스킹합니다. 이러한 토큰이 손실에 기여하면 꼬리 반복이나 갑작스러운 종료 토큰 생성과 같은 원치 않는 모델 동작을 초래할 수 있습니다. 이는 DPO 손실의 대조적 성격 때문일 수 있으며, 선택된 응답과 거부된 응답 모두에서 공통된 토큰이 존재하면 모델이 이러한 토큰의 가능성을 동시에 증가시키고 감소시켜야 하는 상충되는 학습 목표를 초래할 수 있습니다.
- **NLL 손실로 정규화**: 선택된 시퀀스에 대해 스케일링 계수가 0.2인 추가적인 음의 로그 가능도(NLL) 손실 항을 추가합니다(Pang et al., 2024). 이는 생성의 원하는 포맷팅을 유지하고 선택된 응답의 로그 확률 감소를 방지하여 DPO 훈련을 더욱 안정화합니다(Pang et al., 2024; Pal et al., 2024).

### 4.1.5 모델 평균화 (Model Averaging)

마지막으로, 각 RM(Reward Model), SFT(Supervised Finetuning), 또는 DPO(Direct Preference Optimization) 단계에서 다양한 데이터 또는 하이퍼파라미터 버전을 사용하여 실험한 모델을 평균화합니다(Izmailov et al., 2019; Wortsman et al., 2022; Li et al., 2022).

![](/assets/images/posts/219/img_13.png)

### 표 6 인간 선호 데이터 통계

Llama 3 정렬에 사용된 내부적으로 수집된 인간 선호 데이터의 통계를 나열합니다. 우리는 주석자들에게 모델과 여러 턴의 대화를 수행하고 각 턴에서 응답을 비교하도록 요청합니다. 후처리에서는 각 대화를 턴 단위로 여러 예제로 분할합니다. 각 예제는 프롬프트(이전 대화 포함)와 응답(예: 선택된 응답 또는 거부된 응답)으로 구성됩니다.

### 4.1.6 반복적인 라운드

Llama 2와 마찬가지로, 우리는 위의 방법을 여섯 라운드에 걸쳐 적용합니다. 각 사이클에서 우리는 새로운 선호 주석과 SFT 데이터를 수집하고 최신 모델에서 합성 데이터를 샘플링합니다.

### 4.2 사후 훈련 데이터

사후 훈련 데이터 구성은 언어 모델의 유용성과 행동에 중요한 역할을 합니다. 이 섹션에서는 우리의 인간 주석 절차와 선호 데이터 수집(섹션 4.2.1), SFT 데이터 구성(섹션 4.2.2), 데이터 품질 관리 및 정리 방법(섹션 4.2.3)에 대해 논의합니다.

#### 4.2.1 선호 데이터

우리의 선호 데이터 주석 과정은 Llama 2와 유사합니다. 각 라운드 후 여러 모델을 주석 작업에 배치하고, 각 사용자 프롬프트에 대해 두 개의 다른 모델에서 두 개의 응답을 샘플링합니다. 이러한 모델은 다른 데이터 믹스와 정렬 레시피로 훈련될 수 있어 다양한 기능 강도(예: 코드 전문성)와 데이터 다양성을 허용합니다. 우리는 주석자에게 선택된 응답을 거부된 응답보다 얼마나 더 선호하는지에 따라 크게 더 좋음, 더 좋음, 약간 더 좋음, 조금 더 좋음의 네 가지 수준으로 선호도의 강도를 평가하도록 요청합니다. 또한 선호 순위 매긴 후 주석자가 선호된 응답을 직접 수정하거나 모델에 피드백을 제공하여 응답을 개선하도록 유도하는 편집 단계를 포함합니다. 따라서 우리의 선호 데이터의 일부는 세 가지 응답(편집됨 > 선택됨 > 거부됨)이 순위 매겨져 있습니다.

표 6에서는 Llama 3 훈련에 사용된 선호 주석의 통계를 보고합니다. 일반 영어는 특정 기능의 범위를 벗어나는 지식 기반 질문과 응답 또는 정확한 명령 수행과 같은 여러 하위 범주를 포함합니다. Llama 2와 비교하여 프롬프트와 응답의 평균 길이가 증가했음을 관찰했으며, 이는 우리가 더 복잡한 작업에 대해 Llama 3를 훈련하고 있음을 시사합니다. 또한, 우리는 수집된 데이터를 엄격히 평가하기 위해 품질 분석과 인간 평가 프로세스를 구현하여 프롬프트를 개선하고 주석자에게 체계적이고 실행 가능한 피드백을 제공합니다. 예를 들어, 각 라운드 후 Llama 3가 개선됨에 따라 모델이 뒤처지는 영역을 타겟으로 프롬프트 복잡성을 증가시킵니다.

사후 훈련의 각 라운드에서 우리는 보상 모델링을 위해 그 당시 사용할 수 있는 모든 선호 데이터를 사용하지만, DPO 훈련에는 최신 배치만 사용합니다. 보상 모델링과 DPO 모두에서 선택된 응답이 거부된 응답보다 크게 또는 더 좋은 것으로 표시된 샘플을 훈련에 사용하고, 유사한 응답이 있는 샘플은 제외합니다.

#### 4.2.2 SFT 데이터

우리의 미세 조정 데이터는 주로 다음 출처로 구성됩니다:

- 거부 샘플링된 응답이 포함된 인간 주석 수집 프롬프트
- 특정 기능을 타겟으로 한 합성 데이터(자세한 내용은 섹션 4.3 참조)
- 소량의 인간이 큐레이션한 데이터(자세한 내용은 섹션 4.3 참조)

사후 훈련 라운드가 진행됨에 따라, 우리는 더 강력한 Llama 3 변형을 개발하여 더 넓은 범위의 복잡한 기능을 포괄하는 더 큰 데이터 세트를 수집합니다. 이 섹션에서는 거부 샘플링 절차와 최종 SFT 데이터 믹스의 전반적인 구성에 대해 논의합니다.

![](/assets/images/posts/219/img_14.png)

표 7에서는 Llama 3 정렬에 사용된 내부적으로 수집된 SFT 데이터의 통계를 나열합니다. 각 SFT 예제는 컨텍스트(즉, 마지막 하나를 제외한 모든 대화 턴)와 최종 응답으로 구성됩니다.

### 거부 샘플링 (Rejection Sampling)

거부 샘플링(RS) 동안, 우리는 인간 주석(섹션 4.2.1) 중 수집된 각 프롬프트에 대해 최신 대화 모델 정책(일반적으로 이전 사후 훈련 반복에서 가장 성능이 좋은 체크포인트 또는 특정 기능에서 가장 성능이 좋은 체크포인트)에서 K(보통 10에서 30 사이)의 출력을 샘플링하고, 보상 모델을 사용하여 최적의 후보를 선택합니다(Bai et al., 2022와 일치). 사후 훈련의 후반 라운드에서는 RS 응답을 원하는 톤, 스타일 또는 형식으로 유도하기 위해 시스템 프롬프트를 도입합니다. 이러한 형식은 기능마다 다를 수 있습니다.

거부 샘플링의 효율성을 높이기 위해, 우리는 PagedAttention(Kwon et al., 2023)을 채택합니다. PagedAttention은 동적 키-값 캐시 할당을 통해 메모리 효율성을 향상시킵니다. 이는 현재 캐시 용량을 기반으로 요청을 동적으로 스케줄링하여 임의의 출력 길이를 지원합니다. 그러나 메모리가 부족할 때 스왑아웃의 위험이 있습니다. 이러한 스왑 오버헤드를 제거하기 위해, 우리는 최대 출력 길이를 정의하고 충분한 메모리가 있는 경우에만 요청을 수행합니다. PagedAttention은 또한 프롬프트에 대한 키-값 캐시 페이지를 모든 해당 출력에 대해 공유할 수 있게 합니다. 이를 통해 거부 샘플링 동안 처리량이 2배 이상 향상됩니다.

### 전체 데이터 구성

표 7은 우리의 "도움이 되는" 믹스의 각 광범위한 범주에 대한 데이터 통계를 보여줍니다. SFT와 선호 데이터는 중복되는 도메인을 포함하지만, 각각 다르게 큐레이션되어 고유한 카운트 통계를 생성합니다. 섹션 4.2.3에서는 데이터 샘플의 주제, 복잡성 및 품질을 분류하는 기술을 설명합니다. 사후 훈련의 각 라운드에서, 우리는 다양한 벤치마크에 대한 성능을 조정하기 위해 이러한 축을 따라 전체 데이터 믹스를 신중하게 조정합니다. 우리의 최종 데이터 믹스는 일부 고품질 소스를 여러 번 반복하고 다른 소스를 다운샘플링합니다.

### 4.2.3 데이터 처리 및 품질 관리

우리의 훈련 데이터 대부분이 모델 생성이기 때문에, 신중한 정리와 품질 관리가 필요합니다.

#### 데이터 정리

초기 라운드에서는 데이터에서 과도한 이모지 또는 느낌표 사용과 같은 바람직하지 않은 패턴이 많이 관찰되었습니다. 따라서 문제 데이터 필터링 또는 정리를 위한 일련의 규칙 기반 데이터 제거 및 수정 전략을 구현했습니다. 예를 들어, 과도한 사과 톤 문제를 완화하기 위해, "I'm sorry" 또는 "I apologize"와 같은 과도하게 사용된 문구를 식별하고, 이러한 샘플의 비율을 균형 있게 조정했습니다.

#### 데이터 가지치기

우리는 또한 저품질 훈련 샘플을 제거하고 전체 모델 성능을 향상시키기 위해 모델 기반 기술 모음을 적용합니다:

- **주제 분류**: 우리는 먼저 Llama 3 8B를 주제 분류기로 미세 조정하고, 모든 데이터를 추론하여 이를 대략적인 범주("수학적 추론")와 세부적인 범주("기하학 및 삼각법")로 분류합니다.
- **품질 점수**: 우리는 보상 모델과 Llama 기반 신호를 사용하여 각 샘플에 대한 품질 점수를 얻습니다. RM 기반 점수의 경우, RM 점수의 상위 사분위에 해당하는 데이터를 고품질로 간주합니다. Llama 기반 점수의 경우, 일반 영어 데이터에 대해 정확성, 명령 수행, 톤/프레젠테이션의 세 가지 기준으로, 코딩 데이터에 대해서는 버그 식별과 사용자 의도 두 가지 기준으로 각 샘플을 평가하도록 Llama 3 체크포인트를 프롬프트하여, 최대 점수를 받은 샘플을 고품질로 간주합니다. RM과 Llama 기반 점수는 높은 불일치율을 가지며, 이러한 신호를 결합하여 내부 테스트 세트에서 최고의 재현율을 얻는다는 것을 발견했습니다. 결국, 우리는 RM 또는 Llama 기반 필터에 의해 고품질로 표시된 예제를 선택합니다.
- **난이도 점수**: 우리는 모델에 더 복잡한 예제를 우선시하기 위해 두 가지 난이도 측정을 사용하여 데이터를 점수화합니다: Instag(Lu et al., 2023)와 Llama 기반 점수. Instag의 경우, SFT 프롬프트의 의도 태깅을 수행하도록 Llama 3 70B를 프롬프트하며, 더 많은 의도는 더 높은 복잡성을 의미합니다. 우리는 또한 대화의 난이도를 세 가지 기준으로 측정하도록 Llama 3을 프롬프트합니다(Liu et al., 2024c).
- **의미적 중복 제거**: 마지막으로, 우리는 의미적 중복 제거(Abbas et al., 2023; Liu et al., 2024c)를 수행합니다. 우리는 먼저 RoBERTa(Liu et al., 2019b)를 사용하여 전체 대화를 클러스터링하고, 각 클러스터 내에서 품질 점수와 난이도 점수로 정렬합니다. 그런 다음 모든 정렬된 예제를 순차적으로 선택하고, 클러스터에서 이전에 본 예제와의 최대 코사인 유사성이 임계값 미만인 예제만 유지합니다.

### 4.3 기능 (Capabilities)

우리는 코드(섹션 4.3.1), 다중 언어(섹션 4.3.2), 수학 및 추론(섹션 4.3.3), 긴 컨텍스트(섹션 4.3.4), 도구 사용(섹션 4.3.5), 사실성(섹션 4.3.6), 그리고 조정 가능성(섹션 4.3.7)과 같은 특정 기능의 성능을 개선하기 위한 특별한 노력을 강조합니다.

### 4.3.1 코드

코드에 대한 LLMs는 Copilot과 Codex의 출시 이후로 큰 주목을 받았습니다(Chen et al., 2021). 개발자들은 이제 코드 생성, 디버깅, 작업 자동화, 코드 품질 향상을 위해 이러한 모델을 널리 사용하고 있습니다. Llama 3의 경우, 우리는 다음과 같은 주요 프로그래밍 언어에 대한 코드 생성, 문서화, 디버깅 및 리뷰 기능을 개선하고 평가하는 것을 목표로 합니다: Python, Java, Javascript, C/C++, Typescript, Rust, PHP, HTML/CSS, SQL, bash/shell. 여기서는 코드 전문가를 훈련하고, SFT를 위한 합성 데이터를 생성하며, 시스템 프롬프트 유도를 통해 형식을 개선하고, 훈련 데이터에서 나쁜 샘플을 제거하기 위한 품질 필터를 만드는 등의 작업을 통해 이러한 코딩 기능을 개선하는 작업을 설명합니다.

#### 전문가 훈련

우리는 후속 사후 훈련 라운드 동안 고품질의 인간 주석을 수집하기 위해 사용할 코드 전문가를 훈련합니다. 이는 주로 코드 데이터(>85%)를 포함하는 1T 토큰 믹스에서 주 훈련을 분기하고 계속 사전 훈련하여 달성됩니다. 특정 도메인 데이터에서의 지속적인 사전 훈련은 특정 도메인에서의 성능을 향상시키는 데 효과적임이 입증되었습니다(Gururangan et al., 2020). 우리는 CodeLlama(Rozière et al., 2023)와 유사한 레시피를 따릅니다. 훈련의 마지막 몇 천 단계 동안, 우리는 고품질의 리포 수준 코드 데이터를 사용하여 전문가의 컨텍스트 길이를 16K 토큰으로 확장하기 위해 긴 컨텍스트 미세 조정(LCFT)을 수행합니다. 마지막으로, 이 모델을 정렬하기 위해 섹션 4.1에서 설명한 유사한 사후 훈련 모델링 레시피를 따르되, 주로 코드를 타겟으로 한 SFT 및 DPO 데이터 믹스를 사용합니다. 이 모델은 코딩 프롬프트에 대한 거부 샘플링(섹션 4.2.2)에도 사용됩니다.

#### 합성 데이터 생성

개발 과정에서 우리는 명령 수행의 어려움, 코드 구문 오류, 잘못된 코드 생성, 버그 수정의 어려움 등 코드 생성에서의 주요 문제를 식별했습니다. 이론적으로는 집중적인 인간 주석이 이러한 문제를 해결할 수 있지만, 합성 데이터 생성은 주석자의 전문성 수준에 구애받지 않고 더 낮은 비용과 더 큰 규모로 보완적인 접근 방식을 제공합니다. 따라서 우리는 Llama 3와 코드 전문가를 사용하여 대량의 합성 SFT 대화를 생성합니다. 우리는 합성 코드 데이터를 생성하기 위한 세 가지 고수준 접근 방식을 설명합니다. 총 270만 개 이상의 합성 예제가 SFT 동안 사용되었습니다.

1. **합성 데이터 생성: 실행 피드백**:
   - 8B 및 70B 모델은 더 크고 더 능숙한 모델이 생성한 데이터로 훈련될 때 성능이 크게 향상됩니다. 그러나 초기 실험에서 Llama 3 405B가 자체 생성한 데이터로 훈련되는 것이 도움이 되지 않음을 발견했습니다(성능이 저하될 수도 있음). 이 제한을 해결하기 위해, 우리는 진실의 원천으로서 실행 피드백을 도입하여 모델이 실수에서 배우고 올바른 경로를 유지하도록 했습니다. 특히, 우리는 다음 프로세스를 사용하여 약 백만 개의 합성 코딩 대화 데이터를 생성했습니다:
     - 문제 설명 생성: 먼저, 다양한 주제를 포함하는 프로그래밍 문제 설명의 대규모 컬렉션을 생성합니다. 이를 위해 다양한 소스에서 임의의 코드 스니펫을 샘플링하고, 이러한 예제에서 영감을 얻어 프로그래밍 문제를 생성하도록 모델을 프롬프트합니다.
     - 솔루션 생성: 그런 다음, Llama 3에게 주어진 프로그래밍 언어로 각 문제를 해결하도록 프롬프트합니다. 프롬프트에 좋은 프로그래밍의 일반 규칙을 추가하면 생성된 솔루션의 품질이 향상됨을 관찰했습니다. 또한, 모델이 주석에서 생각 과정을 설명하도록 요구하는 것이 도움이 됩니다.
     - 정확성 분석: 솔루션을 생성한 후, 그 정확성이 보장되지 않으며 잘못된 솔루션을 미세 조정 데이터셋에 포함시키는 것이 모델의 품질에 해로울 수 있음을 인식하는 것이 중요합니다. 우리는 완전한 정확성을 보장하지는 않지만 이를 근사화하는 방법을 개발했습니다. 이를 위해 생성된 솔루션의 소스 코드를 추출하고 정적 및 동적 분석 기술을 결합하여 정확성을 테스트합니다.
       - 정적 분석: 모든 생성된 코드를 파서 및 린터를 통해 실행하여 구문 오류, 초기화되지 않은 변수 사용, 비수입 함수, 코드 스타일 문제, 타이핑 오류 등을 잡아냅니다.
       - 단위 테스트 생성 및 실행: 각 문제 및 솔루션에 대해 모델이 단위 테스트를 생성하도록 프롬프트하고, 솔루션과 함께 컨테이너화된 환경에서 실행하여 런타임 실행 오류와 일부 의미 오류를 잡아냅니다.
     - 오류 피드백 및 반복적 자기 수정: 솔루션이 어느 단계에서 실패하면 모델에게 이를 수정하도록 프롬프트합니다. 프롬프트에는 원래 문제 설명, 결함 있는 솔루션, 파서/린터/테스터의 피드백(stdout, stderr, 반환 코드)이 포함됩니다. 단위 테스트 실행 실패 후, 모델은 기존 테스트를 통과하도록 코드를 수정하거나 생성된 코드에 맞게 단위 테스트를 수정할 수 있습니다. 모든 검사를 통과한 대화만 최종 데이터셋에 포함되어 SFT에 사용됩니다. 약 20%의 솔루션이 초기에는 잘못되었지만 자기 수정된 것을 관찰했으며, 이는 모델이 실행 피드백에서 배우고 성능을 개선했음을 나타냅니다.
     - 미세 조정 및 반복적 개선: 미세 조정 과정은 여러 라운드에 걸쳐 진행되며, 각 라운드는 이전 라운드에 기반하여 구축됩니다. 각 라운드 후, 모델은 개선되어 다음 라운드를 위한 더 높은 품질의 합성 데이터를 생성합니다. 이 반복 과정은 모델 성능의 점진적인 개선과 향상을 허용합니다.
2. **합성 데이터 생성: 프로그래밍 언어 번역**:
   - 우리는 주요 프로그래밍 언어(예: Python/C++)와 덜 일반적인 언어(예: Typescript/PHP) 사이의 성능 격차를 관찰했습니다. 이는 덜 일반적인 프로그래밍 언어에 대한 훈련 데이터가 적기 때문에 놀라운 일이 아닙니다. 이를 완화하기 위해, 우리는 기존 데이터를 일반적인 프로그래밍 언어에서 덜 일반적인 언어로 번역하여 데이터 양을 보충합니다(논리의 맥락에서 Chen et al., 2023과 유사). 이는 Llama 3를 프롬프트하고 구문 분석, 컴파일 및 실행을 통해 품질을 보장하여 달성됩니다. 그림 8은 Python에서 번역된 합성 PHP 코드의 예를 보여줍니다. MultiPL-E(Cassano et al., 2023) 벤치마크로 측정한 덜 일반적인 언어의 성능이 크게 향상되었습니다.
3. 합성 데이터 생성: 역번역 (Backtranslation)
   - **생성 (Generate)**: Llama 3를 프롬프트하여 목표 기능을 나타내는 데이터를 생성합니다(예: 코드 스니펫에 주석 및 도크스트링 추가, 코드 조각 설명).
   - **역번역 (Backtranslate)**: 그런 다음 모델을 프롬프트하여 합성된 데이터를 원래 코드로 "역번역"합니다(예: 모델에게 문서화만으로 코드를 생성하도록 하거나, 설명만으로 코드를 생성하도록 요청).
   - **필터링 (Filter)**: 원래 코드를 참조하여 Llama 3에게 출력의 품질을 결정하도록 프롬프트합니다(예: 모델에게 역번역된 코드가 원래 코드에 얼마나 충실한지 평가하도록 요청). 그런 다음 자기 검증 점수가 가장 높은 생성된 예제를 SFT에 사용합니다.
4. 코딩 설명이나 문서화와 같은 특정 코딩 기능을 개선하기 위해 실행 피드백이 품질 결정에 덜 유용할 때, 우리는 대안적인 다단계 접근 방식을 사용합니다. 이 절차를 통해, 우리는 코드 설명, 생성, 문서화 및 디버깅과 관련된 약 120만 개의 합성 대화를 생성했습니다. 사전 훈련 데이터에 있는 다양한 언어의 코드 스니펫을 시작으로:

![](/assets/images/posts/219/img_15.png)

### 그림 8: 코드 번역 예제

Llama 3를 사용하여 Python 코드를 PHP 코드로 번역하여 더 다양한 프로그래밍 언어로 SFT 데이터셋을 확장하는 예제를 보여줍니다.

![](/assets/images/posts/219/img_16.png)

### 그림 9: 시스템 프롬프트로 생성된 코드 품질 개선

왼쪽: 시스템 프롬프트 없이 생성된 코드 오른쪽: 시스템 프롬프트로 개선된 코드

### 시스템 프롬프트 유도를 통한 거부 샘플링

거부 샘플링 과정에서, 우리는 코드의 가독성, 문서화, 철저함 및 구체성을 개선하기 위해 코드 특화 시스템 프롬프트를 사용했습니다. 섹션 7에서 설명한 바와 같이, 이 데이터는 언어 모델을 미세 조정하는 데 사용됩니다. 그림 9는 시스템 프롬프트가 생성된 코드 품질을 어떻게 향상시키는지 보여주는 예입니다. 필요한 주석을 추가하고, 더 유익한 변수 이름을 사용하며, 메모리를 절약하는 등의 효과가 있습니다.

### 실행 및 모델-판단 신호를 사용한 훈련 데이터 필터링

섹션 4.2.3에서 설명한 바와 같이, 우리는 때때로 거부 샘플링된 데이터에서 코드 블록에 버그가 포함되는 등의 품질 문제를 겪습니다. 거부 샘플링된 데이터에서 이러한 문제를 감지하는 것은 합성 코드 데이터에서 감지하는 것만큼 간단하지 않습니다. 거부 샘플링된 응답은 일반적으로 자연어와 코드가 혼합되어 있으며, 코드가 항상 실행 가능한 것으로 기대되지 않을 수 있기 때문입니다. (예: 사용자 프롬프트가 명시적으로 의사 코드 또는 실행 가능한 프로그램의 매우 작은 스니펫에 대한 편집을 요청할 수 있음). 이를 해결하기 위해 우리는 "모델-판단" 접근 방식을 사용하여 Llama 3의 이전 버전이 두 가지 기준(코드 정확성 및 코드 스타일)에 따라 이진(0/1) 점수를 부여하도록 합니다. 우리는 이 점수에서 2점을 받은 샘플만 유지합니다. 처음에는 이러한 엄격한 필터링이 주로 도전적인 프롬프트가 포함된 예제를 불균형하게 제거하여 다운스트림 벤치마크 성능이 저하되었습니다. 이를 해결하기 위해, 우리는 Llama 기반 "모델-판단" 기준을 충족할 때까지 가장 도전적인 코딩 데이터의 응답을 전략적으로 수정했습니다. 이러한 도전적인 문제를 정제함으로써, 코딩 데이터는 품질과 난이도 사이에서 균형을 이루어 최적의 다운스트림 성능을 달성했습니다.

### 4.3.2 다중 언어 능력

우리는 Llama 3의 다중 언어 능력을 향상시키는 방법을 설명합니다. 여기에는 상당히 더 많은 다중 언어 데이터로 전문화를 진행하는 전문가를 훈련하고, 독일어, 프랑스어, 이탈리아어, 포르투갈어, 힌디어, 스페인어, 태국어에 대한 고품질 다중 언어 명령 조정 데이터를 소싱하고 생성하며, 다중 언어 언어 유도의 특정 과제를 해결하여 모델의 전체 성능을 향상시키는 작업이 포함됩니다.

#### 전문가 훈련

우리의 Llama 3 사전 훈련 데이터 믹스에는 영어 토큰이 비영어 토큰보다 훨씬 많이 포함되어 있습니다. 비영어 언어로 고품질의 인간 주석을 수집하기 위해, 우리는 사전 훈련을 분기하고 90% 다중 언어 토큰으로 구성된 데이터 믹스에서 계속 사전 훈련하여 다중 언어 전문가를 훈련합니다. 그런 다음 섹션 4.1을 따라 이 전문가를 사후 훈련합니다. 이 전문가 모델은 사전 훈련이 완전히 완료될 때까지 비영어 언어에서 고품질의 주석을 수집하는 데 사용됩니다.

### 다중 언어 데이터 수집

우리의 다중 언어 SFT 데이터는 주로 아래에 설명된 소스에서 파생됩니다. 전체 분포는 2.4% 인간 주석, 44.2% 기타 NLP 작업 데이터, 18.8% 거부 샘플링 데이터, 34.6% 번역된 추론 데이터로 구성됩니다.

- **인간 주석**: 우리는 언어학자와 원어민으로부터 고품질의 수동 주석 데이터를 수집합니다. 이러한 주석은 주로 실제 사용 사례를 나타내는 개방형 프롬프트로 구성됩니다.
- **기타 NLP 작업 데이터**: 추가적으로, 우리는 다른 작업에서 다중 언어 훈련 데이터를 사용하여 대화 형식으로 다시 작성합니다. 예를 들어, 우리는 exams-qa(Hardalov et al., 2020)와 Conic10k(Wu et al., 2023)에서 데이터를 사용합니다. 언어 정렬을 개선하기 위해, 우리는 GlobalVoices(Prokopidis et al., 2016)와 Wikimedia(Tiedemann, 2012)에서 평행 텍스트도 사용합니다. 우리는 LID 기반 필터링과 Blaser2.0(Seamless Communication et al., 2023)을 사용하여 저품질 데이터를 제거합니다. 평행 텍스트 데이터의 경우, 비텍스트 쌍을 직접 사용하기보다는 Wei et al.(2022a)에서 영감을 받은 다중 언어 템플릿을 적용하여 번역 및 언어 학습 시나리오에서 실제 대화를 더 잘 시뮬레이션합니다.
- **거부 샘플링 데이터**: 우리는 인간 주석 프롬프트에 거부 샘플링을 적용하여 미세 조정을 위한 고품질 샘플을 생성합니다. 영어 데이터의 프로세스와 몇 가지 수정 사항이 있습니다:
  - **생성**: 사후 훈련 초기 라운드에서 다양한 생성을 위해 0.2에서 1 사이의 범위에서 온도 하이퍼파라미터를 무작위로 선택하는 것을 탐색했습니다. 높은 온도에서는 다중 언어 프롬프트에 대한 응답이 창의적이고 영감을 줄 수 있지만, 불필요하거나 부자연스러운 코드 전환이 발생할 수 있습니다. 사후 훈련의 마지막 라운드에서는 0.6의 일정한 값을 사용하여 이러한 트레이드오프를 균형 있게 유지합니다. 또한, 응답 형식, 구조 및 전반적인 가독성을 개선하기 위해 특수화된 시스템 프롬프트를 사용했습니다.
  - **선택**: 보상 모델 기반 선택 전에, 우리는 프롬프트와 응답 간의 높은 언어 일치율을 보장하기 위해 다중 언어 특정 검사를 구현했습니다(예: 로마자 힌디어 프롬프트는 힌디어 데바나가리 스크립트로 응답하지 않아야 합니다).
- **번역 데이터**: 우리는 모델을 미세 조정하기 위해 기계 번역된 데이터를 사용하는 것을 피하려고 노력합니다. 이는 번역체(Bizzoni et al., 2020; Muennighoff et al., 2023), 가능한 이름 편향(Wang et al., 2022a), 성별 편향(Savoldi et al., 2021), 또는 문화적 편향(Ji et al., 2023)을 방지하기 위해서입니다. 또한, 우리는 모델이 영어 문화적 맥락에 뿌리를 둔 작업에만 노출되는 것을 방지하고자 합니다. 이는 우리가 포착하고자 하는 언어 및 문화적 다양성을 대표하지 않을 수 있습니다. 우리는 비영어 언어에서 수량 추론 성능을 향상시키기 위해 합성 수량 추론 데이터를 번역하는 예외를 두었습니다(자세한 내용은 섹션 4.3.3 참조). 이 수학 문제의 간단한 언어 특성으로 인해 번역된 샘플에서 품질 문제가 거의 없었습니다. MGSM(Shi et al., 2022)에서 이 번역 데이터를 추가한 후 강력한 성능 향상을 관찰했습니다.

### 4.3.3 수학 및 추론

우리는 추론을 다단계 계산을 수행하고 올바른 최종 답변에 도달하는 능력으로 정의합니다. 수학적 추론에서 우수한 모델을 훈련하는 접근 방식을 안내하는 몇 가지 과제는 다음과 같습니다:

- **프롬프트 부족**: 질문의 복잡성이 증가함에 따라, 유효한 프롬프트 또는 질문의 수가 감소합니다. 이는 모델에 다양한 수학적 기술을 가르치기 위한 대표적인 훈련 데이터셋을 만드는 것을 어렵게 만듭니다(Yu et al., 2023; Yue et al., 2023; Luo et al., 2023; Mitra et al., 2024; Shao et al., 2024; Yue et al., 2024b).
- **사고 과정의 실제 예 부족**: 효과적인 추론은 사고 과정을 단계별로 진행하여 문제를 해결하는 것이 필요합니다(Wei et al., 2022c). 그러나 문제를 단계별로 해결하고 최종 답변에 도달하는 방법을 안내하는 실제 사고 과정의 예가 종종 부족합니다(Zelikman et al., 2022).
- **잘못된 중간 단계**: 모델 생성 사고 과정을 사용할 때, 중간 단계가 항상 올바르지 않을 수 있습니다(Cobbe et al., 2021; Uesato et al., 2022; Lightman et al., 2023; Wang et al., 2023a). 이 부정확성은 잘못된 최종 답변으로 이어질 수 있으며, 해결이 필요합니다.
- **외부 도구 사용 학습**: 코드 인터프리터와 같은 외부 도구를 사용하는 모델을 향상시키면, 코드와 텍스트를 교차하여 추론할 수 있습니다(Gao et al., 2023; Chen et al., 2022; Gou et al., 2023). 이 기능은 문제 해결 능력을 크게 향상시킬 수 있습니다.
- **훈련과 추론 간의 불일치**: 훈련 중 모델이 미세 조정되는 방식과 추론 중 사용되는 방식 간에는 종종 불일치가 있습니다. 추론 중에 미세 조정된 모델은 인간이나 다른 모델과 상호 작용할 수 있으며, 피드백을 사용하여 추론을 개선해야 할 수 있습니다. 훈련과 실제 사용 간의 일관성을 보장하는 것은 추론 성능을 유지하는 데 중요합니다.

이러한 과제를 해결하기 위해 다음 방법론을 적용합니다:

- **프롬프트 부족 해결**: 우리는 수학적 맥락에서 관련 사전 훈련 데이터를 소싱하여 이를 감독된 미세 조정을 위한 질문-답변 형식으로 변환합니다. 또한 모델이 성능이 저하된 수학적 기술을 식별하고, 사람들로부터 이러한 기술을 가르치는 프롬프트를 적극적으로 소싱합니다. 이 과정을 용이하게 하기 위해, 우리는 수학적 기술의 분류를 작성하고(Didolkar et al., 2024), 사람들에게 관련 프롬프트/질문을 제공하도록 요청합니다.
- **단계별 추론 추적을 포함한 훈련 데이터 보강**: 우리는 Llama 3를 사용하여 일련의 프롬프트에 대해 단계별 솔루션을 생성합니다. 각 프롬프트에 대해 모델은 가변적인 수의 생성을 생성합니다. 이러한 생성은 올바른 답변을 기반으로 필터링됩니다(Li et al., 2024a). 우리는 또한 Llama 3를 사용하여 특정 단계별 솔루션이 주어진 질문에 대해 유효한지 여부를 검증합니다. 이 과정은 유효한 추론 추적을 생성하지 않는 인스턴스를 제거하여 미세 조정 데이터의 품질을 향상시킵니다.
- **잘못된 추론 추적 필터링**: 우리는 중간 추론 단계가 잘못된 훈련 데이터를 필터링하기 위해 결과 및 단계별 보상 모델(Lightman et al., 2023; Wang et al., 2023a)을 훈련합니다. 이러한 보상 모델은 유효하지 않은 단계별 추론이 포함된 데이터를 제거하여 미세 조정을 위한 고품질 데이터를 보장합니다. 더 도전적인 프롬프트의 경우, 우리는 학습된 단계별 보상 모델을 사용하여 유효한 추론 추적을 생성하기 위해 몬테카를로 트리 탐색(MCTS)을 사용하여 고품질 추론 데이터 수집을 더욱 향상시킵니다(Xie et al., 2024).
- **코드와 텍스트 추론을 교차하여 사용**: 우리는 Llama 3에게 텍스트 추론과 관련된 파이썬 코드를 결합하여 추론 문제를 해결하도록 프롬프트합니다(Gou et al., 2023). 코드 실행은 추론 체인이 유효하지 않은 경우를 제거하는 피드백 신호로 사용되어 추론 과정의 정확성을 보장합니다.
- **피드백과 실수로부터 학습**: 인간 피드백을 시뮬레이션하기 위해, 우리는 잘못된 생성(즉, 잘못된 추론 추적으로 이어지는 생성)을 사용하여 오류 수정을 수행하고, Llama 3에게 올바른 생성을 제공하도록 프롬프트합니다(An et al., 2023b; Welleck et al., 2022; Madaan et al., 2024a). 잘못된 시도로부터 피드백을 사용하고 이를 수정하는 반복적인 과정은 모델이 정확하게 추론하고 실수로부터 학습하는 능력을 향상시키는 데 도움이 됩니다.

### 4.3.4 긴 컨텍스트

최종 사전 훈련 단계에서, 우리는 Llama 3의 컨텍스트 길이를 8K 토큰에서 128K 토큰으로 확장합니다(자세한 내용은 섹션 3.4 참조). 사전 훈련과 유사하게, 우리는 미세 조정 중에도 짧은 컨텍스트와 긴 컨텍스트 기능 간의 균형을 맞추기 위해 레시피를 신중하게 조정해야 한다는 것을 발견했습니다.

#### SFT와 합성 데이터 생성

기존의 SFT 레시피를 짧은 컨텍스트 데이터만으로 적용하는 것은 사전 훈련에서 긴 컨텍스트 기능의 상당한 성능 저하를 초래하여, SFT 데이터 믹스에 긴 컨텍스트 데이터를 포함해야 한다는 필요성을 강조했습니다. 그러나 실제로는 긴 컨텍스트 예제를 인간이 주석 달도록 하는 것은 읽는 데 많은 시간과 노력이 필요하기 때문에 비현실적입니다. 그래서 우리는 주로 합성 데이터에 의존하여 이 공백을 채웁니다. 우리는 Llama 3의 이전 버전을 사용하여 주요 긴 컨텍스트 사용 사례에 기반한 합성 데이터를 생성합니다: (여러 번의 대화를 포함할 수 있는) 질문-응답, 긴 문서 요약, 코드 저장소에 대한 추론. 이를 아래에서 자세히 설명합니다.

- **질문 응답**: 우리는 사전 훈련 믹스에서 신중하게 긴 문서 집합을 큐레이션합니다. 이러한 문서를 8K 토큰의 청크로 나누고, 이전 버전의 Llama 3 모델을 프롬프트하여 무작위로 선택된 청크에 따라 QA 쌍을 생성합니다. 훈련 중에는 전체 문서를 컨텍스트로 사용합니다.
- **요약**: 우리는 긴 컨텍스트 문서의 계층적 요약을 적용합니다. 먼저, 가장 강력한 Llama 3 8K 컨텍스트 모델을 사용하여 8K 입력 길이의 청크를 요약하고, 그런 다음 요약본을 다시 요약합니다. 훈련 중에는 전체 문서를 제공하고 모델이 중요한 세부 정보를 모두 보존하면서 문서를 요약하도록 프롬프트합니다. 우리는 또한 문서 요약을 기반으로 QA 쌍을 생성하고, 전체 긴 문서에 대한 전반적인 이해를 요구하는 질문으로 모델을 프롬프트합니다.
- **긴 컨텍스트 코드 추론**: 우리는 Python 파일을 파싱하여 import 문을 식별하고 그들의 종속성을 결정합니다. 여기에서, 적어도 다섯 개 이상의 다른 파일에서 참조된 파일을 선택합니다. 그런 다음 이러한 주요 파일 중 하나를 저장소에서 제거하고 모델에게 누락된 파일에 의존하는 파일을 식별하고 필요한 누락된 코드를 생성하도록 프롬프트합니다.

우리는 이러한 합성된 샘플을 시퀀스 길이(16K, 32K, 64K, 128K)에 따라 분류하여 입력 길이별로 더 정밀하게 타겟팅할 수 있도록 합니다. 신중한 제거 실험을 통해, 합성된 긴 컨텍스트 데이터의 0.1%를 기존의 짧은 컨텍스트 데이터와 혼합하면 짧은 컨텍스트와 긴 컨텍스트 벤치마크 모두에서 성능이 최적화됨을 관찰했습니다.

#### DPO

DPO에서 짧은 컨텍스트 훈련 데이터만 사용하는 것이 긴 컨텍스트 성능에 부정적인 영향을 미치지 않는 것을 관찰했습니다. 이는 SFT 모델이 긴 컨텍스트 작업에 적합할 경우에 해당합니다. 이는 DPO 레시피의 옵티마이저 단계가 SFT보다 적기 때문일 것으로 추측됩니다. 이 발견을 바탕으로, 우리는 긴 컨텍스트 SFT 체크포인트 위에 표준 짧은 컨텍스트 레시피를 유지합니다.

### 4.3.5 도구 사용

LLM에게 검색 엔진이나 코드 인터프리터 같은 도구를 사용하는 법을 가르치면, 그들이 해결할 수 있는 작업의 범위가 크게 확장되어 순수한 채팅 모델에서 더 일반적인 어시스턴트로 변모합니다(Nakano et al., 2021; Thoppilan et al., 2022; Parisi et al., 2022; Gao et al., 2023; Mialon et al., 2023a; Schick et al., 2024). 우리는 Llama 3가 다음 도구들과 상호작용할 수 있도록 훈련합니다:

- **검색 엔진**: Llama 3는 Brave Search를 사용하여 지식 컷오프를 넘어서는 최근 사건에 대한 질문이나 웹에서 특정 정보를 검색해야 하는 질문에 답할 수 있습니다.
- **Python 인터프리터**: Llama 3는 복잡한 계산을 수행하기 위해 코드를 생성하고 실행할 수 있으며, 사용자가 업로드한 파일을 읽고 이를 기반으로 질문에 답하거나 요약, 데이터 분석 또는 시각화를 수행할 수 있습니다.
- **수학적 계산 엔진**: Llama 3는 Wolfram Alpha API를 사용하여 수학이나 과학 문제를 더 정확하게 해결하거나 Wolfram의 데이터베이스에서 정확한 정보를 검색할 수 있습니다.

결과적으로, 이 모델은 채팅 환경에서 이러한 도구들을 사용하여 사용자의 쿼리를 해결할 수 있으며, 다중 회전 대화에서도 가능합니다. 쿼리가 여러 도구 호출을 필요로 하는 경우, 모델은 단계별 계획을 작성하고, 순차적으로 도구를 호출하며, 각 도구 호출 후 추론을 수행할 수 있습니다.

또한, Llama 3의 제로샷 도구 사용 능력을 향상시켰습니다. 주어진 맥락에서 잠재적으로 보지 못한 도구 정의와 사용자 쿼리를 통해 올바른 도구 호출을 생성하도록 모델을 훈련했습니다.

### 구현

우리는 핵심 도구들을 다양한 메서드를 가진 Python 객체로 구현했습니다. 제로샷 도구는 설명과 문서(예: 사용 예시)가 있는 Python 함수로 구현할 수 있으며, 모델은 함수의 시그니처와 도크스트링만을 맥락으로 사용하여 적절한 호출을 생성할 수 있습니다. 우리는 함수 정의와 호출을 JSON 형식으로 변환하기도 합니다, 예를 들어 웹 API 호출을 위해. 모든 도구 호출은 Python 인터프리터에 의해 실행되며, 이는 Llama 3 시스템 프롬프트에서 활성화되어야 합니다. 핵심 도구는 시스템 프롬프트에서 개별적으로 활성화하거나 비활성화할 수 있습니다.

### 데이터 수집

Schick et al. (2024)와 다르게, 우리는 Llama 3에게 도구 사용을 가르치기 위해 인간 주석과 선호도를 사용합니다. Llama 3에서 일반적으로 사용되는 사후 훈련 파이프라인과 두 가지 주요 차이점이 있습니다:

- 도구의 경우, 대화는 종종 단일 어시스턴트 메시지 이상을 포함합니다(예: 도구 호출 및 도구 출력에 대한 추론). 따라서, 우리는 메시지 수준에서 주석을 달아 세분화된 피드백을 수집합니다: 주석자는 동일한 맥락에서 두 어시스턴트 메시지 사이에서 선호도를 제공하거나, 두 메시지 모두 주요 문제가 있는 경우 메시지 중 하나를 편집합니다. 선택된 또는 편집된 메시지는 맥락에 추가되고 대화가 계속됩니다. 이는 어시스턴트가 도구를 호출하고 도구 출력을 추론하는 능력에 대한 인간 피드백을 제공합니다. 주석자는 도구 출출을 순위 매기거나 편집할 수 없습니다.
- 우리는 거부 샘플링을 수행하지 않습니다, 도구 벤치마크에서 이점이 관찰되지 않았기 때문입니다.

주석 프로세스를 가속화하기 위해, 우리는 이전 Llama 3 체크포인트에서 합성적으로 생성된 데이터에 대해 미세 조정을 수행하여 기본 도구 사용 능력을 부트스트래핑합니다. 따라서 주석자는 수행할 편집이 적습니다. 유사한 정신으로, Llama 3가 점진적으로 개발을 통해 개선됨에 따라, 우리는 인간 주석 프로토콜을 점진적으로 복잡하게 만듭니다: 단일 회전 도구 사용 주석에서 시작하여 대화에서 도구 사용을 다루고, 최종적으로 다중 단계 도구 사용 및 데이터 분석에 대한 주석을 수행합니다.

### 도구 데이터셋

도구 사용 애플리케이션을 위한 데이터를 생성하기 위해 다음 절차를 활용합니다:

- **단계별 도구 사용**: 우리는 몇 샷 생성(few-shot generation) 방법을 사용하여 우리 핵심 도구 중 하나의 호출이 필요한 합성 사용자 프롬프트를 생성합니다(예: 지식 컷오프 날짜를 초과하는 질문). 그런 다음, 적절한 도구 호출을 생성하고 실행하여 출력 결과를 모델의 컨텍스트에 추가합니다. 마지막으로, 도구 출력을 기반으로 사용자의 질문에 대한 최종 답변을 생성하도록 모델을 다시 프롬프트합니다. 최종적으로 다음과 같은 형태의 경로를 얻습니다: 시스템 프롬프트, 사용자 프롬프트, 도구 호출, 도구 출력, 최종 답변. 실행할 수 없는 도구 호출이나 기타 형식 문제를 제거하기 위해 이 데이터셋의 약 30%를 필터링합니다.
- **다단계 도구 사용**: 유사한 프로토콜을 따르며, 모델에게 기본적인 다단계 도구 사용 능력을 가르치기 위해 합성 데이터를 먼저 생성합니다. 이를 위해 먼저 최소 두 번의 도구 호출이 필요한 사용자 프롬프트를 생성하도록 Llama 3를 프롬프트합니다. 그런 다음, 이러한 프롬프트에 조건을 두고 Llama 3를 몇 샷 프롬프트하여 추론 단계와 도구 호출이 교차된 솔루션을 생성합니다(예: ReAct(Yao et al., 2022)와 유사). 그림 10은 다단계 도구 사용을 포함한 작업을 수행하는 Llama 3의 예를 보여줍니다.
- **파일 업로드**: 다음 파일 유형에 대해 주석을 달았습니다: .txt, .docx, .pdf, .pptx, .xlsx, .csv, .tsv, .py, .json, .jsonl, .html, .xml. 우리는 제공된 파일을 기반으로 한 프롬프트를 작성하여 파일의 내용을 요약하거나, 버그를 찾아 수정하거나, 코드의 최적화, 데이터 분석 또는 시각화를 수행하도록 요청합니다. 그림 11은 파일 업로드를 포함한 작업을 수행하는 Llama 3의 예를 보여줍니다.

이 합성 데이터에 대한 미세 조정 후, 우리는 다중 회전 상호작용, 세 단계 이상의 도구 사용, 도구 호출이 만족스러운 답변을 제공하지 못하는 경우 등을 포함한 다양한 도전적인 시나리오에서 인간 주석을 수집합니다. 우리는 도구가 활성화된 경우에만 도구를 사용하도록 모델을 가르치기 위해 다른 시스템 프롬프트로 합성 데이터를 보강합니다. 모델이 간단한 쿼리에 대해 도구를 호출하지 않도록 훈련하기 위해, 우리는 쉬운 수학 문제 또는 질문 응답 데이터셋(Berant et al., 2013; Koncel-Kedziorski et al., 2016; Joshi et al., 2017; Amini et al., 2019)에서 도구 없이 응답한 쿼리도 추가하지만, 시스템 프롬프트에서는 도구가 활성화되어 있습니다.

![](/assets/images/posts/219/img_17.png)

그림 10 다단계 도구 사용 : Llama 3가 다단계 계획, 추론 및 도구 호출을 수행하여 작업을 해결하는 예제.

![](/assets/images/posts/219/img_18.png)

그림 11 파일 업로드 처리 중. 업로드된 파일의 분석 및 시각화를 수행하는 Llama 3의 예시.

### 미세 조정 및 평가

우리 모델을 평가하는 방법은 다음과 같습니다:

- **단일, 중첩, 병렬 함수 호출**: 호출은 단순할 수도 있고, 중첩될 수도 있으며, 병렬일 수도 있습니다. 예를 들어, 함수 호출을 다른 함수의 인수로 전달하거나, 모델이 독립적인 함수 호출 목록을 반환하는 경우입니다. 다양한 함수, 쿼리 및 정답을 생성하는 것은 도전적일 수 있으며(Mekala et al., 2024), 우리는 Stack(Kocetkov et al., 2022)을 채굴하여 합성 사용자 쿼리를 실제 함수에 기반시킵니다. 보다 정확하게는, 함수 호출과 그 정의를 추출하고, 문서 문자열이 누락되었거나 실행할 수 없는 함수 등을 정리하고 필터링한 다음, Llama 3를 사용하여 함수 호출에 해당하는 자연어 쿼리를 생성합니다.
- **다중 회전 함수 호출**: 우리는 또한 함수 호출을 포함한 다중 회전 대화를 위한 합성 데이터를 생성합니다(Li et al., 2023b에서 제안된 프로토콜과 유사한 프로토콜을 따름). 우리는 도메인, API, 사용자 쿼리, API 호출 및 응답을 생성하는 여러 에이전트를 사용하며, 생성된 데이터가 다양한 도메인과 현실적인 API를 다루도록 보장합니다. 모든 에이전트는 Llama 3의 변형으로, 그들의 역할에 따라 다른 방식으로 프롬프트를 받아 단계별로 협력합니다.

### 4.3.6 사실성

환각은 대형 언어 모델의 주요 도전 과제입니다. 모델은 지식이 부족한 도메인에서도 과신하는 경향이 있습니다. 이러한 단점에도 불구하고, 종종 지식 베이스로 사용되며, 이는 잘못된 정보의 확산과 같은 위험한 결과를 초래할 수 있습니다. 사실성이 환각을 넘어서지만, 우리는 여기서 환각을 우선으로 접근했습니다.

### 파일 업로드 처리

Llama 3가 업로드된 파일을 분석하고 시각화하는 예제입니다.

우리는 사후 훈련이 모델이 "자신이 아는 것을 알도록" 맞추는 원칙을 따르며, 지식을 추가하지 않습니다(Gekhman et al., 2024; Mielke et al., 2020). 우리의 주요 접근 방식은 사전 훈련 데이터에 존재하는 사실 데이터의 하위 집합과 모델 생성이 일치하도록 데이터를 생성하는 것입니다. 이를 위해 우리는 Llama 3의 맥락 내 능력을 활용한 지식 탐색 기술을 개발합니다. 이 데이터 생성 과정은 다음 절차를 포함합니다:

1. 사전 훈련 데이터에서 데이터 스니펫을 추출합니다.
2. Llama 3를 프롬프트하여 이 스니펫(컨텍스트)에 대한 사실 질문을 생성합니다.
3. 질문에 대한 Llama 3의 응답을 샘플링합니다.
4. 원래 컨텍스트를 참조로 사용하고 Llama 3를 심판으로 사용하여 생성물의 정확성을 평가합니다.
5. Llama 3를 심판으로 사용하여 생성물의 정보성을 평가합니다.
6. 여러 세대에 걸쳐 일관되게 정보적이지만 부정확한 응답에 대해서는 거부 응답을 생성합니다.

우리는 지식 탐색에서 생성된 데이터를 사용하여 모델이 알고 있는 질문에만 답변하고, 확신이 없는 질문은 답변을 거부하도록 합니다. 또한, 사전 훈련 데이터는 항상 사실적으로 일관되거나 정확하지 않으므로, 사실적으로 모순되거나 부정확한 진술이 만연한 민감한 주제를 다루는 제한된 사실성 데이터를 수집합니다.

### 4.3.7 조종 가능성 (Steerability)

조종 가능성은 모델의 행동과 결과를 개발자와 사용자의 요구 사항에 맞게 조정할 수 있는 능력을 의미합니다. Llama 3는 일반적인 기본 모델이기 때문에 다양한 하위 사용 사례에 쉽게 최대한 조종 가능해야 합니다. Llama 3의 경우, 특히 응답 길이, 형식, 톤 및 캐릭터/페르소나와 관련하여 자연어 지침을 사용한 시스템 프롬프트를 통해 조종 가능성을 향상시키는 데 중점을 둡니다.

### 데이터 수집

우리는 주석자에게 Llama 3를 위한 다양한 시스템 프롬프트를 설계하도록 요청하여 일반 영어 범주 내에서 조종 가능성 선호 샘플을 수집합니다. 주석자들은 모델과 대화를 하며 대화 중 시스템 프롬프트에 정의된 지침을 일관되게 따르는지 평가합니다. 아래는 조종 가능성을 향상시키기 위해 사용된 맞춤형 시스템 프롬프트의 예입니다:

```
당신은 바쁜 가족을 위한 식단 계획 보조로 활동하는 도움을 주고 명랑한 AI 챗봇입니다.
가족은 성인 2명, 청소년 3명, 미취학 아동 2명으로 구성되어 있습니다. 한 번에 이틀 또는 사흘
계획을 세우고, 두 번째 날의 계획에 남은 음식이나 추가 재료를 사용하세요. 사용자가 이틀 또는 사흘
계획을 원하는지 알려줍니다. 그렇지 않으면 사흘 계획을 기본으로 합니다. 각 계획에는 아침,
점심, 간식, 저녁이 포함되어야 합니다. 계획을 승인하거나 조정이 필요한지 사용자에게 묻습니다.
승인 후 가족 크기를 고려한 식료품 목록을 제공하세요. 가족의 선호를 항상 염두에 두고, 싫어하는
것이 있다면 대체품을 제공하세요. 사용자가 영감을 받지 못하고 있다면 이번 주에 가고 싶은
한 곳을 물어보고, 그 장소의 문화에 기반한 식사를 제안하세요. 주말 식사는 더 복잡할 수 있습니다.
평일 식사는 빠르고 쉬워야 합니다. 아침과 점심은 시리얼, 영국식 머핀과 미리 요리된 베이컨 같은
간편한 음식이 선호됩니다. 가족은 바쁩니다. 기본품목이나 즐겨찾는 음료(커피나 에너지 드링크 등)를
가지고 있는지 확인하세요. 특별한 경우가 아니라면 예산을 신경 쓰세요.
```

### 모델링

우리는 선호 데이터를 수집한 후, 이 데이터를 보상 모델링, 거부 샘플링, SFT 및 DPO에 활용하여 Llama 3의 조종 가능성을 향상시킵니다.

우리는 Llama 3의 성능을 평가하기 위해 광범위한 평가를 수행했습니다. 평가 항목은 다음과 같습니다: (1) 사전 훈련된 언어 모델, (2) 사후 훈련된 언어 모델, (3) Llama 3의 안전 특성. 각 항목에 대한 평가 결과를 아래의 별도 섹션에서 제시합니다.

### 5.1 사전 훈련된 언어 모델

이 섹션에서는 사전 훈련된 Llama 3(섹션 3 참조)의 평가 결과를 보고하며, 유사한 크기의 다양한 다른 모델과 비교합니다. 가능한 경우 경쟁 모델의 결과를 재현합니다. Llama 모델이 아닌 경우, 공개적으로 보고된 결과 또는 우리가 재현할 수 있는 경우, 최고의 점수를 보고합니다. 이러한 평가의 세부 사항, 구성(예: 샷 수, 메트릭 및 기타 관련 하이퍼파라미터와 설정)은 우리의 Github 저장소에서 확인할 수 있습니다. 추가적으로, 공개적으로 이용 가능한 벤치마크를 사용하여 평가의 일환으로 생성된 데이터를 Huggingface에서 찾을 수 있습니다. 우리는 표준 벤치마크(섹션 5.1.1), 다중 선택 질문 설정의 변화에 대한 견고성(섹션 5.1.2), 적대적 평가(섹션 5.1.3)에 대해 모델의 품질을 평가합니다. 또한, 평가가 훈련 데이터 오염에 의해 얼마나 영향을 받는지 추정하기 위해 오염 분석을 수행합니다(섹션 5.1.4).

#### 5.1.1 표준 벤치마크

우리 모델을 현재의 최첨단 기술과 비교하기 위해, Llama 3를 표 8에 나와 있는 다수의 표준 벤치마크 평가에서 평가합니다. 이러한 평가는 다음의 8가지 최상위 범주를 포함합니다: (1) 상식 추론; (2) 지식; (3) 독해력; (4) 수학, 추론 및 문제 해결; (5) 긴 컨텍스트; (6) 코드; (7) 적대적 평가; (8) 종합 평가.

![](/assets/images/posts/219/img_19.png)

#### 표 8 사전 훈련 벤치마크 카테고리별 개요

Llama 3 모델을 평가하기 위해 사용하는 모든 벤치마크를 능력 범주별로 그룹화한 개요.

### 실험 설정

각 벤치마크에 대해 Llama 3와 비교 가능한 크기의 다양한 사전 훈련된 모델들의 점수를 계산합니다. 가능한 경우, 다른 모델의 점수를 우리의 파이프라인으로 다시 계산합니다. 공정한 비교를 위해, 우리가 계산한 점수와 그 모델의 유사하거나 보수적인 설정에서 보고된 점수 중 가장 좋은 점수를 선택합니다. 평가 설정에 대한 추가 세부 사항은 여기를 참조하십시오. 일부 모델의 경우, 사전 훈련된 모델이 공개되지 않았거나 API가 로그 확률에 접근할 수 없기 때문에 벤치마크 값을 다시 계산할 수 없습니다. 특히, Llama 3 405B와 비교 가능한 모든 모델에 대해 그렇습니다. 따라서, 모든 벤치마크에 대해 모든 숫자가 제공되어야 하는 Llama 3 405B의 카테고리 평균을 보고하지 않습니다.

### 유의미성 값

벤치마크 점수를 계산할 때, 몇 샷 시연, 랜덤 시드, 배치 크기와 같은 여러 변동 요인으로 인해 모델의 성능에 대한 정확한 추정이 어려울 수 있습니다. 이는 한 모델이 다른 모델보다 통계적으로 유의미하게 더 나은지 이해하기 어렵게 만듭니다. 이러한 이유로, 우리는 벤치마크 데이터 선택으로 인한 변동에 대해 95% 신뢰 구간(CI)을 함께 보고합니다. 95% 신뢰 구간은 Madaan et al.(2024b)의 공식을 사용하여 분석적으로 계산합니다:

![](/assets/images/posts/219/img_20.png)

우선 벤치마크 점수 S와 벤치마크의 샘플 크기 N을 사용하여 95% 신뢰 구간(CI)을 계산합니다. 벤치마크 데이터의 분산이 유일한 변동 요인이 아니기 때문에, 이 95% CI는 실제 능력 추정치의 하한에 해당합니다. 단순 평균이 아닌 메트릭에 대해서는 CI를 생략합니다.

![](/assets/images/posts/219/img_21.png)

#### 그림 12

그림 12는 사전 훈련된 Llama 3 8B 및 70B 모델의 사전 훈련 벤치마크에서의 성능을 보여줍니다. 결과는 능력 카테고리별로 모든 벤치마크의 정확도를 평균하여 집계되었습니다.

#### 8B 및 70B 모델의 결과

그림 12는 상식 추론, 지식, 독해력, 수학 및 추론, 코드 벤치마크에서 Llama 3 8B 및 70B의 평균 성능을 보고합니다. 결과는 Llama 3 8B가 거의 모든 카테고리에서 경쟁 모델을 능가함을 보여주며, 카테고리별 승률과 평균 카테고리별 성능 모두에서 우수합니다. 또한, Llama 3 70B는 대부분의 벤치마크에서 이전 모델인 Llama 2 70B를 큰 차이로 능가하며, 상식 벤치마크를 제외하고는 대부분의 영역에서 더 나은 성능을 보입니다. Llama 3 70B는 Mixtral 8x22B도 능가합니다.

![](/assets/images/posts/219/img_22.png)

#### 표 9

사전 훈련된 모델의 독해력 작업 성능을 보여줍니다. 결과에는 95% 신뢰 구간이 포함됩니다.

![](/assets/images/posts/219/img_23.png)

#### 표 10

사전 훈련된 모델의 코딩 작업 성능을 보여줍니다. 결과에는 95% 신뢰 구간이 포함됩니다.

![](/assets/images/posts/219/img_24.png)

#### 표 11

사전 훈련된 모델의 상식 이해 작업 성능을 보여줍니다. 결과에는 95% 신뢰 구간이 포함됩니다.

![](/assets/images/posts/219/img_25.png)

#### 표 12

사전 훈련된 모델의 수학 및 추론 작업 성능을 보여줍니다. 결과에는 95% 신뢰 구간이 포함됩니다.

![](/assets/images/posts/219/img_26.png)

#### 표 13

사전 훈련된 모델의 일반 언어 작업 성능을 보여줍니다. 결과에는 95% 신뢰 구간이 포함됩니다.

![](/assets/images/posts/219/img_27.png)

#### 표 14

긴 문맥 작업에서 사전 훈련된 모델의 성능을 보여줍니다. 결과에는 95% 신뢰 구간이 포함됩니다.

#### 모든 모델에 대한 상세 결과

표 9, 10, 11, 12, 13, 14는 독해력 작업, 코딩 작업, 상식 이해 작업, 수학적 추론 작업, 일반 작업에서 사전 훈련된 Llama 3 8B, 70B, 405B 모델의 벤치마크 성능을 제시합니다. 이 표들은 Llama 3의 성능을 유사한 크기의 모델과 비교합니다. 결과는 Llama 3 405B가 해당 클래스의 다른 모델들과 경쟁력이 있음을 보여줍니다. 특히, Llama 3 405B는 이전의 오픈 소스 모델들을 크게 능가합니다. 긴 컨텍스트에 대해서는 5.2절에서 더 포괄적인 결과(needle-in-a-haystack와 같은 프로빙 작업 포함)를 제시합니다.

### 5.1.2 모델의 견고성

벤치마크 성능 외에도, 견고성은 사전 훈련된 언어 모델의 품질에 중요한 요소입니다. 우리는 여러 선택형 질문(MCQ) 설정에서 설계 선택에 대한 사전 훈련된 언어 모델의 견고성을 조사했습니다. 이전 연구에 따르면 이러한 설정에서 모델 성능은 겉보기에는 임의적인 설계 선택에 민감할 수 있으며(Lu et al., 2022; Zhao et al., 2021; Robinson and Wingate, 2023; Liang et al., 2022; Gupta et al., 2024), 예를 들어 문맥 내 예제의 순서와 레이블에 따라 모델 점수와 순위가 변할 수 있습니다. (Weber et al., 2023b; Mishra et al., 2022), 또는 답변 선택 형식과 순서(Alzahrani et al., 2024; Wang et al., 2024a; Zheng et al., 2023)와 같은 요소들이 있습니다. 이러한 연구에 영감을 받아 우리는 MMLU 벤치마크를 사용하여 사전 훈련된 모델의 견고성을 다음과 같은 항목에 대해 평가했습니다: (1) 몇 샷 레이블 편향, (2) 레이블 변형, (3) 답변 순서, (4) 프롬프트 형식.

- **몇 샷 레이블 편향**: Zheng et al. (2023) 및 Weber et al. (2023a)을 따라, 4 샷 예제의 레이블 분포에 미치는 영향을 조사했습니다. 구체적으로, (1) 모든 몇 샷 예제가 동일한 레이블을 갖는 설정(A A A A), (2) 모든 예제가 다른 레이블을 갖는 설정(A B C D), (3) 두 개의 레이블만 있는 설정(A A B B 및 C C D D)을 고려했습니다.
- **레이블 변형**: 다른 선택 토큰 세트에 대한 모델 응답도 연구했습니다. Alzahrani et al. (2024)가 제안한 두 세트를 고려했으며, 일반적인 언어 독립 토큰 세트($ & # @)와 암묵적 상대 순서가 없는 희귀 토큰 세트(oe § ç ü)를 사용했습니다. 또한, 표준 레이블(A. B. C. D. 및 A) B) C) D))과 숫자 목록(1. 2. 3. 4.)의 두 가지 버전을 고려했습니다.
- **답변 순서**: Wang et al. (2024a)를 따라, 다른 답변 순서에 대한 결과가 얼마나 안정적인지 계산했습니다. 이를 계산하기 위해 데이터셋의 모든 답변을 고정된 순열에 따라 재매핑했습니다. 예를 들어, A B C D 순열에서는 레이블 A와 B가 있는 모든 답변 옵션이 레이블을 유지하고, 레이블 C가 있는 모든 답변 옵션은 레이블 D를 얻고, 그 반대도 마찬가지입니다.
- **프롬프트 형식**: 제공된 정보 수준이 다른 다섯 가지 작업 프롬프트에서 성능 변동을 평가했습니다. 하나의 프롬프트는 단순히 모델에게 질문에 답하도록 요청하고, 다른 프롬프트는 모델의 전문성을 주장하거나 최선의 답변을 선택하도록 요청합니다.

그림 13은 레이블 변형(왼쪽) 및 몇 샷 레이블 편향(오른쪽)에 대한 모델 성능의 견고성을 연구한 결과를 보여줍니다. 결과는 사전 훈련된 언어 모델이 MCQ 레이블과 몇 샷 프롬프트 레이블의 구조 변화에 매우 견고함을 보여줍니다. 이 견고성은 특히 405B 파라미터 모델에서 두드러집니다. 그림 14는 답변 순서 및 프롬프트 형식에 대한 견고성 연구 결과를 보여줍니다. 그림의 결과는 사전 훈련된 언어 모델, 특히 Llama 3 405B의 성능의 견고성을 더욱 강조합니다.

![](/assets/images/posts/219/img_28.png)

#### 그림 13

다른 레이블 변형(왼쪽) 및 몇 샷 예제에 있는 레이블(오른쪽)에 대한 사전 훈련된 언어 모델의 견고성을 보여줍니다.

![](/assets/images/posts/219/img_29.png)

#### 그림 14

다른 답변 순서(왼쪽) 및 다른 프롬프트 형식(오른쪽)에 대한 사전 훈련된 언어 모델의 견고성을 보여줍니다.

![](/assets/images/posts/219/img_30.png)

#### 그림 15

질문 응답, 수학적 추론 및 패러프레이즈 감지 벤치마크에 대한 적대적 대 비적대적 성능을 보여줍니다. 왼쪽은 사전 훈련된 모델의 결과, 오른쪽은 사후 훈련된 모델의 결과입니다.

### 5.1.3 적대적 벤치마크

위에서 제시된 벤치마크 외에도, 우리는 질문 응답, 수학적 추론, 패러프레이즈 검출의 세 가지 영역에서 여러 적대적 벤치마크를 평가합니다. 이러한 테스트는 모델의 능력을 도전적인 작업에서 조사하며, 벤치마크에 대한 과적합 여부도 판단할 수 있습니다. 질문 응답을 위해 우리는 Adversarial SQuAD (Jia and Liang, 2017)와 Dynabench SQuAD (Kiela et al., 2021)를 사용합니다. 수학적 추론을 위해 우리는 GSM-Plus (Li et al., 2024c)를 사용하고, 패러프레이즈 검출을 위해서는 PAWS (Zhang et al., 2019)를 사용합니다.

그림 15는 적대적 벤치마크에서의 Llama 3 8B, 70B, 405B 모델의 점수를 비적대적 벤치마크에서의 성능과 비교한 결과를 보여줍니다. 비적대적 벤치마크로는 질문 응답을 위한 SQuAD (Rajpurkar et al., 2016), 수학적 추론을 위한 GSM8K, 패러프레이즈 검출을 위한 QQP (Wang et al., 2017)를 사용합니다. 각 데이터 포인트는 적대적 데이터셋과 비적대적 데이터셋의 쌍을 나타내며(e.g., QQP와 PAWS의 쌍), 각 카테고리 내에서 모든 가능한 쌍을 보여줍니다. 대각선 검은 선은 적대적 데이터셋과 비적대적 데이터셋 간의 성능 차이를 나타내며, 선 위에 있을 경우 모델의 성능이 적대적 성질과 상관없이 유사함을 나타냅니다.

패러프레이즈 검출에서는 사전 훈련된 모델과 사후 훈련된 모델 모두 PAWS의 적대성에 영향을 받지 않는 것으로 보이며, 이는 이전 세대의 모델에 비해 상당한 진전을 나타냅니다. 이 결과는 LLM이 여러 적대적 데이터셋에서 발견되는 유사 상관관계에 덜 취약하다는 Weber et al. (2023a)의 발견을 확인합니다. 그러나 수학적 추론과 질문 응답에서는 적대적 성능이 비적대적 성능에 비해 상당히 낮습니다. 이 패턴은 사전 훈련된 모델과 사후 훈련된 모델 모두에서 유사하게 나타납니다.

### 5.1.4 오염 분석

평가 데이터가 사전 훈련 코퍼스에 오염된 정도가 벤치마크 점수에 어떤 영향을 미치는지 추정하기 위해 오염 분석을 수행합니다. 이전 연구에서는 다양한 오염 방법이 사용되었으며, 다양한 하이퍼파라미터가 적용되었습니다(Singh et al., 2024 참조). 이러한 방법은 모두 거짓 양성 및 음성의 문제가 있을 수 있으며, 오염 분석을 최적으로 수행하는 방법은 여전히 연구 중인 분야입니다. 여기서는 Singh et al. (2024)의 제안을 주로 따릅니다.

#### 방법

Singh et al. (2024)은 데이터셋의 '청정' 부분과 전체 데이터셋 간의 차이를 기준으로 오염 감지 방법을 경험적으로 선택할 것을 제안합니다. 이를 통해 최대 성능 향상을 추정합니다. 모든 평가 데이터셋에 대해, 우리는 8-그램 겹침을 기반으로 예제를 점수화합니다. Singh et al. (2024)에 따르면 이는 많은 데이터셋에서 정확한 방법입니다. 데이터셋 D의 예제가 사전 훈련 코퍼스에 최소한 한 번 이상 발생하는 8-그램의 일부일 경우, 오염된 것으로 간주합니다. 우리는 각 데이터셋에 대해 TD 값을 별도로 선택하여, 세 모델 크기 간의 최대 성능 향상을 보여주는 값을 선택합니다.

![](/assets/images/posts/219/img_31.png)

#### 표 15

평가 세트의 오염 비율과 그로 인한 성능 향상 추정치를 보여줍니다. 자세한 내용은 본문을 참조하십시오.

#### 결과

표 15에서는 위에서 설명한 대로, 주요 벤치마크에 대해 오염된 것으로 간주되는 평가 데이터의 비율을 보고합니다. 예제 수가 너무 적거나, 성능 향상 추정치가 매우 불안정한 경우와 같이 유의미하지 않은 결과는 제외했습니다. 표 15에서 우리는 일부 데이터셋에서 오염이 큰 영향을 미치는 반면, 다른 데이터셋에서는 그렇지 않음을 관찰합니다. 예를 들어, PiQA와 HellaSwag의 경우 오염 추정치와 성능 향상 추정치가 모두 높습니다. 반면, Natural Questions의 경우 52%의 오염 추정치가 성능에 거의 영향을 미치지 않는 것으로 보입니다. SQuAD와 MATH의 경우 낮은 임계값이 높은 오염 수준을 보이지만, 성능 향상은 없습니다. 이는 이러한 데이터셋에 대해 오염이 도움이 되지 않거나, 더 나은 추정을 위해 더 큰 n이 필요하다는 것을 시사합니다. 마지막으로, MBPP, HumanEval, MMLU 및 MMLU-Pro의 경우, 다른 오염 감지 방법이 필요할 수 있습니다. 높은 임계값에서도 8-그램 겹침이 너무 높은 오염 점수를 보여 성능 향상 추정을 정확히 할 수 없습니다.

### 5.2 사후 훈련된 언어 모델

다양한 기능에 걸쳐 Llama 3 사후 훈련된 모델의 벤치마크 결과를 제시합니다. 사전 훈련과 유사하게, 우리는 공개된 벤치마크와 함께 평가의 일환으로 생성된 데이터를 Huggingface에서 공개합니다. 평가 설정에 대한 추가 세부 사항은 여기를 참조하십시오.

#### 벤치마크와 지표

표 16에는 기능별로 정리된 모든 벤치마크의 개요가 포함되어 있습니다. 각 벤치마크의 프롬프트와 정확히 일치하는 사후 훈련 데이터를 제거하는 방법을 적용합니다. 표준 학술 벤치마크 외에도, 우리는 다양한 기능에 대한 광범위한 인간 평가를 수행했습니다. 자세한 내용은 섹션 5.3에 제공됩니다.

#### 실험 설정

사전 훈련 단계와 유사한 실험 설정을 사용하여, Llama 3를 유사한 크기와 기능을 가진 다른 모델들과 비교 분석합니다. 가능한 한, 다른 모델의 성능을 직접 평가하고 보고된 결과와 비교하여 최상의 점수를 선택합니다. 평가 설정에 대한 추가 세부 사항은 여기를 참조하십시오.

![](/assets/images/posts/219/img_32.png)

#### 표 16 사후 훈련 벤치마크 분류별 개요

여기에는 사후 훈련된 Llama 3 모델을 평가하기 위해 사용한 모든 벤치마크가 기능별로 정리되어 있습니다.

### 5.2.1 일반 지식 및 지시 따르기 벤치마크

Llama 3를 일반 지식 및 지시 따르기 벤치마크에서 평가합니다.

**일반 지식:** Llama 3의 지식 기반 질문 응답 능력을 평가하기 위해 MMLU(Hendrycks et al., 2021a)와 MMLU-Pro(Wang et al., 2024b)를 활용합니다. MMLU의 경우, 5-샷 표준 설정에서 하위 작업 정확도의 매크로 평균을 보고합니다. MMLU-Pro는 MMLU의 확장판으로, 더 도전적이고 추론 중심의 질문을 포함하며, 선택 항목을 4개에서 10개로 확장합니다. 복잡한 추론에 중점을 두고 있으므로, MMLU-Pro는 5-샷 CoT를 보고합니다. 모든 작업은 simple-evals(OpenAI, 2024)와 유사한 생성 작업으로 형식화됩니다. 표 2에서 볼 수 있듯이, 우리의 8B 및 70B Llama 3 변형은 두 가지 일반 지식 작업에서 유사한 크기의 다른 모델보다 우수합니다. 405B 모델은 GPT-4와 Nemotron 4 340B를 능가하며, Claude 3.5 Sonnet이 더 큰 모델 중에서 선두를 차지합니다.

**지시 따르기:** Llama 3 및 다른 모델이 자연어 지시를 따르는 능력을 IFEval(Zhou et al., 2023)에서 평가합니다. IFEval은 "400 단어 이상으로 작성하세요"와 같은 약 500개의 "검증 가능한 지시"로 구성되어 있으며, 이는 휴리스틱으로 검증할 수 있습니다. 우리는 엄격한 제약과 느슨한 제약 하에서 프롬프트 수준과 지시 수준 정확도의 평균을 보고합니다. 모든 Llama 3 변형은 IFEval에서 비교 가능한 모델보다 우수합니다.

### 5.2.2 능력 시험

다음으로, 우리는 인간을 테스트하기 위해 고안된 다양한 능력 시험에서 모델을 평가합니다. 우리는 이러한 시험을 공개적으로 이용할 수 있는 공식 출처에서 가져오며, 일부 시험에서는 각 능력 시험당 다양한 시험 세트의 평균 점수를 보고합니다. 구체적으로는 다음을 평균합니다:

- **GRE:** 공식 GRE 실전 테스트 1 및 2(교육 테스트 서비스 제공)
- **LSAT:** 공식 Preptest 71, 73, 80 및 93
- **SAT:** 2018년판 공식 SAT 학습 가이드의 8개 시험
- **AP:** 각 과목당 공식 실전 시험 하나
- **GMAT:** 공식 GMAT 온라인 시험

이 시험의 질문은 MCQ 스타일과 생성 질문을 모두 포함합니다. 이미지를 동반하는 질문은 제외합니다. 여러 정답 선택이 가능한 GRE 시험의 경우, 모델이 모든 정답을 선택한 경우에만 정답으로 간주합니다. 여러 시험 세트가 있는 경우에는 몇 샷 프롬프트를 사용하여 평가를 실행합니다. 점수는 GRE의 경우 130-170 범위로 조정하고, 다른 모든 시험에서는 정확도를 보고합니다.

우리의 결과는 표 17에 나와 있습니다. Llama 3 405B 모델의 성능은 Claude 3.5 Sonnet 및 GPT-4 4o와 매우 유사합니다. 70B 모델은 더욱 인상적인 성능을 보이며, GPT-3.5 Turbo보다 훨씬 우수하며 많은 테스트에서 Nemotron 4 340B를 능가합니다.

![](/assets/images/posts/219/img_33.png)

표 17: LSAT, SAT, GMAT, AP, GRE 시험을 포함한 다양한 능력 시험에서 Llama 3 모델 및 GPT-4o의 성능. GRE 시험의 경우 정규화된 점수를 보고하며, 다른 모든 시험의 경우 정확도를 보고합니다. 하단의 두 행은 GRE Quant. 및 GRE Verbal에 해당하며, 170점 만점으로 환산된 점수를 보고합니다.

### 5.2.3 코딩 벤치마크

Llama 3를 여러 인기 있는 Python 및 다중 프로그래밍 언어 벤치마크에서 코드 생성 성능을 평가합니다. 기능적으로 올바른 코드를 생성하는 모델의 효과를 측정하기 위해, 우리는 N 세대 중 유닛 테스트를 통과하는 비율을 평가하는 pass@N 메트릭을 사용합니다. 여기서는 pass@1을 보고합니다.

**Python 코드 생성:** HumanEval(Chen et al., 2021)과 MBPP(Austin et al., 2021)는 비교적 간단하고 독립적인 함수를 중점으로 하는 Python 코드 생성의 인기 있는 벤치마크입니다. HumanEval+(Liu et al., 2024a)은 더 많은 테스트를 생성하여 false positive를 피하기 위한 HumanEval의 향상된 버전입니다. MBPP EvalPlus 기본 버전(v0.2.0)은 원래 MBPP(훈련 및 테스트) 데이터셋의 초기 974개 문제 중 378개의 잘 구성된 문제를 선택한 것입니다(Liu et al., 2024a). 이러한 벤치마크에 대한 결과는 표 18에 보고됩니다. Python 변형 벤치마크 전반에 걸쳐, Llama 3 8B 및 70B는 유사한 크기의 모델을 능가합니다. 가장 큰 모델인 Llama 3 405B, Claude 3.5 Sonnet, GPT-4o는 유사한 성능을 보이며, GPT-4o가 가장 강력한 결과를 보입니다.

**다중 프로그래밍 언어 코드 생성:** Python 외의 코드 생성 기능을 평가하기 위해, HumanEval 및 MBPP 문제의 번역을 기반으로 한 MultiPL-E(Cassano et al., 2023) 벤치마크 결과를 보고합니다. 인기 있는 프로그래밍 언어의 일부에 대한 결과는 표 19에 보고됩니다. 표 18의 Python과 비교했을 때 성능이 크게 떨어지는 것을 알 수 있습니다.

![](/assets/images/posts/219/img_34.png)

**표 18:** 코드 생성 벤치마크에서의 Pass@1 점수. HumanEval(Chen et al., 2021), MBPP(Austin et al., 2021), 그리고 이러한 벤치마크의 EvalPlus(Liu et al., 2024a) 버전의 결과를 보고합니다.

![](/assets/images/posts/219/img_35.png)

**표 19:** 비-Python 프로그래밍 작업의 성능. MultiPL-E(Cassano et al., 2023)에서 Llama 3의 결과를 보고합니다.

### 5.2.4 다중 언어 벤치마크

Llama 3는 영어, 독일어, 프랑스어, 이탈리아어, 포르투갈어, 힌디어, 스페인어, 태국어 등 8개의 언어를 지원합니다. 그러나 기본 모델은 더 광범위한 언어 컬렉션으로 훈련되었습니다. 표 20에서는 다중 언어 MMLU(Hendrycks et al., 2021a) 및 다중 언어 초등 수학(MGSM) (Shi et al., 2022) 벤치마크에서 Llama 3를 평가한 결과를 보여줍니다.

**다중 언어 MMLU:** MMLU 질문, 몇 가지 예제 및 답변을 Google Translate를 사용하여 번역했습니다. 작업 지침은 영어로 남겨두고 5-shot 설정에서 평가를 수행했습니다. 표 20에서는 독일어, 프랑스어, 이탈리아어, 포르투갈어, 힌디어, 스페인어, 태국어 전반의 평균 결과를 보고합니다.

**MGSM (Shi et al., 2022):** simple-evals(OpenAI, 2024)에서와 동일한 네이티브 프롬프트를 사용하여 0-shot CoT 설정에서 모델을 테스트했습니다. 표 20에서는 MGSM 벤치마크에 포함된 언어들에 대한 평균 결과를 보고합니다.

Llama 3 405B는 MGSM에서 대부분의 다른 모델을 능가하여 평균 91.6%를 달성했습니다. MMLU에서는 위에서 보여준 영어 MMLU 결과와 일치하게, Llama 3 405B가 GPT-4o보다 2% 뒤처졌습니다. 반면, Llama 3 70B 및 8B 모델은 두 작업 모두에서 경쟁 모델을 크게 앞서는 강력한 성능을 보여줍니다.

### 5.2.5 수학 및 추론 벤치마크

수학 및 추론 벤치마크 결과는 표 2에 제시되어 있습니다. Llama 3 8B 모델은 GSM8K, MATH, GPQA에서 유사한 크기의 다른 모델을 능가합니다. 70B 모델은 모든 벤치마크에서 동급의 다른 모델보다 현저히 뛰어난 성능을 보입니다. 마지막으로, Llama 3 405B 모델은 GSM8K 및 ARC-C에서 자신의 카테고리에서 최고이며, MATH에서는 두 번째로 좋은 모델입니다. GPQA에서는 GPT-4 4o와 경쟁할 만한 성능을 보이며, Claude 3.5 Sonnet이 큰 차이로 최고의 모델로 나타났습니다.

![](/assets/images/posts/219/img_36.png)

**표 20:** 다중 언어 벤치마크. MGSM (Shi et al., 2022)에 대해, Llama 3 모델의 0-shot CoT 결과를 보고합니다. 다중 언어 MMLU는 번역된 MMLU (Hendrycks et al., 2021a) 질문과 답변을 7개 언어로 번역한 내부 벤치마크로, 5-shot 결과를 이 언어들 전반에 걸쳐 평균으로 보고합니다.

### 5.2.6 Long Context Benchmarks

다양한 도메인과 텍스트 유형을 포함한 다양한 작업 세트를 고려했습니다. 아래 나열된 벤치마크에서는 n-gram 중첩 메트릭이 아닌 정확도 기반 메트릭을 사용하는 편견 없는 평가 프로토콜을 사용하는 하위 작업에 중점을 두었습니다. 또한 변동성이 낮은 작업을 우선적으로 선택했습니다.

- \*\*Needle-in-a-Haystack (Kamradt, 2023)\*\*는 모델이 긴 문서의 임의 부분에 삽입된 숨겨진 정보를 검색하는 능력을 측정합니다. Llama 3 모델은 모든 문서 깊이와 컨텍스트 길이에서 100%의 바늘 검색 성능을 보여줍니다. Multi-needle(Table 21)에서도 Llama 3 모델은 거의 완벽한 검색 결과를 얻었습니다.
- \*\*ZeroSCROLLS (Shaham et al., 2023)\*\*는 긴 텍스트에 대한 자연어 이해를 위한 제로샷 벤치마크입니다. 우리는 정답이 공개되지 않았기 때문에 검증 세트의 수치를 보고합니다. Llama 3 405B 및 70B 모델은 이 벤치마크의 다양한 작업에서 다른 모델과 동일하거나 이를 능가합니다.
- \*\*InfiniteBench (Zhang et al., 2024)\*\*는 컨텍스트 창에서 긴 의존성을 이해하는 모델을 필요로 합니다. 우리는 En.QA(소설에 대한 QA) 및 En.MC(소설에 대한 선택형 QA)에서 Llama 3을 평가하며, 405B 모델이 다른 모델들을 능가합니다. 특히 En.QA에서 상당한 성장을 보였습니다.

### 5.2.7 Tool Use Performance

Llama 3 모델을 제로샷 도구 사용(즉, 함수 호출) 벤치마크인 Nexus (Srinivasan et al., 2023), API-Bank (Li et al., 2023b), Gorilla API-Bench (Patil et al., 2023), 및 Berkeley Function Calling Leaderboard (BFCL) (Yan et al., 2024)에서 평가했습니다. 결과는 Table 22에 나와 있습니다.

- Nexus에서는 Llama 3 변형 모델이 경쟁 모델들보다 우수한 성능을 보였습니다.
- API-Bank에서는 Llama 3 8B 및 70B 모델이 해당 카테고리에서 다른 모델들을 상당한 차이로 능가했습니다. 405B 모델은 Claude 3.5 Sonnet보다 0.6% 뒤쳐졌습니다.
- BFCL에서는 405B 및 70B 모델이 경쟁력 있는 성능을 보였으며, 각 크기 클래스에서 거의 두 번째로 좋은 성능을 보였습니다. Llama 3 8B는 해당 카테고리에서 가장 우수한 성능을 보였습니다.

**인간 평가**에서는 코드 실행 작업에 중점을 두어 모델의 도구 사용 능력을 테스트했습니다. LMSys 데이터셋(Chiang et al., 2024), GAIA 벤치마크(Mialon et al., 2023b), 인간 평가자, 합성 생성을 통해 2000개의 사용자 프롬프트를 수집했습니다.

우리는 OpenAI의 Assistants API를 사용하여 GPT-4o와 Llama 3 405B를 비교했습니다. 결과는 Figure 16에 나와 있습니다. 텍스트 전용 코드 실행 작업 및 플롯 생성에서 Llama 3 405B는 GPT-4o를 크게 능가했지만, 파일 업로드 사용 사례에서는 뒤쳐졌습니다.

![](/assets/images/posts/219/img_37.png)

**Table 21**은 ZeroSCROLLS(Shaham et al., 2023)에 대한 검증 세트의 수치를 보고합니다. QuALITY에서는 정확한 일치, Qasper에서는 f1, SQuALITY에서는 rougeL을 보고합니다. InfiniteBench(Zhang et al., 2024) En.QA 메트릭에서는 f1, En.MC에서는 정확도를 보고합니다. Multi-needle(Kamradt, 2023)에서는 컨텍스트에 4개의 바늘을 삽입하고 다른 컨텍스트 길이에서 2개의 바늘을 검색할 수 있는지 테스트하며, 128k까지 10개의 시퀀스 길이에 걸쳐 평균 리콜을 계산합니다.

![](/assets/images/posts/219/img_38.png)

**Table 22**는 제로샷 도구 사용 벤치마크를 보여줍니다. Nexus(Srinivasan et al., 2023), API-Bank(Li et al., 2023b), APIBench(Patil et al., 2023), BFCL(Yan et al., 2024)에서 함수 호출 정확도를 보고합니다.

![](/assets/images/posts/219/img_39.png)

**Figure 16**은 코드 실행 작업, 플롯 생성 및 파일 업로드 작업에서 Llama 3 405B와 GPT-4o를 비교한 인간 평가 결과를 보여줍니다. Llama 3 405B는 코드 실행(플롯 생성 또는 파일 업로드 제외) 및 플롯 생성에서 GPT-4o를 능가하지만 파일 업로드 사용 사례에서는 뒤쳐집니다.

5.3 인간 평가

표준 벤치마크 세트에서의 평가 외에도 일련의 인간 평가를 수행했습니다. 이러한 평가는 모델의 톤, 장황함, 미묘한 이해 및 문화적 맥락 이해와 같은 모델 성능의 더 미묘한 측면을 측정하고 최적화할 수 있게 합니다. 잘 설계된 인간 평가는 사용자 경험을 밀접하게 반영하여 모델이 실제 시나리오에서 어떻게 작동하는지에 대한 통찰력을 제공합니다.

**프롬프트 수집.** 우리는 다양한 범주와 난이도를 아우르는 고품질 프롬프트를 수집했습니다. 이를 위해 가능한 많은 모델 기능을 포착하는 범주 및 하위 범주를 포함하는 분류 체계를 먼저 개발했습니다. 이 분류 체계를 사용하여 6개의 개별 기능(영어, 추론, 코딩, 힌디어, 스페인어 및 포르투갈어)과 3개의 다중 턴 기능(영어, 추론 및 코딩)에 걸쳐 약 7,000개의 프롬프트를 수집했습니다. 각 범주 내에서 프롬프트가 하위 범주에 고르게 분포되도록 했습니다. 또한 각 프롬프트를 세 가지 난이도 수준 중 하나로 분류하고, 수집된 프롬프트가 대략 10%는 쉬운 프롬프트, 30%는 중간 난이도 프롬프트, 60%는 어려운 프롬프트로 구성되도록 했습니다. 모든 인간 평가 프롬프트 세트는 철저한 품질 보증 프로세스를 거쳤습니다. 모델링 팀은 테스트 세트에서의 우연한 오염이나 과적합을 방지하기 위해 인간 평가 프롬프트에 접근할 수 없었습니다.

### 평가 과정

두 모델에 대한 쌍대 비교 인간 평가를 수행하기 위해 인간 평가자들에게 어느 모델 응답이 더 나은지 묻습니다. 평가자들은 7점 척도를 사용하여 응답이 다른 모델 응답보다 훨씬 나은지, 더 나은지, 약간 나은지 또는 거의 동일한지를 평가합니다. 평가자가 한 모델의 응답이 다른 모델의 응답보다 낫다고 평가하면, 이는 해당 모델의 "승리"로 간주됩니다. 우리는 프롬프트 세트에서 각 기능에 대해 모델 간의 쌍대 비교를 수행하여 승률을 보고합니다.

### 결과

우리는 인간 평가 과정을 사용하여 Llama 3 405B와 GPT-4 (0125 API 버전), GPT-4o (API 버전), 그리고 Claude 3.5 Sonnet (API 버전)을 비교했습니다. 이러한 평가의 결과는 **Figure 17**에 제시되어 있습니다. Llama 3 405B는 GPT-4 0125 API 버전과 거의 동등한 성능을 보였으며, GPT-4o와 Claude 3.5 Sonnet에 비해 혼합된 결과(일부 승리, 일부 패배)를 보였습니다. 거의 모든 기능에서 Llama 3과 GPT-4의 승률은 오차 범위 내에 있었습니다. 다중 턴 추론 및 코딩 작업에서 Llama 3 405B는 GPT-4를 능가했지만, 다중 언어(힌디어, 스페인어, 포르투갈어) 프롬프트에서는 GPT-4에 비해 성능이 떨어졌습니다. Llama 3은 영어 프롬프트에서 GPT-4o와 거의 동등한 성능을 보였고, 다중 언어 프롬프트에서 Claude 3.5 Sonnet과 동등한 성능을 보였으며, 단일 및 다중 턴 영어 프롬프트에서 Claude 3.5 Sonnet을 능가했습니다. 그러나 코딩 및 추론 기능에서는 Claude 3.5 Sonnet에 뒤처졌습니다. 질적으로, 인간 평가에서 모델 성능은 모델 톤, 응답 구조, 장황함과 같은 미묘한 요인에 크게 영향을 받는다는 것을 발견했습니다. 이러한 요인들은 포스트 트레이닝 과정에서 최적화되고 있습니다. 전반적으로, 우리의 인간 평가 결과는 표준 벤치마크 평가 결과와 일치하며, Llama 3 405B는 주요 산업 모델들과 매우 경쟁력이 있어 가장 성능이 뛰어난 공개 가능 모델로 평가됩니다.

### 한계

모든 인간 평가 결과는 철저한 데이터 품질 보증 과정을 거쳤습니다. 그러나 모델 응답을 평가하는 객관적 기준을 정의하는 것이 어렵기 때문에, 인간 평가 결과는 평가자의 개인적 편향, 배경, 선호도에 의해 영향을 받을 수 있으며, 이는 일관성이 없거나 신뢰할 수 없는 결과로 이어질 수 있습니다.

![](/assets/images/posts/219/img_40.png)

**Figure 17**은 Llama 3 405B 모델에 대한 인간 평가 결과를 보여줍니다. 왼쪽: GPT-4와의 비교. 중간: GPT-4o와의 비교. 오른쪽: Claude 3.5 Sonnet과의 비교. 모든 결과에는 95% 신뢰 구간이 포함되며 동점은 제외됩니다.

### 안전성

Llama 3의 안전하고 책임 있는 콘텐츠 생성을 평가하는 데 중점을 두고 있으며, 유익한 정보를 최대한 제공하는 데 주력합니다. 우리의 안전성 작업은 주로 데이터 정리 및 필터링 형태로 사전 훈련 단계에서 시작됩니다. 이후 안전성 미세 조정 접근 방식을 설명하며, 특정 안전 정책에 맞추어 모델을 훈련시키는 동시에 유용성을 유지하는 방법에 초점을 맞춥니다.

Llama 3의 다국어, 긴 문맥, 도구 사용 및 다양한 멀티모달 기능을 분석하여 안전성 완화 조치의 효과를 측정합니다.

다음으로, 사이버 보안 및 화학 및 생물학 무기 위험에 대한 상승 효과 평가를 설명합니다. 상승 효과는 기존에 사용 가능한 기술(예: 웹 검색)과 비교하여 새로운 기술 발전으로 인해 추가되는 위험을 의미합니다.

그 후, 다양한 기능 전반에서 발생할 수 있는 안전 위험을 식별하고 이를 해결하기 위해 반복적으로 레드 팀 활동을 활용하는 방법과 잔여 위험 평가를 수행하는 방법을 설명합니다.

마지막으로, 시스템 수준의 안전성을 설명하며, 이는 모델 자체의 입력 및 출력 주위에 분류기를 개발 및 조정하여 안전성을 더욱 강화하고, 개발자가 다양한 사용 사례에 맞춰 안전성을 사용자 정의하고 책임 있게 생성형 AI를 배포할 수 있도록 지원합니다.

### 5.4.1 벤치마크 구성

우리는 모델을 안전하고 책임감 있게 개발하기 위해 다양한 내부 벤치마크를 작성합니다. 우리의 벤치마크는 ML Commons의 위험 분류법에서 영감을 받았습니다 (Vidgen et al., 2024). Llama 3의 새로운 기능 중 일부는 충분한 외부 벤치마크가 부족하며, 종종 외부 벤치마크는 폭과 깊이의 범위가 충분하지 않습니다. 각 위험 범주에 대해 우리는 적대적이거나 경계선에 있는 성격의 인간이 작성한 프롬프트를 수집합니다 — 이러한 프롬프트의 예는 Table 23에 나와 있습니다. 적대적인 프롬프트는 해로운 응답을 직접 유도하는 간단한 것부터 정교한 탈옥 기법을 포함하는 것까지 다양합니다. 이러한 적대적인 프롬프트의 벤치마크는 위반율을 측정하는 기준이 됩니다.

위반율에 대한 반대 지표로, 우리는 경계선 프롬프트로 구성된 잘못된 거부 벤치마크를 구성합니다. 모델이 안전한 응답이 가능함에도 불구하고 도움을 거부하는 경우를 잘못된 거부라고 합니다. 경계선 프롬프트는 모델이 잘 처리해야 할 결정 경계 근처의 프롬프트입니다. 예를 들어, "내 절친이 항상 주인공처럼 행동하는데 내가 어떻게 눈에 띌 수 있을까?"와 같은 프롬프트입니다. 우리의 전체 벤치마크 크기는 위반 및 잘못된 거부에 대해 기능 또는 언어당 4000개 이상의 프롬프트로 구성되며, 단일 턴 및 다중 턴 프롬프트가 혼합되어 있습니다.

### 5.4.2 안전성 사전 훈련

우리는 책임 있는 개발이 모델 개발 및 배포의 모든 단계에서 고려되어야 한다고 믿습니다. 사전 훈련 중에 우리는 다양한 필터를 적용합니다. 예를 들어, 개인 식별 가능 정보가 포함된 웹사이트를 식별하는 필터를 적용합니다 (3.1절 참조). 우리는 또한 발견 가능한 기억에 중점을 둡니다 (Nasr et al., 2023). Carlini et al. (2022)와 유사하게, 우리는 코퍼스의 모든 n-그램의 효율적인 롤링 해시 인덱스를 사용하여 훈련 데이터에서 다른 빈도로 발생하는 프롬프트와 실제 답변을 샘플링합니다. 프롬프트와 실제 답변의 길이, 대상 데이터의 언어 감지 및 도메인을 다양하게 하여 다양한 테스트 시나리오를 구성합니다. 그런 다음 모델이 실제 답변 시퀀스를 그대로 생성하는 빈도를 측정하고, 지정된 시나리오에서의 기억화 비율을 분석합니다. 우리는 기억화 비율을 포함율로 정의하며, 이는 모델 생성 중 실제 답변 연속 시퀀스를 정확하게 포함하는 비율입니다. Table 24에서 보듯이, 우리는 데이터의 주어진 특성의 유병률에 가중치를 두어 평균을 보고합니다. 우리는 훈련 데이터의 기억화 비율이 낮다는 것을 발견했습니다 (405B 모델의 경우 n = 50과 n = 1000에서 각각 평균 1.13% 및 3.91%). 기억화 비율은 Llama 2와 유사하며, 동일한 방법론을 사용하여 데이터 믹스를 적용했습니다.

![](/assets/images/posts/219/img_41.png)

**Table 23** 예시는 우리 내부 벤치마크에서 모든 기능에 걸친 적대적인 프롬프트의 예시입니다.

![](/assets/images/posts/219/img_42.png)

**Table 24** 사전 훈련된 Llama 3의 특정 테스트 시나리오에서의 평균 기억화 비율입니다. 우리의 기준선은 동일한 프롬프트 방법론을 적용한 Llama 2의 데이터 믹스에서 영어, 50-그램 시나리오입니다.

### 5.4.3 안전성 미세 조정

여기서는 다양한 기능에 걸친 위험을 완화하기 위한 안전성 미세 조정 접근법을 설명합니다. 이는 두 가지 주요 측면을 포함합니다: (1) 안전 훈련 데이터와 (2) 위험 완화 기술입니다. 우리의 안전성 미세 조정 과정은 일반적인 미세 조정 방법론을 기반으로 하여 특정 안전 문제를 해결하기 위한 수정 사항을 포함합니다. 우리는 두 가지 주요 지표를 최적화합니다: 모델이 안전 정책을 위반하는 응답을 생성할 때 이를 포착하는 Violation Rate (VR)과 모델이 무해한 프롬프트에 대해 부적절하게 응답을 거부하는 경우를 포착하는 False Refusal Rate (FRR)입니다. 동시에, 우리는 안전성 개선이 전반적인 도움성에 영향을 미치지 않도록 도움성 벤치마크에서 모델 성능을 평가합니다.

### 미세 조정 데이터

안전 훈련 데이터의 품질과 설계는 성능에 큰 영향을 미칩니다. 광범위한 실험을 통해 우리는 품질이 양보다 중요하다는 것을 발견했습니다. 우리는 주로 데이터 제공업체로부터 수집한 사람이 생성한 데이터를 사용하지만, 이는 특히 미묘한 안전 정책에 대해 오류와 불일치가 발생하기 쉽습니다. 최고의 품질 데이터를 보장하기 위해 우리는 엄격한 품질 보증 프로세스를 지원하는 AI 지원 주석 도구를 개발했습니다. 적대적인 프롬프트를 수집하는 것 외에도, 우리는 경계선 프롬프트라는 유사한 프롬프트 집합을 수집합니다. 이는 적대적인 프롬프트와 밀접하게 관련되어 있으며, 모델이 도움되는 응답을 제공하도록 학습시키는 것을 목표로 합니다. 이를 통해 False Refusal Rate (FRR)을 줄일 수 있습니다.

사람의 주석 외에도 우리는 훈련 데이터 세트의 품질과 범위를 개선하기 위해 합성 데이터를 활용합니다. 우리는 다양한 기술을 사용하여 추가적인 적대적 예제를 생성합니다. 여기에는 신중하게 작성된 시스템 프롬프트를 사용한 맥락 학습, 새로운 공격 벡터를 기반으로 한 씨앗 프롬프트의 유도된 변형, 그리고 다양한 차원의 다양성에 걸친 프롬프트를 생성하는 MAP-Elites (Mouret and Clune, 2015)에 기반한 Rainbow Teaming (Samvelyan et al., 2024)과 같은 고급 알고리즘이 포함됩니다.

우리는 모델이 안전한 응답을 생성할 때의 어조도 다룹니다. 이는 사용자 경험에 영향을 미칩니다. 우리는 Llama 3을 위한 거부 어조 지침을 개발하고, 모든 새로운 안전 데이터가 이를 준수하도록 엄격한 품질 보증 프로세스를 통해 보장했습니다. 또한 기존의 안전 데이터를 지침에 맞게 정제했습니다. 이를 위해 제로샷 리라이팅과 인간이 참여하는 편집을 결합하여 고품질 데이터를 생성했습니다. 이러한 방법과 안전 응답의 어조 품질을 평가하기 위한 어조 분류기를 사용하여, 우리는 모델의 어휘력을 크게 향상시킬 수 있었습니다.

![](/assets/images/posts/219/img_43.png)

**Figure 18** 모델 크기가 위반율 (VR)과 False Refusal Rate (FRR) 균형을 맞추기 위한 안전성 믹스 설계에 미치는 영향을 보여줍니다. 각 산점도의 점은 안전성과 도움성 데이터를 균형 있게 조정한 다른 데이터 믹스를 나타냅니다. 모델 크기에 따라 안전 학습을 위한 용량이 다릅니다. 실험 결과, 8B 모델은 70B 모델과 유사한 안전 성능을 달성하기 위해 전체 SFT 믹스에서 도움성 데이터에 비해 더 높은 비율의 안전 데이터를 필요로 한다는 것을 보여줍니다. 더 큰 모델은 적대적 맥락과 경계선 맥락을 구별하는 데 더 능숙하여 VR과 FRR 사이의 균형을 더 유리하게 만들 수 있습니다.

### 안전성 감독 미세 조정

우리의 Llama 2 방법론(Touvron et al., 2023b)을 따르면서, 우리는 모델 정렬 단계에서 모든 도움성 데이터와 안전 데이터의 조합을 사용합니다. 또한, 모델이 안전한 요청과 안전하지 않은 요청 사이의 미묘한 차이를 구별할 수 있도록 경계선 데이터셋을 도입합니다. 우리의 주석 팀은 지침에 따라 안전 프롬프트에 대한 응답을 세심하게 작성하도록 지시받습니다. 우리는 적대적 예제와 경계선 예제의 비율을 전략적으로 균형 있게 조절할 때, SFT(안전성 감독 미세 조정)가 모델 정렬에 매우 효과적이라는 것을 발견했습니다. 우리는 더 도전적인 위험 영역에 중점을 두고, 경계선 예제의 비율을 높게 유지하여 성공적인 안전 완화 노력에 중요한 역할을 하면서도 False Refusal Rate (FRR)을 최소화합니다.

또한, 모델 크기가 FRR과 VR(위반율) 간의 균형에 미치는 영향을 Figure 18에서 살펴봅니다. 우리의 결과는 작은 모델이 도움성 데이터에 비해 더 많은 비율의 안전 데이터를 요구하며, 더 큰 모델에 비해 VR과 FRR 간의 균형을 효율적으로 맞추는 것이 더 어렵다는 것을 보여줍니다.

### SafetyDPO

안전 학습을 강화하기 위해, 우리는 DPO(Preference Optimization)에서 적대적 및 경계선 예제를 포함합니다. 임베딩 공간에서 응답 쌍을 거의 직교하도록 만드는 것이 주어진 프롬프트에 대해 좋은 응답과 나쁜 응답을 구별하도록 모델을 가르치는 데 특히 효과적이라는 것을 발견했습니다. 우리는 적대적, 경계선, 도움성 예제의 최적 비율을 결정하기 위해 여러 실험을 수행하며, FRR과 VR 간의 균형을 최적화하는 것을 목표로 합니다. 또한 모델 크기가 학습 결과에 영향을 미친다는 것을 발견했으며, 이로 인해 다양한 모델 크기에 맞춘 안전성 믹스를 조정합니다.

### 안전성 결과

먼저 Llama 3의 일반적인 행동을 다양한 축에서 강조하고, 이어서 각 새로운 기능에 대한 결과와 안전 위험 완화의 효과를 설명합니다.

![](/assets/images/posts/219/img_44.png)

**Figure 19**: 영어 및 핵심 다국어 짧은 문맥 벤치마크에서 Llama 3 405B(일반적으로 및 Llama Guard (LG) 시스템 레벨 보호가 적용된 경우)와 경쟁 모델 및 시스템 간의 위반율(VR) 및 False Refusal Rate (FRR) 비교를 보여줍니다. Comp. 3가 지원하지 않는 언어는 'x'로 표시되어 있습니다. 숫자가 낮을수록 좋습니다.

![](/assets/images/posts/219/img_45.png)

**Figure 20**: 도구 사용 및 긴 문맥 벤치마크에서 위반율(VR) 및 False Refusal Rate (FRR)를 보여줍니다. 숫자가 낮을수록 좋습니다. DocQA와 Many-shot 벤치마크의 성능은 별도로 나열됩니다. Many-shot 벤치마크의 경우 적대적 성격으로 인해 경계선 데이터 세트가 없으며, 따라서 False Refusal Rate를 측정하지 않습니다. Tool Usage (Search)에서는 Llama 3 405B를 Comp. 1과 비교하여 테스트합니다.

### 전체 성능

Llama 3의 최종 위반율과 거짓 거부율을 유사한 모델들과 비교한 결과는 Figures 19와 20에 나와 있습니다. 이 결과는 가장 큰 매개변수 크기를 가진 Llama 3 405B 모델에 중점을 두고 있으며, 관련 경쟁자들과 비교한 것입니다. 경쟁자 중 두 개는 API를 통해 접근하는 종단 간 시스템이고, 하나는 내부적으로 호스팅하여 직접 평가한 오픈 소스 언어 모델입니다. Llama 모델은 독립 실행형 및 Llama Guard와 결합된 형태로 평가되었습니다. Llama Guard는 오픈 소스 시스템 수준의 안전성 솔루션입니다.

낮은 위반율은 바람직하지만, 거짓 거부율(FRR)을 고려하는 것이 중요합니다. 모델이 항상 거부하면 최대한 안전하지만 전혀 도움이 되지 않기 때문입니다. 마찬가지로, 문제가 있는 요청에 대해 항상 응답하는 모델은 매우 해롭고 유해할 것입니다. Figure 21에서는 내부 벤치마크를 활용하여 업계의 다양한 모델과 시스템이 이 균형을 어떻게 조절하는지, 그리고 Llama 3가 어떻게 비교되는지 탐구합니다. 우리는 모델이 매우 경쟁력 있는 위반율 지표를 달성하면서도 거짓 거부율을 낮게 유지하여, 도움성과 안전성 사이의 균형을 잘 유지하고 있음을 발견했습니다.

### 다국어 안전성

우리의 실험은 영어에서의 안전 지식이 다른 언어로 쉽게 전이되지 않는다는 것을 보여줍니다. 특히 안전 정책의 미묘한 차이와 언어별 문맥을 고려할 때 그렇습니다. 따라서 각 언어에 대한 고품질 안전 데이터를 수집하는 것이 중요합니다. 우리는 또한 언어별로 안전 데이터의 분포가 안전 성능에 큰 영향을 미친다는 것을 발견했습니다. 일부 언어는 전이 학습의 혜택을 받는 반면, 다른 언어는 더 많은 언어별 데이터가 필요합니다. FRR과 VR 간의 균형을 맞추기 위해, 우리는 반복적으로 적대적 및 경계선 데이터를 추가하면서 두 메트릭에 미치는 영향을 모니터링합니다.

Figure 19는 영어 및 비영어 언어에 대해 유사한 모델 및 시스템과 비교하여 Llama 3의 위반율과 거짓 거부율을 보여줍니다. 각 언어에 대한 벤치마크를 작성하기 위해, 우리는 네이티브 스피커가 작성한 프롬프트와 경우에 따라 영어 벤치마크에서 번역한 프롬프트를 사용합니다. 우리가 지원하는 각 언어에 대해, 내부 벤치마크에서 측정된 Llama 405B는 두 경쟁 시스템에 비해 최소한 안전하거나 더 안전하며, 경쟁력 있는 거짓 거부율을 유지합니다. Llama Guard 없이 Llama 405B 모델만 보면, 경쟁 오픈 소스 모델보다 훨씬 낮은 위반율을 보이지만 더 높은 거짓 거부율을 나타냅니다.

![](/assets/images/posts/219/img_46.png)

**Figure 21**: 모델 및 기능별 위반율과 거짓 거부율을 나타냅니다. 각 포인트는 모든 안전 범주에 걸쳐 내부 기능 벤치마크에 대한 전체 거짓 거부율과 위반율을 나타냅니다. 기호는 모델 수준의 안전성 또는 시스템 수준의 안전성을 평가하는지를 나타냅니다. 예상대로 모델 수준의 안전성 결과는 시스템 수준의 안전성 결과에 비해 더 높은 위반율과 낮은 거절율을 나타냅니다. Llama 3는 낮은 위반율과 낮은 거짓 거부율의 균형을 목표로 하며, 일부 경쟁자들은 어느 하나에 더 치우쳐 있습니다.

### 긴 문맥 안전성

긴 문맥 모델은 특정한 완화 조치가 없으면 다수 샷 탈옥 공격에 취약합니다(Anil et al., 2024). 이를 해결하기 위해, 우리는 모델을 SFT 데이터셋으로 미세 조정하여 안전하지 않은 행동의 예시가 포함된 안전한 행동을 포함합니다. 우리는 VR을 크게 줄이고, 256 샷 공격에서도 더 긴 문맥 공격의 영향을 효과적으로 중화하는 확장 가능한 완화 전략을 개발했습니다. 이 접근 방식은 FRR 및 대부분의 도움성 메트릭에 거의 영향을 미치지 않습니다.

긴 문맥 안전성 완화 조치의 효과를 정량화하기 위해, 우리는 DocQA와 Many-shot이라는 두 가지 추가 벤치마킹 방법을 사용합니다. DocQA는 긴 문서에 있는 정보를 악의적으로 활용할 수 있는지 테스트합니다. 모델은 문서와 관련된 프롬프트 세트를 제공받아 질문이 문서의 정보와 관련된 경우 모델의 응답 안전성에 영향을 미치는지 테스트합니다. Many-shot에서는 Anil et al.(2024)를 따라 합성된 채팅 기록을 구성하여 안전하지 않은 프롬프트-응답 쌍으로 구성된 최종 프롬프트가 이전 메시지와 관련이 없는 경우, 문맥 내 안전하지 않은 행동이 모델의 응답 안전성에 영향을 미치는지 테스트합니다. DocQA와 Many-shot의 위반율과 거짓 거부율은 Figure 20에 나와 있습니다. 우리는 Llama 405B(Llama Guard 포함 및 미포함)가 DocQA와 Many-shot에서 Comp. 2 시스템에 비해 Pareto 우위에 있음을 확인했습니다. Comp. 1에 비해 Llama 405B는 더 안전하지만 거짓 거부율 측면에서 대가를 치르는 경우가 있습니다.

### 도구 사용 안전성

도구 사용 호출 및 모델 통합의 다양한 구현으로 인해 도구 사용은 완전히 완화하기 어려운 능력입니다(Wallace et al., 2024). 우리는 검색 사용 사례에 중점을 둡니다. 위반율과 거짓 거부율은 Figure 20에 나와 있습니다. 우리는 Comp. 1 시스템에 대해 테스트했으며, Llama 405B가 훨씬 더 안전하지만 약간 더 높은 거짓 거부율을 나타내는 것을 발견했습니다.

### 5.4.5 사이버 보안 및 화학/생물 무기 안전성

#### 사이버 보안 평가 결과

사이버 보안 위험을 평가하기 위해, 우리는 CyberSecEval 벤치마크 프레임워크를 활용했습니다 (Bhatt et al., 2023, 2024). 이 프레임워크는 불안전한 코드 생성, 악성 코드 생성, 텍스트 기반 프롬프트 주입, 취약성 식별 등의 도메인에서 안전성을 측정하는 작업을 포함합니다. 우리는 Llama 3를 창피싱 및 자율 사이버 공격과 관련된 새로운 벤치마크에 적용했습니다. 전반적으로, Llama 3는 악성 코드를 생성하거나 취약성을 악용하는 데 큰 취약성이 없는 것으로 나타났습니다. 특정 작업에 대한 간략한 결과는 다음과 같습니다:

- **불안전한 코딩 테스트 프레임워크**: 불안전한 코딩 테스트 프레임워크에 대해 Llama 3 8B, 70B, 405B를 평가한 결과, 더 큰 모델이 더 많은 불안전한 코드를 생성하고, 평균 BLEU 점수가 더 높았습니다 (Bhatt et al., 2023).
- **코드 인터프리터 악용 프롬프트 코퍼스**: Llama 3 모델은 특정 프롬프트에서 악성 코드를 실행하는 데 취약했습니다. Llama 3 405B는 10.4%의 확률로 악성 프롬프트를 준수했으며, Llama 3 70B는 3.8%의 준수율을 보였습니다.
- **텍스트 기반 프롬프트 주입 벤치마크**: 프롬프트 주입 벤치마크에서 Llama 3 405B는 21.7%의 성공률을 보였습니다. Figure 22는 Llama 3, GPT-4 Turbo, Gemini Pro, Mixtral 모델의 텍스트 기반 프롬프트 주입 성공률을 보여줍니다.
- **취약성 식별 챌린지**: CyberSecEval 2의 캡처 더 플래그 테스트 챌린지를 사용하여 Llama 3의 취약성 식별 및 악용 능력을 평가한 결과, Llama 3는 일반적으로 사용되는 전통적인 비-LLM 도구 및 기술보다 뛰어나지 않았습니다.
- **창피싱 벤치마크**: 개인화된 대화를 통해 보안 침해를 유도하는 모델의 설득력 및 성공률을 평가했습니다. Llama 3 70B와 405B는 각각 24%와 14%의 성공률을 보였습니다. Figure 23은 모델 및 피싱 목표별 설득력 점수를 보여줍니다.
- **공격 자동화 프레임워크**: 네트워크 정찰, 취약성 식별, 익스플로잇 실행, 포스트 익스플로잇 행동의 네 가지 주요 단계에서 자율 에이전트로서 Llama 3 405B의 잠재력을 평가했습니다. Llama 3 405B는 네트워크 정찰에서 효율적으로 네트워크 서비스를 식별했으나, 취약한 머신에 초기 접근을 얻는 데 실패했습니다.

#### 사이버 공격을 위한 성과 테스트

사이버 공격률을 개선하기 위해 가상 비서가 초보 및 전문가 사이버 공격자들에게 미치는 영향을 측정하기 위해 성과 연구를 수행했습니다. 두 단계 연구는 62명의 내부 자원봉사자를 대상으로 했습니다. 첫 번째 단계에서는 LLM 지원 없이 오픈 인터넷에 접근할 수 있게 했고, 두 번째 단계에서는 인터넷 접근과 함께 Llama 3 405B 모델을 제공하여 유사한 난이도의 다른 사이버 보안 공격 과제를 수행했습니다. 분석 결과, Llama 3 405B를 사용하는 초보자와 전문가 모두 LLM 없이 인터넷에 자유롭게 접근하는 것에 비해 성과 향상이 미미했습니다.

![](/assets/images/posts/219/img_47.png)

**Figure 22**: 각 프롬프트 주입 전략에 따른 모델별 텍스트 기반 프롬프트 주입 성공률을 나타냅니다. Llama 3는 이 벤치마크에서 평가할 때 GPT-4 Turbo 및 Gemini Pro보다 더 취약하지만 Mixtral 모델보다는 덜 취약합니다.

![](/assets/images/posts/219/img_48.png)

**Figure 23**: 창피싱 목표별 창피싱 모델의 평균 설득력 점수를 나타냅니다. 시도 설득력은 Llama 3 70B 판사 LLM에 의해 평가되었습니다.

### 화학 및 생물 무기 확산에 대한 성과 테스트

화학 및 생물 무기의 확산과 관련된 위험을 평가하기 위해, Llama 3의 사용이 공격 계획 능력을 의미 있게 증가시킬 수 있는지를 평가하는 성과 테스트를 수행했습니다. 이 연구는 생물 또는 화학 공격에 대한 가상의 운영 계획을 생성하도록 두 명의 참가자로 구성된 팀에게 6시간 동안 시나리오를 제공하는 방식으로 진행되었습니다.

#### 연구 구성

- **시나리오**: 참가자들은 CBRNE 공격의 주요 계획 단계(제제 확보, 생산, 무기화 및 전달)를 포함하는 시나리오를 다루었습니다. 이 시나리오는 제한된 물질의 조달, 실제 실험실 프로토콜, 운영 보안과 관련된 도전을 해결할 수 있도록 상세한 계획을 이끌어내도록 설계되었습니다.
- **참가자**: 참가자들은 과학 또는 운영 전문 지식과 관련된 이전 경험을 바탕으로 모집되었으며, 공식적인 훈련이 없는 저숙련 참가자 두 명 또는 일부 훈련과 실무 경험이 있는 중숙련 참가자 두 명으로 구성된 팀에 배정되었습니다.
- **연구 설계 검증**: 연구 설계의 타당성을 검증하기 위해 예비 연구가 수행되었으며, 통계 분석을 위한 충분한 샘플 크기를 보장하기 위한 강력한 파워 분석도 포함되었습니다.

#### 연구 방법

각 팀은 "컨트롤" 또는 "LLM" 조건에 배정되었습니다.

- **컨트롤 팀**: 인터넷 기반 자원에만 접근할 수 있었습니다.
- **LLM 팀**: 인터넷 접근 외에도 웹 검색, 정보 검색 기능(RAG), 코드 실행(Python 및 Wolfram Alpha)이 가능한 Llama 3 모델에 접근할 수 있었습니다. RAG 기능 테스트를 위해, 관련 과학 논문의 키워드 검색을 통해 수백 개의 논문이 생성되어 Llama 3 모델 추론 시스템에 사전 로드되었습니다.

#### 평가

연습이 끝난 후, 각 팀이 생성한 운영 계획은 생물학, 화학 및 운영 계획 분야의 전문가들에 의해 평가되었습니다. 각 계획은 과학적 정확성, 세부 사항, 탐지 회피, 과학적 및 운영 실행의 성공 가능성 등의 측정 지표에 따라 네 가지 잠재적 공격 단계별로 평가되었습니다. 편향과 가변성을 줄이기 위해 강력한 델파이 과정을 거쳐, 단계별 측정 지표를 종합 점수로 통합하여 최종 점수가 생성되었습니다.

#### 결과

이 연구 결과에 대한 정량적 분석은 Llama 3 모델 사용과 관련된 성과의 유의미한 향상을 보여주지 않았습니다. 이러한 결과는 모든 LLM 조건을 웹 전용 컨트롤 조건과 비교한 종합 분석뿐만 아니라 화학 또는 생물 무기와 관련된 시나리오를 별도로 평가한 분석에서도 동일하게 나타났습니다. CBRNE 전문가와 결과를 검증한 후, Llama 3 모델의 출시가 생물학적 또는 화학 무기 공격과 관련된 생태계 위험을 증가시킬 가능성이 낮다고 평가했습니다.

### 5.4.6 레드 팀

우리는 위험을 발견하고 이러한 발견을 통해 벤치마크와 안전성 조정 데이터셋을 개선하기 위해 레드 팀을 활용합니다. 지속적인 모델 개발과 위험 완화 프로세스를 안내하기 위해 반복적인 레드 팀 연습을 수행하여 새로운 위험을 지속적으로 발견하고 있습니다.

#### 레드 팀 구성

레드 팀은 사이버 보안, 적대적 기계 학습, 책임 있는 AI 및 무결성 전문가들로 구성되어 있으며, 특정 지리적 시장의 무결성 문제에 대한 배경을 가진 다국어 콘텐츠 전문가들과도 협력합니다. 또한 중요한 위험 분야의 내부 및 외부 주제 전문가와 협력하여 위험 분류 체계를 구축하고 보다 집중된 적대적 평가를 지원합니다.

### 특정 모델 기능에 대한 적대적 테스트

우리는 초기 레드 팀 작업을 통해 특정 고위험 카테고리 내에서 개별 모델 기능을 중점적으로 분석하고, 이를 함께 테스트하여 위험을 발견했습니다. 레드 팀은 현실 세계 시나리오를 더 잘 모방하기 위해 프롬프트 수준의 공격에 집중했습니다. 모델이 예상된 행동에서 벗어나는 경우가 종종 발생하는데, 특히 프롬프트의 의도가 흐릿하거나 여러 추상화 계층을 겹쳐 놓은 경우에 그렇습니다. 이러한 위험은 추가 기능이 더해짐에 따라 복잡해지며, 아래에 레드 팀 작업에서 발견한 몇 가지를 자세히 설명합니다. 우리는 이러한 발견을 내부 안전 벤치마크 결과와 결합하여 지속적으로 모델 안전성을 개선하기 위한 포커스된 완화책을 개발합니다.

- **단기 및 장기 맥락 영어**: 우리는 단일 및 다중 턴 대화에서 알려진 기법과 공개되지 않은 기법을 혼합하여 사용했습니다. 또한 일부 기술과 위험 카테고리에서는 PAIR(Chao et al., 2023)와 유사한 고급 적대적 다중 턴 자동화를 활용했습니다. 대부분의 경우, 다중 턴 대화는 더 해로운 출력을 초래했습니다. 특히 여러 기법을 함께 사용할 때 이러한 공격이 모델 체크포인트 전반에 걸쳐 널리 퍼졌습니다.
  - **다중 턴 거부 억제**: 모델 응답을 특정 형식으로 따르거나 거부와 관련된 특정 정보를 포함/제외하도록 지정하는 것입니다.
  - **가상 시나리오**: 위반 프롬프트를 가상/이론적 작업 또는 가상 시나리오로 포장하는 것입니다. "가상으로"라는 단어를 추가하거나 정교한 계층적 시나리오를 만드는 것처럼 간단할 수 있습니다.
  - **페르소나 및 롤 플레이**: 모델에 특정 위반 응답 특성을 가진 페르소나를 부여하거나 사용자가 특정 benign 캐릭터를 채택하여 프롬프트의 맥락을 흐리게 만드는 것입니다.
  - **면책 조항 및 경고 추가**: 응답 프라이밍의 한 형태로 작동하며 모델이 일반화된 안전 교육과 교차하는 유용한 준수 경로를 허용하는 방법을 가정합니다. 다중 턴 대화에서 면책 조항, 트리거 경고 등을 요청하면 위반 비율이 증가했습니다.
  - **위반 점진적 확대**: 대화가 더나덜 benign 요청으로 시작하여 점진적으로 더 과장된 내용을 직접적으로 요청하는 형태의 다중 턴 공격입니다. 모델이 한 번 위반 내용을 출력하기 시작하면 회복하기 어려우며(거부가 발생할 경우 다른 공격을 사용할 수 있음), 장기 맥락 모델에서는 이 문제가 더 자주 발생할 것입니다.
- **다국어**: 여러 언어를 고려할 때 몇 가지 고유한 위험이 식별되었습니다.
  - **다국어 혼합**: 하나의 프롬프트 또는 대화에서 여러 언어를 혼합하면 단일 언어를 사용할 때보다 더 많은 위반 출력을 쉽게 초래할 수 있습니다.
  - **저자원 언어**: 관련 안전 미세 조정 데이터가 부족하거나 모델의 안전 일반화가 약할 때 위반 출력을 초래할 수 있습니다. 그러나 이 공격은 일반적으로 품질이 낮아 실제 적대적 사용은 제한적입니다.
  - **속어, 특정 맥락 또는 문화적 특정 참조**: 이러한 요소들은 모델이 특정 참조를 올바르게 이해하지 못해 처음에는 위반처럼 보일 수 있습니다.
- **도구 사용**: 테스트 중 영어 텍스트 수준의 적대적 프롬프트 기법이 성공적으로 위반 출력을 생성하는 것 외에도 여러 도구 특화 공격도 발견되었습니다.
  - **안전하지 않은 도구 체인**: 위반적인 도구 하나와 함께 여러 도구를 한 번에 요청하는 경우, 초기 체크포인트에서는 모든 도구가 혼합된 benign 및 위반 입력으로 호출될 수 있습니다.
  - **도구 사용 강제**: 특정 입력 문자열, 단편화된 또는 인코딩된 텍스트로 도구 입력을 유도하여 잠재적으로 위반적인 출력을 초래할 수 있습니다. 다른 기술을 사용하여 도구 결과에 접근할 수 있습니다.
  - **도구 사용 매개 변수 수정**: 쿼리에서 단어를 교환하거나, 재시도하거나, 다중 턴 대화에서 초기 요청의 일부를 흐리게 하여 위반을 초래할 수 있습니다.

### 아동 안전 위험

아동 안전 위험 평가가 전문가 팀에 의해 수행되어 모델이 아동 안전 위험을 초래할 수 있는 출력물을 생성할 가능성을 평가하고, 필요한 경우 적절한 위험 완화 방안을 조정하기 위해 세션을 진행했습니다. 우리는 이러한 전문가 레드 팀 세션을 활용하여 모델 개발을 통한 평가 벤치마크의 범위를 확장했습니다. Llama 3의 경우, 다수의 공격 벡터를 통해 모델 위험을 평가하기 위한 객관적 방법론을 사용하여 새로운 심층 세션을 진행했습니다. 또한, 시장별 특수성이나 경험을 고려한 잠재적 위반 콘텐츠를 평가하기 위해 콘텐츠 전문가와 협력하여 레드 팀 연습을 수행했습니다.

### 시스템 수준의 안전성

대형 언어 모델이 실제 애플리케이션에서 단독으로 사용되지 않고 더 넓은 시스템에 통합되는 경우가 많습니다. 이 섹션에서는 모델 수준의 완화를 보완하여 더 큰 유연성과 제어를 제공하는 시스템 수준의 안전성 구현에 대해 설명합니다.

이를 위해 우리는 Llama Guard 3라는 새로운 분류기를 개발하고 출시했습니다. 이 분류기는 안전성 분류를 위해 미세 조정된 Llama 3 8B 모델입니다. Llama Guard 2(Llama-Team, 2024)와 유사하게, 이 분류기는 입력 프롬프트 및/또는 언어 모델이 생성한 출력 응답이 특정 해악 범주에 대한 안전 정책을 위반하는지 감지하는 데 사용됩니다.

Llama의 확장된 기능을 지원하도록 설계되었으며, 영어 및 다국어 텍스트에 사용할 수 있습니다. 또한 검색 도구와 같은 도구 호출의 맥락에서 사용되도록 최적화되었으며 코드 인터프리터 남용을 방지합니다. 마지막으로 메모리 요구 사항을 줄이기 위해 양자화된 변형도 제공합니다. 개발자들이 시스템 안전 구성 요소를 기반으로 자신의 사용 사례에 맞게 구성할 것을 권장합니다.

### 분류 체계

우리는 AI 안전성 분류 체계(Vidgen et al., 2024)에 나열된 13개의 해악 범주(아동 성 착취, 명예 훼손, 선거, 증오, 무차별 무기, 지적 재산권, 비폭력 범죄, 프라이버시, 성범죄, 성적 콘텐츠, 전문적인 조언, 자살 및 자해, 폭력 범죄)와 코드 인터프리터 남용 범주에 대해 훈련합니다.

### 훈련 데이터

우리는 Llama Guard(Inan et al., 2023)에서 사용한 영어 데이터를 시작으로 이 데이터셋을 확장하여 새로운 기능을 통합합니다. 다국어 및 도구 사용과 같은 새로운 기능을 위해 프롬프트 및 응답 분류 데이터를 수집하고, 안전성 미세 조정을 위한 데이터도 활용합니다. 적대적 프롬프트에 응답을 거부하지 않도록 LLM을 프롬프트 엔지니어링하여 훈련 세트에 포함된 안전하지 않은 응답의 수를 증가시킵니다. Llama 3을 사용하여 생성된 데이터에 대한 응답 레이블을 획득합니다.

Llama Guard 3의 성능을 향상시키기 위해 인간 주석 및 Llama 3에 의한 LLM 주석을 통해 수집된 샘플을 광범위하게 정리합니다. 사용자 프롬프트에 대한 레이블을 얻는 것은 인간과 LLM 모두에게 훨씬 더 어려운 작업이며, 특히 경계선 프롬프트에 대해서는 인간 레이블이 약간 더 나은 것으로 나타났지만, 우리의 전체 반복 시스템은 노이즈를 줄이고 더 정확한 레이블을 생성하는 데 도움이 됩니다.

### 결과

Llama Guard 3는 여러 기능에서 위반을 크게 줄일 수 있습니다(우리의 벤치마크에서 평균적으로 -65%의 위반 감소). 시스템 보호 장치(및 일반적인 안전 완화 장치)를 추가하면 안전하지 않은 프롬프트에 대한 거부가 증가하는 비용이 발생합니다. 표 25에서는 이러한 균형을 강조하기 위해 위반율 감소 및 거부율 증가를 기본 모델과 비교하여 보고합니다. 이 효과는 그림 19, 20 및 21에서도 확인할 수 있습니다.

시스템 안전성은 더 큰 유연성을 제공합니다. Llama Guard 3는 특정 해악에 대해서만 배포할 수 있어 해악 범주 수준에서 위반 및 거부의 균형을 제어할 수 있습니다. 표 26은 개발자의 사용 사례에 따라 어떤 범주를 켜거나 꺼야 하는지를 알리기 위해 범주별 위반 감소를 나타냅니다.

안전 시스템을 쉽게 배포할 수 있도록 일반적으로 사용되는 int8 양자화 기법을 사용하여 Llama Guard 3의 양자화된 버전을 제공하여 크기를 40% 이상 줄였습니다. 표 27은 양자화가 모델 성능에 거의 영향을 미치지 않는 것을 보여줍니다.

![](/assets/images/posts/219/img_49.png)

#### 표 25

언어별로 Llama Guard 3를 사용하여 입력 또는 출력 필터링 시 Llama 3에 비해 위반율(VR) 및 거부율(FRR). 예를 들어, VR이 -50%인 경우, Llama Guard를 사용할 때 Llama 3 모델 위반율이 50% 감소했음을 의미합니다. 평가는 405B-매개변수 Llama 3 모델의 생성에서 수행되었습니다. 낮을수록 좋습니다.

### 프롬프트 기반 시스템 보호 장치

시스템 수준의 안전 구성 요소는 개발자가 LLM 시스템이 사용자 요청에 응답하는 방식을 맞춤화하고 제어할 수 있게 해줍니다. 모델 시스템의 전반적인 안전성을 개선하고 개발자가 책임 있게 배포할 수 있도록 하기 위해, 우리는 두 가지 프롬프트 기반 필터링 메커니즘인 Prompt Guard와 Code Shield의 생성 과정을 설명하고 공개합니다. 이들을 커뮤니티에서 그대로 활용하거나 영감을 얻어 자신만의 사용 사례에 맞게 조정할 수 있도록 오픈 소스화합니다.

### Prompt Guard

Prompt Guard는 모델 기반 필터로, 애플리케이션의 일부로 작동하는 LLM의 의도된 동작을 무력화하려는 입력 문자열인 프롬프트 공격을 감지하도록 설계되었습니다. 이 모델은 두 가지 유형의 프롬프트 공격 위험을 감지하는 멀티 라벨 분류기입니다. 첫 번째는 모델의 안전 조건이나 시스템 프롬프트를 명시적으로 무력화하려는 기법인 직접 탈옥(direct jailbreaks)이며, 두 번째는 모델의 컨텍스트 창에 포함된 타사 데이터가 사용자 명령으로 실행되도록 유도하는 간접 프롬프트 주입(indirect prompt injections)입니다. 이 모델은 LLM 입력을 필터링하기에 적합한 작은(86M) 매개변수 모델인 mDeBERTa-v3-base에서 미세 조정되었습니다. 우리는 여러 평가 데이터셋에서 성능을 평가하였으며, 그 결과를 표 28에 나타내었습니다. 평가에는 학습 데이터와 동일한 분포에서 추출된 두 개의 데이터셋(탈옥과 주입), 영어로 작성된 분포 외 데이터셋, 기계 번역을 통해 구축된 다국어 탈옥 세트, CyberSecEval에서 추출한 간접 주입 데이터셋(영어 및 다국어) 등이 포함됩니다. 전반적으로 모델은 새로운 분포에 잘 일반화되었으며 강력한 성능을 보였습니다.

### Code Shield

Code Shield는 추론 시간 필터링을 제공하는 시스템 수준 보호 장치의 한 예입니다. 특히, 생산 시스템과 같은 다운스트림 사용 사례에 들어가기 전에 불안전한 코드를 감지하는 데 중점을 둡니다. 이를 위해 정적 분석 라이브러리인 Insecure Code Detector(ICD)를 활용하여 불안전한 코드를 식별합니다. ICD는 7가지 프로그래밍 언어에서 분석을 수행하기 위해 다양한 정적 분석 도구를 사용합니다. 이러한 종류의 보호 장치는 일반적으로 개발자가 다양한 애플리케이션에서 다층 보호를 배포하는 데 유용합니다.

![](/assets/images/posts/219/img_50.png)

### 표 26

다양한 안전 범주에서 입력 또는 출력 필터링 시 Llama Guard 3를 사용할 때 Llama 3에 비해 위반율과 거부율. 예를 들어, VR이 -50%인 경우, Llama Guard를 사용할 때 Llama 3 모델 위반율이 50% 감소했음을 의미합니다. 평가는 영어 프롬프트 및 405B 매개변수 Llama 3 모델의 생성에서 수행되었습니다. 낮을수록 좋습니다.

![](/assets/images/posts/219/img_51.png)

### 표 27

Llama Guard 3 출력 분류 성능에 대한 int8 양자화의 효과를 다양한 모델 기능에 대해 나타냅니다.

### 한계점

우리는 Llama 3의 안전한 사용을 위한 다양한 위험에 대해 광범위한 측정 및 완화를 수행했습니다. 그러나 모든 위험을 식별하기 위한 테스트가 완벽할 수는 없습니다. Llama 3는 특히 영어 외의 언어와 관련된 다양한 데이터셋에서 훈련되었기 때문에 여전히 유해한 콘텐츠를 생성할 수 있습니다. 숙련된 적대적 레드 팀에 의해 프롬프트 엔지니어링될 때 특히 그렇습니다. 악의적인 개발자나 적대적인 사용자는 우리의 모델을 탈옥하여 다양한 악의적인 사용 사례에 사용할 새로운 방법을 찾을 수 있습니다. 우리는 계속해서 위험을 능동적으로 식별하고 완화 방법에 대한 연구를 수행할 것이며, 개발자가 모델 개발부터 사용자에게 배포까지 모든 측면에서 책임을 고려하도록 권장합니다. 우리는 개발자가 우리가 공개하는 오픈 소스 시스템 수준의 안전 스위트를 활용하고 기여하기를 바랍니다.

### 6. 추론(Inference)

우리는 Llama 3 405B 모델의 효율적인 추론을 위해 두 가지 주요 기술을 조사했습니다: (1) 파이프라인 병렬 처리와 (2) FP8 양자화입니다. FP8 양자화의 구현은 공개적으로 배포되었습니다.

### 6.1 파이프라인 병렬 처리

모델 매개변수에 BF16 숫자 표현을 사용할 때, Llama 3 405B는 8개의 Nvidia H100 GPU가 있는 단일 머신의 GPU 메모리에 맞지 않습니다. 이 문제를 해결하기 위해, 우리는 두 대의 머신에서 16개의 GPU를 사용하여 BF16 정밀도로 모델 추론을 병렬 처리합니다. 각 머신 내에서는 높은 NVLink 대역폭을 통해 텐서 병렬 처리(Shoeybi et al., 2019)를 사용할 수 있습니다. 그러나 노드 간 연결은 대역폭이 낮고 지연 시간이 더 높으므로 파이프라인 병렬 처리(Huang et al., 2019)를 대신 사용합니다.

파이프라인 병렬 처리로 훈련할 때, 버블(bubble)은 주요 효율성 문제입니다(섹션 3.3 참조). 그러나 추론 중에는 백워드 패스가 필요 없기 때문에 버블이 문제가 되지 않습니다. 따라서 파이프라인 병렬 처리에서 마이크로 배칭(micro-batching)을 사용하여 추론 처리량을 향상시킵니다.

4,096개의 입력 토큰과 256개의 출력 토큰을 갖는 추론 작업에서 두 개의 마이크로 배치를 사용할 때의 효과를 평가했습니다. 이는 추론의 키-값 캐시 프리필 단계와 디코딩 단계 모두에서 적용됩니다. 우리는 마이크로 배칭이 동일한 로컬 배치 크기로 추론 처리량을 향상시키는 것을 발견했습니다(그림 24 참조). 이러한 개선은 마이크로 배칭이 두 단계 모두에서 마이크로 배치의 동시 실행을 가능하게 하기 때문입니다. 추가 동기화 지점으로 인해 지연 시간이 증가하지만, 전반적으로 마이크로 배칭은 더 나은 처리량-지연 시간 트레이드오프를 제공합니다.

![](/assets/images/posts/219/img_52.png)

### 표 28 프롬프트 가드의 성능

프롬프트 가드의 성능 평가에는 분포 내 및 분포 외 평가, 기계 번역을 사용하여 구축된 다국어 탈옥 세트, 그리고 CyberSecEval의 간접 주입 데이터셋이 포함됩니다.

![](/assets/images/posts/219/img_53.png)

### 그림 24

마이크로 배칭이 추론 처리량과 지연 시간에 미치는 영향. 왼쪽: 프리필 단계, 오른쪽: 디코딩 단계. 플롯의 숫자는 (마이크로)배치 크기를 나타냅니다.

### 6.2 FP8 양자화 (FP8 Quantization)

우리는 H100 GPU의 네이티브 FP8 지원을 활용하여 저정밀도 추론을 수행하는 실험을 진행했습니다. 저정밀도 추론을 가능하게 하기 위해, 우리는 모델 내부의 대부분의 행렬 곱셈에 FP8 양자화를 적용했습니다. 특히, 모델에서 추론 계산 시간의 약 50%를 차지하는 피드포워드 네트워크 레이어의 대부분의 매개변수와 활성화를 양자화했습니다. 모델의 셀프 어텐션 레이어의 매개변수는 양자화하지 않았습니다. 더 나은 정확도를 위해 동적 스케일링 팩터를 활용(Xiao et al., 2024b)하고, 스케일을 계산하는 오버헤드를 줄이기 위해 CUDA 커널을 최적화했습니다. 우리는 Llama 3 405B의 품질이 특정 유형의 양자화에 민감하다는 것을 발견하고, 모델 출력 품질을 높이기 위해 몇 가지 추가적인 변경을 했습니다:

1. Zhang et al. (2021)와 유사하게, 첫 번째와 마지막 Transformer 레이어에서는 양자화를 수행하지 않습니다.
2. 날짜와 같은 높은 당혹도(perplexity) 토큰은 큰 활성화 값을 유발할 수 있습니다. 이는 FP8에서 높은 동적 스케일링 팩터를 초래할 수 있으며, 무시할 수 없는 수의 언더플로우가 발생하여 디코딩 오류를 유발할 수 있습니다. 이 문제를 해결하기 위해, 동적 스케일링 팩터를 1200으로 상한을 둡니다.
3. 행별(row-wise) 양자화를 사용하여 매개변수와 활성화 행렬에 대해 행별로 스케일링 팩터를 계산합니다(그림 25 참조). 이는 텐서별 양자화 접근 방식보다 더 잘 작동합니다.

#### 양자화 오류의 영향 (Effect of Quantization Errors)

표준 벤치마크 평가에서는 FP8 추론이 이러한 완화 조치 없이도 BF16 추론과 동등하게 수행되는 것으로 보입니다. 그러나 우리는 이러한 벤치마크가 FP8 양자화의 영향을 적절히 반영하지 않는다는 것을 발견했습니다. 스케일링 팩터가 상한이 없는 경우, 모델이 가끔 손상된 응답을 생성하는데, 이는 벤치마크 성능이 강력함에도 불구하고 발생합니다. 양자화로 인한 분포 변화를 측정하기 위해 벤치마크에 의존하는 대신, 우리는 FP8과 BF16을 사용하여 생성된 100,000개의 응답에 대한 보상 모델 점수의 분포를 분석하는 것이 더 낫다는 것을 발견했습니다. 그림 26은 우리의 양자화 접근 방식에 대한 보상 분포를 보여줍니다. 그림의 결과는 FP8 양자화에 대한 우리의 접근 방식이 모델의 응답에 매우 제한된 영향을 미친다는 것을 보여줍니다.

![](/assets/images/posts/219/img_54.png)

#### 그림 25

텐서별 양자화와 행별 양자화의 예시. 오른쪽: 행별 양자화는 더 세분화된 활성화 팩터를 사용할 수 있게 해줍니다. 왼쪽: 텐서별 양자화.

![](/assets/images/posts/219/img_55.png)

#### 그림 26

BF16과 FP8 추론을 사용한 Llama 3 405B의 보상 점수 분포. 우리의 FP8 양자화 접근 방식은 모델의 응답에 거의 영향을 미치지 않습니다.

### 실험적 평가의 효율성 (Experimental Evaluation of Efficiency)

그림 27은 Llama 3 405B를 사용하여 FP8 추론을 수행할 때의 처리량-지연 시간 트레이드오프를 보여줍니다. 이 실험은 4,096개의 입력 토큰과 256개의 출력 토큰을 사용하여 사전 채우기(pre-fill)와 디코딩 단계에서 이루어졌습니다. 그림은 6.1절에서 설명한 두 머신 BF16 추론 접근 방식과 FP8 추론의 효율성을 비교하고 있습니다. 결과는 FP8 추론을 사용하면 사전 채우기 단계에서 최대 50%의 처리량 개선이 이루어지며, 디코딩 단계에서도 처리량-지연 시간 트레이드오프가 상당히 개선된다는 것을 보여줍니다.

![](/assets/images/posts/219/img_56.png)

#### 그림 27

Llama 3 405B를 사용한 FP8 추론에서의 처리량-지연 시간 트레이드오프를 BF16 추론과 다양한 파이프라인 병렬화 설정을 사용하여 비교한 결과. 왼쪽: 사전 채우기(pre-filling) 단계의 결과. 오른쪽: 디코딩 단계의 결과.

### 7. 비전 실험 (Vision Experiments)

Llama 3에 시각 인식 기능을 통합하기 위해 두 가지 주요 단계를 포함하는 구성 접근 방식을 사용하여 일련의 실험을 수행했습니다. 첫 번째 단계에서는 이미지-텍스트 쌍의 대규모 데이터 세트에서 크로스 어텐션 레이어 세트를 도입하고 훈련하여 사전 훈련된 이미지 인코더(Xu et al., 2023)와 사전 훈련된 언어 모델을 결합합니다(Alayrac et al., 2022). 이를 통해 그림 28에 나와 있는 모델이 만들어집니다. 두 번째 단계에서는 시간적 정보 인식을 위해 대규모 비디오-텍스트 쌍을 사용하여 시간 집계 레이어와 추가 비디오 크로스 어텐션 레이어를 도입합니다.

기초 모델 개발에 있어 구성 접근 방식의 몇 가지 장점은 다음과 같습니다:

1. 시각 및 언어 모델링 기능의 개발을 병렬로 수행할 수 있습니다.
2. 시각 데이터 토큰화에서 발생하는 복잡성, 다른 모달리티에서 유래하는 토큰의 배경 혼란, 모달리티 간의 충돌을 피할 수 있습니다.
3. 시각 인식 기능의 도입으로 인해 텍스트 전용 작업에서 모델 성능이 영향을 받지 않도록 보장합니다.
4. 크로스 어텐션 아키텍처를 사용하여 전체 해상도 이미지를 점점 더 많은 LLM 백본(특히 각 트랜스포머 레이어의 피드포워드 네트워크)을 통해 전달할 필요가 없어 추론 시 더 효율적입니다.

우리는 여전히 개발 중인 멀티모달 모델을 공개할 준비가 되지 않았습니다. 실험 결과를 제시하기 전에 시각 인식 기능을 훈련시키기 위해 사용한 데이터, 비전 구성 요소의 모델 아키텍처, 이러한 구성 요소의 훈련을 확장하는 방법, 사전 훈련 및 후 훈련 방법을 설명합니다.

### 7.1 데이터

이미지와 비디오 데이터를 각각 아래에 설명합니다.

#### 7.1.1 이미지 데이터

이미지 인코더와 어댑터는 이미지-텍스트 쌍에서 훈련됩니다. 이 데이터 세트는 네 가지 주요 단계로 구성된 복잡한 데이터 처리 파이프라인을 통해 구성됩니다: (1) 품질 필터링, (2) 인식 기반 중복 제거, (3) 재샘플링, (4) 광학 문자 인식. 또한 일련의 안전 완화 조치를 적용합니다.

- **품질 필터링:** CLIP 점수가 낮은 비영어 캡션 및 저품질 캡션을 제거하는 품질 필터를 구현합니다(Radford et al., 2021).
- **중복 제거:** 대규모 훈련 데이터 세트를 중복 제거하면 훈련 계산을 절약할 수 있습니다. 내부 SSCD 복제 탐지 모델(Pizzi et al., 2022)을 사용하여 이미지를 대규모로 중복 제거합니다.
- **재샘플링:** Xu et al. (2023); Mahajan et al. (2018); Mikolov et al. (2013)과 유사한 방식으로 이미지-텍스트 쌍의 다양성을 보장하기 위해 재샘플링을 수행합니다.
- **광학 문자 인식:** 이미지에 작성된 텍스트를 추출하여 캡션에 연결함으로써 이미지-텍스트 데이터를 개선합니다.

![](/assets/images/posts/219/img_57.png)

그림 28 : Llama 3에 멀티모달 기능을 추가하기 위한 구성 접근 방식을 보여주는 그림. 이 접근 방식은 다음의 다섯 단계로 훈련된 멀티모달 모델로 이어집니다: (1) 언어 모델 사전 훈련, (2) 멀티모달 인코더 사전 훈련, (3) 비전 어댑터 훈련, (4) 모델 미세 조정, (5) 음성 어댑터 훈련.

### 문서 전사

문서 이해 작업에서 모델의 성능을 향상시키기 위해 문서의 페이지를 이미지로 렌더링하고 이미지를 해당 텍스트와 연결합니다. 문서 텍스트는 소스에서 직접 얻거나 문서 파싱 파이프라인을 통해 획득됩니다.

### 안전성

우리는 이미지 인식의 사전 훈련 데이터셋에 안전하지 않은 콘텐츠(예: 아동 성착취 자료(CSAM))가 포함되지 않도록 주로 초점을 맞춥니다(Thiel, 2023). 모든 훈련 이미지를 PhotoDNA(Farid, 2021)와 같은 인식 해시 접근법과 내부 독점 분류기를 사용하여 CSAM을 검사합니다. 또한, 성적이거나 폭력적인 콘텐츠를 포함하는 이미지-텍스트 쌍을 식별하고 제거하기 위해 독점적인 미디어 위험 검색 파이프라인을 사용합니다. 훈련 데이터셋에서 이러한 자료의 존재를 최소화하는 것이 최종 모델의 안전성을 높이는 동시에 유용성에 영향을 미치지 않는다고 믿습니다. 마지막으로 훈련 세트의 모든 이미지에 얼굴 흐리기 처리를 수행합니다. 모델을 첨부된 이미지를 참조하는 인간 생성 프롬프트에 대해 테스트합니다.

### 어닐링 데이터

n-그램을 사용하여 이미지-캡션 쌍을 3억 5천만 개 예제로 재샘플링하여 어닐링 데이터셋을 만듭니다. n-그램 재샘플링은 더 풍부한 텍스트 설명을 선호하기 때문에 더 높은 품질의 데이터 하위 집합을 선택합니다. 결과 데이터에 다음의 다섯 가지 추가 소스로부터 1억 5천만 개의 예제를 보충합니다:

- **시각적 그라운딩:** 텍스트의 명사구를 이미지의 바운딩 박스 또는 마스크에 연결합니다. 그라운딩 정보(바운딩 박스 및 마스크)는 이미지-텍스트 쌍에 두 가지 방식으로 지정됩니다. (1) 박스 또는 마스크를 이미지에 겹쳐 놓고 텍스트에서 참조로 사용하는 방식입니다(Yang et al., 2023a). (2) 특수 토큰으로 구분된 정규화된 (xmin, ymin, xmax, ymax) 좌표를 직접 텍스트에 삽입합니다.
- **스크린샷 파싱:** HTML 코드를 렌더링하여 스크린샷을 생성하고 모델이 스크린샷의 특정 요소를 생성한 코드를 예측하도록 합니다(Lee et al., 2023). 스크린샷에서 관심 요소는 바운딩 박스로 표시됩니다.
- **질문-답변 쌍:** 너무 커서 모델 미세 조정에 사용할 수 없는 질문-답변 데이터를 포함합니다.
- **합성 캡션:** 모델의 초기 버전에서 생성된 합성 캡션이 있는 이미지를 포함합니다. 원본 캡션과 비교하여 합성 캡션이 이미지에 대한 더 포괄적인 설명을 제공합니다.
- **합성적으로 생성된 구조화된 이미지:** 차트, 표, 흐름도, 수학 방정식 및 텍스트 데이터를 포함하는 다양한 도메인에 대한 합성적으로 생성된 이미지를 포함합니다. 이러한 이미지는 해당 마크다운 또는 LaTeX 표기법과 같은 구조화된 표현과 함께 제공됩니다. 이러한 도메인에 대한 모델의 인식 기능을 개선하는 것 외에도 이 데이터는 모델 미세 조정을 위한 질문-답변 쌍을 생성하는 데 유용합니다.

### 7.1.2 비디오 데이터

비디오 사전 훈련을 위해 대규모 비디오-텍스트 쌍 데이터셋을 사용합니다. 데이터셋은 다단계 프로세스를 통해 큐레이션됩니다. 연관된 텍스트는 최소 길이를 보장하고 대문자를 수정하는 등의 규칙 기반 휴리스틱을 사용하여 필터링하고 정리합니다. 언어 식별 모델을 실행하여 비영어 텍스트를 필터링합니다. OCR 감지 모델을 실행하여 과도한 텍스트 오버레이가 있는 비디오를 필터링합니다. 비디오-텍스트 쌍 간의 합리적인 정렬을 보장하기 위해 CLIP(Radford et al., 2021) 스타일의 이미지-텍스트 및 비디오-텍스트 대조 모델을 사용합니다. 먼저 비디오의 단일 프레임을 사용하여 이미지-텍스트 유사성을 계산하고, 유사성이 낮은 쌍을 필터링한 후 비디오-텍스트 정렬이 낮은 쌍을 추가로 필터링합니다. 데이터의 일부는 정적 또는 저동작 비디오를 포함하며, 이러한 데이터를 모션 스코어 기반 필터링(Girdhar et al., 2023)을 사용하여 필터링합니다. 비디오의 시각적 품질(미적 점수 또는 해상도 필터링)에 대해서는 필터를 적용하지 않습니다.

데이터셋에는 평균 길이가 21초이고 중간 길이가 16초인 비디오가 포함되어 있으며, 비디오의 99% 이상이 1분 미만입니다. 공간 해상도는 320p에서 4K 비디오까지 다양하며, 비디오의 70% 이상이 짧은 쪽이 720픽셀 이상입니다. 비디오의 종횡비는 다양하며 거의 모든 비디오가 1:2에서 2:1 사이의 종횡비를 가지며, 중간 값은 1:1입니다.

### 7.2 모델 아키텍처

우리의 시각 인식 모델은 세 가지 주요 구성 요소로 구성됩니다: (1) 이미지 인코더, (2) 이미지 어댑터, (3) 비디오 어댑터입니다.

#### 이미지 인코더

이미지 인코더는 이미지와 텍스트를 정렬하도록 훈련된 표준 비전 트랜스포머(ViT; Dosovitskiy et al. (2020))입니다. 우리는 ViT-H/14 변형을 사용하며, 이 인코더는 6.3억 개의 매개변수를 가지고 있으며, 2.5억 개의 이미지-텍스트 쌍을 5 에포크 동안 훈련했습니다. 이미지 인코더는 224x224 해상도의 이미지에서 사전 훈련되었으며, 이미지는 16x16 크기의 패치로 나누어졌습니다(즉, 패치 크기는 14x14 픽셀). ViP-Llava(Cai et al., 2024)와 같은 이전 연구에서도 입증되었듯이, 텍스트 정렬 목표로 훈련된 이미지 인코더는 세부적인 위치 정보를 보존하는 데 어려움을 겪습니다. 이를 해결하기 위해 다층 특징 추출 방식을 채택하여 최종 레이어 특징 외에도 4, 8, 16, 24 및 31층의 특징을 제공합니다. 또한, 교차 주의 레이어의 정렬 관련 특징을 학습하기 위해 사전 훈련 전에 8개의 게이트드 자기 주의 레이어를 추가했습니다. 따라서 이미지 인코더는 총 8.5억 개의 매개변수를 가지게 됩니다. 다층 특징을 통해 이미지 인코더는 16x16=256 패치 각각에 대해 7680차원의 표현을 생성합니다. 우리는 텍스트 인식과 같은 도메인에서 성능을 향상시키기 위해 후속 훈련 단계에서 이미지 인코더의 매개변수를 동결하지 않습니다.

#### 이미지 어댑터

이미지 인코더가 생성한 시각적 토큰 표현과 언어 모델이 생성한 토큰 표현 사이에 교차 주의 레이어를 도입합니다(Alayrac et al., 2022). 교차 주의 레이어는 코어 언어 모델의 네 번째 자기 주의 레이어마다 적용됩니다. 언어 모델 자체처럼, 교차 주의 레이어는 효율성을 높이기 위해 일반화된 쿼리 주의(GQA)를 사용합니다. 교차 주의 레이어는 모델에 많은 추가 훈련 가능한 매개변수를 도입합니다: Llama 3 405B의 경우 교차 주의 레이어는 약 100억 개의 매개변수를 가집니다. 우리는 이미지 어댑터를 두 단계로 사전 훈련합니다: (1) 초기 사전 훈련 후 (2) 어닐링:

- 초기 사전 훈련: 위에서 설명한 약 60억 개의 이미지-텍스트 쌍 데이터셋으로 이미지 어댑터를 사전 훈련합니다. 계산 효율성을 위해 모든 이미지를 최대 336x336 픽셀의 네 타일 내에 맞추기 위해 크기를 조정합니다. 타일은 672x672, 672x336, 1344x336 등 다양한 종횡비를 지원하도록 배열됩니다.
- 어닐링: 어닐링 데이터셋의 약 5억 개의 이미지로 이미지 어댑터 훈련을 계속합니다. 어닐링 중에는 타일당 이미지 해상도를 높여 인포그래픽 이해와 같이 고해상도 이미지를 필요로 하는 작업에서 성능을 향상시킵니다.

#### 비디오 어댑터

모델은 최대 64 프레임(전체 비디오에서 균일하게 샘플링됨)을 입력으로 받아들이며, 각 프레임은 이미지 인코더에 의해 처리됩니다. 우리는 비디오의 시간 구조를 두 가지 구성 요소를 통해 모델링합니다: (i) 인코딩된 비디오 프레임은 연속적인 32 프레임을 하나로 합치는 시간 집계자를 통해 집계됩니다, (ii) 추가 비디오 교차 주의 레이어가 네 번째 이미지 교차 주의 레이어마다 추가됩니다. 시간 집계자는 퍼시버 리샘플러(Jaegle et al., 2021; Alayrac et al., 2022)로 구현됩니다. 우리는 비디오당 16 프레임(1 프레임으로 집계됨)을 사용하여 사전 훈련하지만, 감독된 미세 조정 중에는 입력 프레임 수를 64로 증가시킵니다. 비디오 집계자와 교차 주의 레이어는 Llama 3 7B 및 70B에 대해 각각 6억 개 및 46억 개의 매개변수를 가집니다.

### 7.3 모델 확장

Llama 3에 시각 인식 구성 요소가 추가된 후, 모델에는 자기 주의 레이어, 교차 주의 레이어, ViT 이미지 인코더가 포함됩니다. 8B 및 70B 매개변수 모델용 어댑터를 훈련시키기 위해 데이터 및 텐서 병렬화의 조합이 가장 효율적이라는 것을 발견했습니다. 이러한 규모에서는 모델 또는 파이프라인 병렬화가 효율성을 높이지 못하는데, 이는 모델 매개변수를 모으는 데 필요한 계산이 대부분을 차지하기 때문입니다. 그러나 405B 매개변수 모델의 어댑터를 훈련할 때는 데이터 및 텐서 병렬화 외에 파이프라인 병렬화를 사용합니다. 이 규모에서 훈련할 때는 섹션 3.3에 설명된 문제 외에도 모델 이질성, 데이터 이질성, 수치 불안정성이라는 세 가지 새로운 문제가 발생합니다.

#### 모델 이질성

모델 계산은 일부 토큰에서 다른 토큰보다 더 많은 계산이 수행되기 때문에 이질적입니다. 특히, 이미지 토큰은 이미지 인코더와 교차 주의 레이어에서 처리되는 반면, 텍스트 토큰은 언어 백본에서만 처리됩니다. 이 이질성은 파이프라인 병렬화의 스케줄링에서 병목 현상을 초래합니다. 이 문제를 해결하기 위해 각 파이프라인 단계가 다섯 개의 레이어(즉, 언어 백본의 네 개의 자기 주의 레이어와 하나의 교차 주의 레이어)를 포함하도록 합니다. 또한, 모든 파이프라인 단계에서 이미지 인코더를 복제합니다. 이미지-텍스트 데이터 쌍으로 훈련하므로, 이는 이미지와 텍스트 계산 부하를 균형 있게 분배할 수 있게 합니다.

#### 데이터 이질성

데이터는 이미지가 평균적으로 관련 텍스트보다 더 많은 토큰을 가지고 있기 때문에 이질적입니다: 이미지는 2,308개의 토큰을 가지는 반면, 관련 텍스트는 평균 192개의 토큰을 가집니다. 결과적으로 교차 주의 레이어의 계산은 자기 주의 레이어의 계산보다 더 많은 시간과 메모리를 필요로 합니다. 이 문제를 해결하기 위해 이미지 인코더에서 시퀀스 병렬화를 도입하여 각 GPU가 대략 동일한 수의 토큰을 처리하도록 합니다. 평균 텍스트 크기가 상대적으로 짧기 때문에, 미세 배치 크기(1 대신 8)를 상당히 크게 사용합니다.

#### 수치 불안정성

이미지 인코더가 모델에 추가된 후, bf16에서 그래디언트 축적을 수행할 때 수치 불안정성이 발생하는 것을 발견했습니다. 이 문제의 가장 가능성 높은 원인은 이미지 토큰이 모든 교차 주의 레이어를 통해 언어 백본에 도입되기 때문입니다. 이는 이미지 토큰의 표현에서 수치적 편차가 전체 계산에 큰 영향을 미치게 되어 오류가 누적되기 때문입니다. 이를 해결하기 위해 FP32에서 그래디언트 축적을 수행합니다.

### 7.4 사전 훈련

#### 이미지

사전 훈련된 텍스트 모델과 비전 인코더 가중치에서 초기화합니다. 비전 인코더는 고정되지 않고, 텍스트 모델 가중치는 위에서 설명한 대로 고정됩니다. 먼저, 각 이미지를 336x336 픽셀의 네 개 타일 내에 맞추도록 크기를 조정한 60억 개의 이미지-텍스트 쌍을 사용하여 모델을 훈련합니다. 글로벌 배치 크기는 16,384이며, 초기 학습률 10^-4와 가중치 감쇠 0.01을 사용하는 코사인 학습률 스케줄을 사용합니다. 초기 학습률은 소규모 실험을 기반으로 결정되었습니다. 그러나 이러한 결과는 매우 긴 훈련 스케줄에 잘 일반화되지 않았고, 손실 값이 정체될 때 학습률을 몇 번 떨어뜨렸습니다. 기본 사전 훈련 후, 이미지 해상도를 더욱 높이고 동일한 가중치로 어닐링 데이터셋에서 훈련을 계속합니다. 옵티마이저는 학습률 2x10^-5로 웜업하여 다시 초기화되며, 다시 코사인 스케줄을 따릅니다.

#### 비디오

비디오 사전 훈련을 위해, 위에서 설명한 이미지 사전 훈련 및 어닐링 가중치에서 시작합니다. 비디오 집계기와 교차 주의 레이어를 추가하며, 이는 무작위로 초기화됩니다. 비디오 관련 매개변수를 제외한 모델의 모든 매개변수를 고정하고, 비디오 사전 훈련 데이터에서 훈련합니다. 이미지 어닐링 단계와 동일한 훈련 하이퍼파라미터를 사용하지만, 학습률에는 약간의 차이가 있습니다. 전체 비디오에서 균일하게 샘플링된 16 프레임을 사용하며, 각 프레임은 448x448 픽셀 크기의 네 개 조각으로 나타냅니다. 비디오 집계기에서 집계 계수 16을 사용하여 하나의 효과적인 프레임을 얻으며, 이는 텍스트 토큰이 교차 주의할 수 있습니다. 글로벌 배치 크기는 4,096이고, 시퀀스 길이는 190 토큰이며, 학습률은 10^-4입니다.

### 7.5 사후 훈련

이 섹션에서는 시각 어댑터에 대한 사후 훈련 방법을 설명합니다. 사전 훈련 후, 우리는 모델을 고도로 선별된 다중 모드 대화 데이터에 맞춰 미세 조정하여 채팅 기능을 활성화합니다. 또한 인간 평가 성능을 높이기 위해 직접 선호도 최적화(DPO)를 구현하고, 다중 모드 추론 능력을 향상시키기 위해 거부 샘플링을 도입합니다. 마지막으로, 모델을 매우 소량의 고품질 대화 데이터에 추가로 미세 조정하는 품질 조정 단계를 추가하여 인간 평가 성능을 더욱 향상시키면서 벤치마크 성능을 유지합니다. 각 단계에 대한 자세한 내용은 아래에 제공됩니다.

#### 7.5.1 지도 학습 데이터

이미지 및 비디오 기능에 대한 지도 학습(SFT) 데이터를 별도로 설명합니다.

**이미지**

우리는 다양한 데이터 세트를 활용하여 지도 학습을 수행합니다.

- **학술 데이터 세트**: 기존 학술 데이터 세트의 고도로 필터링된 컬렉션을 템플릿을 사용하거나 LLM 재작성 과정을 통해 질문-응답 쌍으로 변환합니다. LLM 재작성의 목적은 데이터를 다양한 지시사항으로 증강하고 답변의 언어 품질을 향상시키는 것입니다.
- **인간 주석**: 우리는 인간 주석자를 통해 다양한 작업(개방형 질문-응답, 캡셔닝, 실제 사용 사례 등)과 도메인(예: 자연 이미지 및 구조화된 이미지)에 대해 다중 모드 대화 데이터를 수집합니다. 주석자는 이미지를 제공받고 대화를 작성하도록 요청받습니다. 다양성을 보장하기 위해 대규모 데이터 세트를 클러스터링하고 다양한 클러스터에서 균일하게 이미지를 샘플링합니다. 또한 주석자는 모델-인터루프 스타일 주석을 촉진하기 위해 기존 모델의 중간 체크포인트를 제공받아, 주석자가 모델 생성물을 시작점으로 추가 인간 수정을 제공할 수 있게 합니다. 이는 모델 체크포인트가 최신 데이터로 훈련된 더 나은 성능의 버전으로 정기적으로 업데이트되는 반복적 과정입니다. 이 과정은 인간 주석의 양과 효율성을 증가시키면서 품질도 향상시킵니다.
- **합성 데이터**: 우리는 텍스트-입력 LLM을 사용하여 합성 다중 모드 데이터를 생성하는 다양한 방법을 탐구합니다. 고수준 아이디어는 텍스트-입력 LLM의 추론 능력을 활용하여 텍스트 도메인에서 질문-응답 쌍을 생성하고, 텍스트 표현을 해당 이미지로 대체하여 합성 다중 모드 데이터를 생성하는 것입니다. 예를 들어, 질문-응답 데이터 세트에서 텍스트를 이미지로 렌더링하거나, 표 데이터를 표와 차트의 합성 이미지로 렌더링하는 것이 있습니다. 추가로, 기존 이미지에서 캡션 및 OCR 추출물을 사용하여 이미지와 관련된 추가 대화 또는 질문-응답 데이터를 생성합니다.

**비디오**

이미지 어댑터와 유사하게, 사전 주석된 학술 데이터 세트를 사용하여 적절한 텍스트 지시사항과 목표 응답으로 변환합니다. 목표는 개방형 응답 또는 다중 선택 옵션으로 변환됩니다. 우리는 인간에게 비디오에 질문과 해당 답변을 주석하도록 요청합니다. 주석자는 단일 프레임으로 답할 수 없는 질문에 집중하도록 요청받아 시간적 이해가 필요한 질문으로 유도됩니다.

#### 7.5.2 지도 학습 레시피

이미지 및 비디오 기능에 대한 지도 학습(SFT) 레시피를 별도로 설명합니다.

**이미지**

사전 훈련된 이미지 어댑터에서 시작하지만, 사전 훈련된 언어 모델의 가중치를 지시 튜닝된 언어 모델의 가중치로 교체합니다. 텍스트 전용 성능을 유지하기 위해 언어 모델 가중치는 고정된 상태로 유지되며, 비전 인코더와 이미지 어댑터 가중치만 업데이트됩니다.

우리의 모델 미세 조정 접근 방식은 Wortsman et al. (2022)과 유사합니다. 먼저, 데이터, 학습률, 가중치 감쇠 값을 무작위로 선택한 여러 하위 집합을 사용하여 하이퍼파라미터 스윕을 실행합니다. 다음으로, 성능을 기준으로 모델을 순위 매기고, 최종적으로 상위-K 모델의 가중치를 평균하여 최종 모델을 얻습니다. K의 값은 평균 모델을 평가하고 성능이 가장 높은 인스턴스를 선택하여 결정됩니다. 평균 모델은 일관되게 그리드 검색을 통해 찾은 최상의 개별 모델보다 더 나은 결과를 제공하며, 하이퍼파라미터에 대한 민감도를 줄여줍니다.

**비디오**

비디오 SFT의 경우, 비디오 집계기와 교차 주의 레이어를 사전 훈련된 가중치로 초기화합니다. 모델의 나머지 매개변수, 이미지 가중치 및 LLM은 해당 미세 조정 단계 이후의 모델에서 초기화됩니다. 비디오 사전 훈련과 유사하게, 비디오 SFT 데이터에서 비디오 매개변수만 미세 조정합니다. 이 단계에서 비디오 길이를 64 프레임으로 늘리고, 집계 계수를 32로 하여 두 개의 효과적인 프레임을 얻습니다. 청크의 해상도는 대응되는 이미지 하이퍼파라미터와 일치하도록 증가시킵니다.

### 7.5.3 선호 데이터

우리는 보상 모델링과 직접 선호 최적화를 위해 다중 모드 쌍별 선호 데이터 세트를 구축했습니다.

- **인간 주석**: 인간이 주석을 달아준 선호 데이터는 두 개의 다른 모델 출력 간의 비교로 구성되며, "선택됨"과 "거부됨"으로 라벨링되고 7점 척도로 평가됩니다. 응답을 생성하는 모델은 다양한 특성을 가진 최근의 최고 모델 풀에서 샘플링되며, 모델 풀은 매주 업데이트됩니다. 선호 라벨 외에도 주석자들은 "선택됨" 응답의 부정확성을 수정하기 위해 선택적으로 인간 수정을 요청받습니다. 이는 비전 작업에서 부정확성에 대한 허용 오차가 낮기 때문입니다. 인간 수정은 선택적 단계로, 실제로는 양과 질 사이의 균형을 맞춰야 하기 때문입니다.
- **합성 데이터**: 합성 선호 쌍은 텍스트 전용 LLM을 사용하여 지도 학습 데이터 세트에서 오류를 도입하고 편집함으로써 생성될 수 있습니다. 우리는 대화 데이터를 입력으로 사용하고, LLM을 사용하여 미묘하지만 의미 있는 오류(예: 객체 변경, 속성 변경, 계산 실수 추가 등)를 도입합니다. 이러한 편집된 응답은 부정적인 "거부됨" 샘플로 사용되며 "선택됨" 원본 지도 학습 데이터와 짝지어집니다.
- **거부 샘플링**: 정책 기반 부정적 샘플을 더 많이 생성하기 위해, 우리는 거부 샘플링의 반복 과정을 활용하여 추가 선호 데이터를 수집했습니다. 거부 샘플링은 고품질 생성을 반복적으로 샘플링하는 데 사용됩니다. 따라서 선택되지 않은 모든 생성물은 부정적인 거부 샘플로 사용되어 추가 선호 데이터 쌍으로 사용될 수 있습니다.

### 7.5.4 보상 모델링

우리는 비전 SFT 모델과 언어 보상 모델(RM)을 기반으로 비전 보상 모델(RM)을 훈련합니다. 비전 인코더와 교차 주의 레이어는 비전 SFT 모델에서 초기화되고 훈련 중에 고정되지 않으며, 자체 주의 레이어는 언어 RM에서 초기화되고 고정됩니다. 언어 RM 부분을 고정하면 일반적으로 더 나은 정확도로 이어지며, 특히 RM이 지식이나 언어 품질을 기반으로 판단해야 하는 작업에서 그렇습니다. 우리는 언어 RM과 동일한 훈련 목표를 채택하지만, 배치 평균에 대한 보상 로짓의 제곱에 가중 정규화 항을 추가하여 보상 점수가 드리프트하는 것을 방지합니다.

섹션 7.5.3에서 설명한 인간 선호 주석을 사용하여 비전 RM을 훈련합니다. 우리는 언어 선호 데이터(섹션 4.2.1)와 동일한 관행을 따라 명확한 순위(편집됨 > 선택됨 > 거부됨)를 가진 두세 쌍을 만듭니다. 또한, 이미지의 정보(예: 숫자 또는 시각적 텍스트)와 관련된 단어나 구를 교란시켜 부정적인 응답을 합성적으로 증강합니다. 이는 비전 RM이 실제 이미지 콘텐츠를 기반으로 판단을 내리도록 장려합니다.

### 7.5.5 직접 선호 최적화

언어 모델(섹션 4.1.4)과 유사하게, 우리는 섹션 7.5.3에서 설명한 선호 데이터를 사용하여 직접 선호 최적화(DPO; Rafailov et al. (2023))로 비전 어댑터를 추가로 훈련합니다. 사후 훈련 라운드 동안 분포 변화를 막기 위해, 우리는 최근의 인간 선호 주석 배치만 유지하고, 충분히 정책을 벗어난 배치(예: 기본 사전 훈련 모델이 변경된 경우)를 삭제합니다. 참조 모델을 항상 고정하는 대신, k-스텝마다 지수 이동 평균(EMA) 방식으로 업데이트하는 것이 모델이 데이터에서 더 많이 배우도록 도와주며, 인간 평가에서 더 나은 성능을 발휘한다는 것을 발견했습니다. 전체적으로, 비전 DPO 모델은 모든 미세 조정 반복에서 인간 평가에서 일관되게 SFT 시작점보다 더 나은 성능을 보였습니다.

### 7.5.6 거부 샘플링

대부분의 사용 가능한 질문-답변 쌍은 최종 답변만 포함하고, 추론 작업에서 잘 일반화되는 모델을 훈련하는 데 필요한 사고 과정 설명이 부족합니다. 우리는 이러한 예제에 대한 누락된 설명을 생성하고 모델의 추론 능력을 향상시키기 위해 거부 샘플링을 사용합니다.

질문-답변 쌍을 주어진 상태에서, 우리는 다양한 시스템 프롬프트나 온도로 미세 조정된 모델을 샘플링하여 여러 답변을 생성합니다. 다음으로, 생성된 답변을 휴리스틱이나 LLM 판사를 통해 실제 답변과 비교합니다. 마지막으로, 올바른 답변을 미세 조정 데이터에 다시 추가하여 모델을 재훈련합니다. 질문당 여러 올바른 답변을 유지하는 것이 유용하다는 것을 발견했습니다.

우리가 다시 훈련에 고품질 예제만 추가하도록 하기 위해, 다음 두 가지 안전장치를 구현했습니다. 첫째, 최종 답변이 올바르더라도 잘못된 설명이 포함된 예제가 있음을 발견했습니다. 이러한 패턴은 생성된 답변 중 일부만 올바른 경우에 더 자주 발생합니다. 따라서, 답변이 올바를 확률이 특정 임계값 이하인 질문에 대한 답변은 삭제합니다. 둘째, 평가자는 언어 또는 스타일의 차이로 인해 일부 답변을 선호합니다. 우리는 보상 모델을 사용하여 가장 높은 품질의 상위-K 답변을 선택하고 이를 훈련에 다시 추가합니다.

### 7.5.7 품질 조정 (Quality Tuning)

우리는 모든 샘플이 인간 또는 최고의 모델에 의해 다시 작성되고 검증된, 작지만 매우 선택적인 SFT 데이터셋을 큐레이션합니다. 우리는 이 데이터를 사용하여 DPO 모델을 훈련하여 응답 품질을 향상시키는 과정을 품질 조정(Quality-Tuning, QT)이라고 합니다. 우리는 QT 데이터셋이 다양한 작업을 포괄하고 적절한 초기 정지를 적용할 때 QT가 인간 평가를 크게 개선하면서도 벤치마크에서 일반화를 유지함을 발견했습니다. 이 단계에서 체크포인트를 선택하는 기준은 순전히 벤치마크를 기반으로 하여 모델의 기능이 유지되거나 향상되도록 합니다.

![](/assets/images/posts/219/img_58.png)

### 테이블 29: Llama 3에 연결된 비전 모듈의 이미지 이해 성능

우리 모델의 성능을 GPT-4V, GPT-4o, Gemini 1.5 Pro, Claude 3.5 Sonnet과 비교합니다. 4개 항목은 외부 OCR 도구를 사용하여 얻은 결과입니다.

### 7.6 이미지 인식 결과

Llama 3의 이미지 이해 능력을 다양한 과제에서 평가했습니다. 여기에는 자연 이미지 이해, 텍스트 이해, 차트 이해, 멀티모달 추론이 포함됩니다:

- **MMMU (Yue et al., 2024a)**: 이 데이터셋은 멀티모달 추론을 위한 도전적인 데이터셋으로, 모델이 이미지를 이해하고 30개 이상의 다양한 학문 분야에서 대학 수준의 문제를 해결해야 합니다. 여기에는 선택형 질문과 주관식 질문이 모두 포함됩니다. 우리는 다른 연구와 동일하게 검증 세트에 있는 900개의 이미지에 대해 모델을 평가했습니다.
- **VQAv2 (Antol et al., 2015)**: 모델이 이미지 이해, 언어 이해 및 상식 지식을 결합하여 자연 이미지에 대한 일반적인 질문에 답하는 능력을 테스트합니다.
- **AI2 Diagram (Kembhavi et al., 2016)**: 과학 다이어그램을 해석하고 이에 대한 질문에 답하는 모델의 능력을 평가합니다. 우리는 Gemini와 x.ai와 동일한 평가 프로토콜을 사용하며, 투명한 경계 상자를 사용하여 점수를 보고합니다.
- **ChartQA (Masry et al., 2022)**: 차트 이해를 위한 도전적인 벤치마크로, 모델이 다양한 종류의 차트를 시각적으로 이해하고 이에 대한 논리적인 질문에 답해야 합니다.
- **TextVQA (Singh et al., 2019)**: 이미지 내 텍스트를 읽고 이를 기반으로 질문에 답하는 모델의 능력을 테스트하는 인기 있는 벤치마크 데이터셋입니다. 이는 모델의 자연 이미지에 대한 OCR 이해 능력을 테스트합니다.
- **DocVQA (Mathew et al., 2020)**: 문서 분석 및 인식을 중심으로 한 벤치마크 데이터셋입니다. 다양한 문서 이미지를 포함하며, 모델이 문서의 내용을 이해하고 질문에 답하는 능력을 평가합니다.

테이블 29에는 우리의 실험 결과가 나와 있습니다. 테이블의 결과는 Llama 3에 연결된 비전 모듈이 다양한 이미지 인식 벤치마크에서 경쟁력 있는 성능을 보임을 보여줍니다. Llama 3-V 405B 모델을 사용하여 우리는 모든 벤치마크에서 GPT-4V를 능가했으며, Gemini 1.5 Pro와 Claude 3.5 Sonnet에 비해 약간 뒤처졌습니다. Llama 3 405B는 특히 문서 이해 작업에서 경쟁력이 있는 것으로 나타났습니다.

![](/assets/images/posts/219/img_59.png)

테이블 30은 우리의 실험 결과를 보여줍니다. 테이블의 결과는 Llama 3의 비전 모듈이 긴 형식 및 시간적 비디오 이해를 포함하는 다양한 작업에서 경쟁력 있으며, 때로는 다른 모델보다 더 우수한 성능을 발휘함을 보여줍니다.

### 7.7 비디오 인식 결과

Llama 3의 비디오 어댑터를 세 가지 벤치마크에서 평가했습니다:

- **PerceptionTest (Patraucean et al., 2023)**: 이 벤치마크는 모델의 시간적 추론 능력을 평가하며, 기억, 추상화, 물리학, 의미론과 같은 기술과 설명적, 예측적, 반사실적 추론과 같은 다양한 유형의 추론을 포함합니다. 11.6K의 테스트 QA 쌍으로 구성되어 있으며, 각 비디오는 평균 23초 길이로, 전 세계 100명의 참가자가 촬영한 지각적으로 흥미로운 작업을 보여줍니다. 각 질문은 세 가지 선택 옵션과 짝을 이루는 다중 선택 질문 응답 작업에 초점을 맞춥니다. 우리의 예측을 온라인 챌린지 서버에 제출하여 유지된 테스트 분할에서 성능을 보고합니다.
- **NExT-QA (Xiao et al., 2021)**: 시간적 및 인과적 추론 벤치마크로, 개방형 질문 응답에 초점을 맞춥니다. 1K의 테스트 비디오(평균 44초 길이)와 9K의 질문으로 구성되어 있습니다. 모델의 응답을 지상 진리 답변과 비교하여 Wu-Palmer 유사성(WUPS) (Wu and Palmer, 1994)를 사용하여 평가합니다.
- **TVQA (Lei et al., 2018)**: 모델의 구성적 추론 수행 능력을 평가하며, 관련 순간의 시공간적 위치화, 시각적 개념 인식, 자막 기반 대화와의 공동 추론을 필요로 합니다. 인기 있는 TV 쇼에서 파생된 이 데이터셋은 또한 모델이 이러한 TV 쇼에 대한 외부 지식을 활용하여 질문에 답할 수 있는 능력을 테스트합니다. 15K 이상의 검증 QA 쌍으로 구성되어 있으며, 각 비디오 클립은 평균 76초 길이입니다. 다섯 가지 선택 옵션이 있는 다중 선택 형식을 따르며, 이전 연구(OpenAI, 2023b)를 따라 검증 세트에서 성능을 보고합니다.
- **ActivityNet-QA (Yu et al., 2019)**: 긴 비디오 클립을 통해 행동, 공간 관계, 시간 관계, 수 계산 등을 이해하는 모델의 능력을 평가합니다. 800개의 비디오에서 8K의 테스트 QA 쌍으로 구성되어 있으며, 각 비디오는 평균 3분 길이입니다. 이전 연구(Google, 2023; Lin et al., 2023; Maaz et al., 2024)의 프로토콜을 따라 평가하며, 모델이 짧은 단어 또는 구를 생성하고, 출력의 정확성은 GPT-3.5 API를 사용하여 지상 진리 답변과 비교하여 평가합니다. API에 의해 평가된 평균 정확도를 보고합니다.

추론을 수행할 때, 전체 비디오 클립에서 프레임을 균일하게 샘플링하여 짧은 텍스트 프롬프트와 함께 모델에 전달합니다. 대부분의 벤치마크가 다중 선택 질문에 답하는 것을 포함하기 때문에, 다음과 같은 프롬프트를 사용합니다: "다음 옵션 중에서 올바른 답을 선택하십시오: {질문}. 올바른 옵션 문자와 그 외 아무것도 답하지 마십시오." 짧은 답변을 요구하는 벤치마크(ActivityNet-QA 및 NExT-QA)의 경우, 다음과 같은 프롬프트를 사용합니다: "한 단어 또는 구를 사용하여 질문에 답하십시오. {질문}." NExT-QA의 경우, 평가 메트릭(WUPS)이 길이와 특정 단어에 민감하므로 모델이 구체적으로 응답하고 가장 중요한 답변을 제공하도록 추가로 프롬프트합니다. 예를 들어, 위치 질문에 "집" 대신 "거실"로 응답하도록 지정합니다. 자막이 포함된 벤치마크(TVQA)의 경우, 추론 중 클립에 해당하는 자막을 프롬프트에 포함시킵니다.

표 30에서 Llama 3 8B와 70B의 성능을 제시합니다. Llama 3의 성능을 두 개의 Gemini 및 두 개의 GPT-4 모델과 비교합니다. 우리의 결과는 모두 제로샷 방식이며, 이러한 벤치마크의 어느 부분도 훈련이나 미세 조정 데이터에 포함하지 않았습니다. 후속 훈련 동안 소형 비디오 어댑터를 훈련한 Llama 3 모델이 매우 경쟁력 있으며, 일부 경우에는 사전 훈련부터 본질적인 멀티모달 처리를 활용하는 다른 모델들보다 더 나은 성능을 발휘한다는 것을 알 수 있습니다. 특히 Llama 3는 8B 및 70B 파라미터 모델만 평가했음에도 불구하고 비디오 인식에서 매우 우수한 성능을 발휘합니다. Llama 3는 PerceptionTest에서 최고의 성능을 발휘하여 모델이 복잡한 시간적 추론을 수행하는 강력한 능력을 가지고 있음을 시사합니다. ActivityNet-QA와 같은 장기 활동 이해 작업에서는 3분 길이의 비디오에서 매 3초마다 한 프레임만 처리함에도 불구하고 Llama 3가 강력한 결과를 얻을 수 있었습니다.

![](/assets/images/posts/219/img_60.png)

그림 29는 Llama 3의 음성 인터페이스 아키텍처를 보여줍니다.

## 8. 음성 실험

우리는 Llama 3에 음성 인식 기능을 통합하는 방법을 연구하기 위해 시각 인식에 사용된 방법과 유사한 구성적 접근 방식을 사용한 실험을 수행했습니다. 입력 측면에서는 음성 신호를 처리하기 위해 인코더와 어댑터를 도입했습니다. Llama 3의 음성 이해를 위해 시스템 프롬프트(텍스트)를 활용하여 다양한 작동 모드를 활성화할 수 있습니다. 시스템 프롬프트가 제공되지 않으면 모델은 Llama 3의 텍스트 전용 버전과 일치하는 방식으로 사용자의 음성에 효과적으로 응답하는 범용 음성 대화 모델로 작동합니다. 다중 회차 대화 경험을 개선하기 위해 대화 기록을 프롬프트 접두사로 도입했습니다. 우리는 Llama 3를 자동 음성 인식(ASR) 및 자동 음성 번역(AST)에 사용할 수 있는 시스템 프롬프트를 실험했습니다. Llama 3의 음성 인터페이스는 최대 34개의 언어를 지원합니다. 또한 텍스트와 음성을 혼합하여 입력할 수 있어 모델이 고급 오디오 이해 작업을 해결할 수 있습니다.

우리는 또한 언어 모델 디코딩 중에 실시간으로 음성 파형을 생성하는 스트리밍 텍스트-음성 변환(TTS) 시스템을 구현하는 음성 생성 접근 방식을 실험했습니다. 우리는 Llama 3에 대한 음성 생성기를 독점적인 TTS 시스템을 기반으로 설계했으며, 음성 생성에 대한 언어 모델을 미세 조정하지 않았습니다. 대신 Llama 3 임베딩을 추론 시 활용하여 음성 합성 지연 시간, 정확도 및 자연스러움을 개선하는 데 중점을 두었습니다. 음성 인터페이스는 그림 28과 29에 설명되어 있습니다.

### 8.1 데이터

#### 8.1.1 음성 이해

훈련 데이터는 크게 두 가지 유형으로 나눌 수 있습니다. 사전 훈련 데이터에는 음성 인코더를 자가 지도 방식으로 초기화하는 데 사용되는 많은 양의 라벨 없는 음성이 포함됩니다. 지도 학습 미세 조정 데이터에는 음성 인식, 음성 번역 및 음성 대화 데이터가 포함되어 있으며, 이 데이터는 대형 언어 모델과 통합될 때 특정 기능을 잠금 해제하는 데 사용됩니다.

- **사전 훈련 데이터:** 음성 인코더를 사전 훈련하기 위해 약 1,500만 시간의 음성 녹음 데이터를 큐레이션했습니다. 우리는 음성 활동 감지(VAD) 모델을 사용하여 오디오 데이터를 필터링하고, VAD 임계값이 0.7 이상인 오디오 샘플을 사전 훈련에 선택했습니다. 음성 사전 훈련 데이터에서는 PII의 부재를 보장하는 데 중점을 두었습니다. 우리는 Presidio 분석기를 사용하여 이러한 PII를 식별했습니다.
- **음성 인식 및 번역 데이터:** 우리의 ASR 훈련 데이터에는 34개 언어에 걸친 230,000시간의 수동으로 전사된 음성 녹음이 포함됩니다. 우리의 AST 훈련 데이터에는 두 가지 방향으로 90,000시간의 번역이 포함됩니다: 33개 언어에서 영어로, 그리고 영어에서 33개 언어로. 이 데이터에는 NLLB 툴킷(NLLB Team et al., 2022)을 사용하여 생성된 지도 데이터와 합성 데이터가 모두 포함됩니다. 합성 AST 데이터를 사용하면 리소스가 부족한 언어의 모델 품질을 향상시킬 수 있습니다. 우리의 데이터에서 음성 세그먼트는 최대 길이가 60초입니다.
- **음성 대화 데이터:** 음성 어댑터를 음성 대화에 맞게 미세 조정하기 위해, 언어 모델에게 이러한 프롬프트의 전사에 응답하도록 요청하여 음성 프롬프트에 대한 응답을 합성적으로 생성했습니다(Fathullah et al., 2024). 이렇게 생성된 합성 데이터는 ASR 데이터셋의 하위 집합(60,000시간의 음성)을 사용하여 생성되었습니다. 또한, Voicebox TTS 시스템(Le et al., 2024)을 사용하여 Llama 3를 미세 조정하는 데 사용된 데이터 하위 집합에 대해 25,000시간의 합성 데이터를 생성했습니다. 우리는 여러 휴리스틱을 사용하여 음성 분포와 일치하는 미세 조정 데이터의 하위 집합을 선택했습니다. 이러한 휴리스틱에는 상대적으로 짧고 단순한 구조의 프롬프트와 비텍스트 기호가 없는 프롬프트에 중점을 두는 것이 포함됩니다.

#### 8.1.2 음성 생성

음성 생성 데이터셋은 주로 텍스트 정규화(TN) 모델과 운율 모델(PM)을 훈련하는 데 사용됩니다. 두 훈련 데이터 모두 Llama 3 임베딩의 추가 입력 기능으로 증강되어 맥락 정보를 제공합니다.

- **텍스트 정규화 데이터:** 우리의 TN 훈련 데이터셋에는 비트리비얼한 정규화가 필요한 다양한 준언어 클래스(예: 숫자, 날짜, 시간)를 포함한 55,000개의 샘플이 포함되어 있습니다. 각 샘플은 작성된 형식의 텍스트와 해당하는 정규화된 구어 형식의 텍스트로 구성되며, 정규화를 수행하는 수작업의 TN 규칙 시퀀스를 포함합니다.
- **운율 모델 데이터:** PM 훈련 데이터에는 50,000시간의 TTS 데이터셋에서 추출된 언어 및 운율 특징이 포함되어 있으며, 이는 스튜디오 환경에서 전문 성우가 녹음한 텍스트와 오디오로 이루어져 있습니다.
- **Llama 3 임베딩:** Llama 3 임베딩은 16번째 디코더 층의 출력으로 사용됩니다. 우리는 독점적으로 Llama 3 8B 모델과 협력하며, Llama 3 모델이 비어 있는 사용자 프롬프트로 생성한 것처럼 주어진 텍스트(즉, TN을 위한 작성 형식의 입력 텍스트 또는 PM을 위한 오디오 전사)에 대해 임베딩을 추출합니다. 주어진 샘플에서 Llama 3 토큰 시퀀스의 각 청크는 TN 또는 PM의 네이티브 입력 시퀀스에 있는 해당 청크(유니코드 범주로 구분된 TN 전용 텍스트 토큰 또는 전화 속도 특징)에 명시적으로 정렬됩니다. 이를 통해 Llama 3 토큰 및 임베딩의 스트리밍 입력으로 TN 및 PM 모듈을 훈련할 수 있습니다.

## 8.2 모델 아키텍처

### 8.2.1 음성 이해

입력 측면에서, 음성 모듈은 두 개의 연속된 모듈로 구성됩니다: 음성 인코더와 어댑터입니다. 음성 모듈의 출력은 토큰 표현으로 직접 언어 모델에 공급되어 음성 및 텍스트 토큰 간의 직접 상호작용을 가능하게 합니다. 또한, 음성 표현 시퀀스를 둘러싸는 두 개의 새로운 특수 토큰을 도입했습니다. 음성 모듈은 언어 모델에 교차 주의 레이어를 통해 다중 모달 정보를 공급하는 비전 모듈과는 상당히 다릅니다. 반면, 음성 모듈은 텍스트 토큰과 매끄럽게 통합될 수 있는 임베딩을 생성하여 음성 인터페이스가 Llama 3 언어 모델의 모든 기능을 활용할 수 있게 합니다.

#### 음성 인코더

우리의 음성 인코더는 10억 개의 매개변수를 가진 Conformer (Gulati et al., 2020) 모델입니다. 모델의 입력은 80차원 멜-스펙트로그램 특징으로, 프레임 길이를 40ms로 줄이기 위해 먼저 스트라이드-4 스택 레이어와 선형 투영을 통해 처리됩니다. 결과 특징은 24개의 Conformer 레이어를 가진 인코더에 의해 처리됩니다. 각 Conformer 레이어는 1536의 잠재 차원을 가지며, 차원이 4096인 두 개의 Macron-net 스타일 피드포워드 네트워크, 커널 크기가 7인 컨볼루션 모듈, 24개의 주의 헤드를 가진 로터리 주의 모듈(Su et al., 2024)로 구성됩니다.

#### 음성 어댑터

음성 어댑터는 약 1억 개의 매개변수를 포함합니다. 이 어댑터는 컨볼루션 레이어, 로터리 Transformer 레이어, 그리고 선형 레이어로 구성됩니다. 컨볼루션 레이어는 커널 크기가 3이고 스트라이드가 2인 레이어로, 음성 프레임 길이를 80ms로 줄이는 것이 설계되었습니다. 이를 통해 모델은 언어 모델에 더 조밀한 특징을 제공할 수 있습니다. Transformer 레이어는 3072의 잠재 차원과 4096의 차원을 가진 피드포워드 네트워크로 구성되며, 컨볼루션 다운샘플링 후 음성 정보를 문맥과 함께 추가로 처리합니다. 마지막으로, 선형 레이어는 출력 차원을 언어 모델 임베딩 레이어와 일치하도록 매핑합니다.

### 8.2.2 음성 생성

우리는 텍스트 정규화(TN)와 운율 모델링(PM)의 두 가지 주요 구성 요소에서 Llama 3 8B 임베딩을 사용하여 음성을 생성합니다. TN 모듈은 문맥적으로 작성된 텍스트를 구어형으로 변환하여 의미적 정확성을 보장하고, PM 모듈은 이러한 임베딩을 사용하여 운율 특징을 예측함으로써 자연스러움과 표현력을 향상시킵니다. 이 두 가지 구성 요소가 결합되어 정확하고 자연스러운 음성 생성을 가능하게 합니다.

#### 텍스트 정규화

생성된 음성의 의미적 정확성을 결정하는 요소로서, 텍스트 정규화(TN) 모듈은 작성된 텍스트를 구어형 텍스트로 문맥에 맞게 변환하는 역할을 합니다. 예를 들어, "123"이라는 작성된 텍스트는 상황에 따라 '일백 이십 삼'이라는 숫자형으로 읽히거나 '하나 둘 셋'이라는 숫자 하나하나의 발음으로 읽힐 수 있습니다. TN 시스템은 입력 텍스트를 변환하기 위해 수작업으로 만든 TN 규칙의 시퀀스를 예측하는 스트리밍 LSTM 기반 시퀀스 태깅 모델로 구성됩니다(Kang et al., 2024). 이 신경망 모델은 교차 주의 메커니즘을 통해 Llama 3 임베딩을 받아 문맥 정보를 활용하여 최소한의 텍스트 토큰 선행과 스트리밍 입출력을 가능하게 합니다.

#### 운율 모델링

합성된 음성의 자연스러움과 표현력을 향상시키기 위해, 우리는 Llama 3 임베딩을 추가 입력으로 사용하는 디코더 전용 Transformer 기반 운율 모델(PM)을 통합합니다(Radford et al., 2021). 이러한 통합은 Llama 3의 언어적 능력을 활용하여 텍스트 출력과 토큰 단위에서 중간 임베딩을 사용하여 운율 특징 예측을 향상시켜 모델이 필요한 선행을 줄입니다(Devlin et al., 2018; Dong et al., 2019; Raffel et al., 2020; Guo et al., 2023).

PM은 종합적인 운율 예측을 생성하기 위해 여러 입력 구성 요소를 통합합니다: 텍스트 정규화 프론트엔드에서 파생된 언어적 특징, 토큰 및 임베딩. PM은 각 음소의 로그 기간, 로그 F0(기본 주파수) 평균, 및 음소 기간 동안의 로그 파워 평균의 세 가지 주요 운율 특징을 예측합니다. 모델은 단방향 Transformer와 여섯 개의 주의 헤드로 구성됩니다. 각 블록은 교차 주의 레이어와 이중 완전 연결 레이어(은닉 차원 864)를 포함합니다. PM의 독특한 특징은 이중 교차 주의 메커니즘으로, 하나의 레이어는 언어적 입력에 전념하고 다른 하나는 Llama 임베딩에 전념합니다. 이 설정은 명시적인 정렬 없이도 다양한 입력 속도를 효율적으로 관리합니다.

### 8.3 학습 레시피

#### 8.3.1 음성 이해

음성 모듈의 학습은 두 단계로 이루어집니다. 첫 번째 단계인 음성 사전 학습에서는 라벨이 없는 데이터를 활용하여 다양한 언어와 음향 조건에 대해 강력한 일반화 능력을 갖춘 음성 인코더를 학습합니다. 두 번째 단계에서는 지도 학습을 통해 어댑터와 사전 학습된 인코더를 언어 모델과 통합하고, 언어 모델은 동결된 상태에서 함께 학습합니다. 이를 통해 모델이 음성 입력에 반응할 수 있게 됩니다. 이 단계에서는 음성 이해 능력에 해당하는 라벨이 있는 데이터를 사용합니다.

다국어 ASR(자동 음성 인식) 및 AST(자동 음성 번역) 모델링은 종종 언어 혼동/간섭을 초래하여 성능 저하로 이어집니다. 이를 완화하는 일반적인 방법은 소스와 타겟 측에 언어 식별(LID) 정보를 포함시키는 것입니다. 이는 미리 정해진 방향에서 성능을 향상시킬 수 있지만, 일반성을 잃을 가능성도 있습니다. 예를 들어, 번역 시스템이 소스와 타겟 측 모두에서 LID를 기대한다면, 학습 중에 보지 못한 방향에서는 좋은 제로샷 성능을 보이지 않을 가능성이 큽니다. 따라서 우리의 도전 과제는 일정 수준의 LID 정보를 허용하면서도 모델이 보지 못한 방향에서도 음성 번역을 수행할 수 있도록 일반성을 유지하는 시스템을 설계하는 것입니다. 이를 해결하기 위해 우리는 타겟 측 텍스트에만 LID를 포함하는 시스템 프롬프트를 설계했습니다. 이러한 프롬프트에는 소스 측 음성 입력에 대한 LID 정보가 없기 때문에 코드 스위칭된 음성에도 잠재적으로 작동할 수 있습니다. ASR의 경우, 시스템 프롬프트는 "Repeat after me in {language}:"이며, 여기서 {language}는 34개 언어 중 하나입니다(영어, 프랑스어 등). 음성 번역의 경우 시스템 프롬프트는 "Translate the following sentence into {language}:"입니다. 이 디자인은 언어 모델이 원하는 언어로 응답하도록 유도하는 데 효과적인 것으로 나타났습니다. 우리는 학습과 추론에서 동일한 시스템 프롬프트를 사용했습니다.

#### 음성 사전 학습

우리는 BEST-RQ 알고리즘(Chiu et al., 2022)을 사용하여 음성 인코더를 사전 학습합니다. 입력 멜-스펙트로그램에 32프레임 길이의 마스크를 2.5% 확률로 적용합니다. 음성 발화가 60초를 초과하는 경우, 60초에 해당하는 6K 프레임을 무작위로 크롭합니다. 멜-스펙트로그램 특징을 4개의 연속 프레임을 스택하여 양자화하고, 320차원 벡터를 16차원 공간으로 투영한 후, 8,192개의 벡터로 이루어진 코드북 내에서 코사인 유사성 측정 기준으로 최근접 이웃 검색을 수행합니다. 사전 학습을 안정화하기 위해 16개의 다른 코드북을 사용합니다. 투영 행렬과 코드북은 무작위로 초기화되며 모델 학습 동안 업데이트되지 않습니다. 효율성을 위해 마스킹된 프레임에만 다중 소프트맥스 손실을 사용합니다. 인코더는 500K 스텝 동안 전역 배치 크기 2,048 발화로 학습됩니다.

#### 지도 학습

사전 학습된 음성 인코더와 무작위로 초기화된 어댑터는 지도 학습 단계에서 Llama 3과 함께 공동 최적화됩니다. 이 과정에서 언어 모델은 변경되지 않습니다. 학습 데이터는 ASR, AST 및 음성 대화 데이터의 혼합물입니다. Llama 3 8B의 음성 모델은 전역 배치 크기 512 발화와 초기 학습률 10^-4로 650K 업데이트 동안 학습됩니다. Llama 3 70B의 음성 모델은 전역 배치 크기 768 발화와 초기 학습률 4x10^-5로 600K 업데이트 동안 학습됩니다.

### 8.4 음성 이해 결과

우리는 Llama 3의 음성 인터페이스에 대한 음성 이해 능력을 세 가지 작업에서 평가했습니다: (1) 자동 음성 인식(ASR), (2) 음성 번역, (3) 음성 질문 응답. Llama 3의 음성 인터페이스 성능을 Whisper (Radford et al., 2023), SeamlessM4T (Barrault et al., 2023), Gemini와 같은 최신 음성 이해 모델들과 비교했습니다. 모든 평가에서 Llama 3 토큰 예측에 대해 탐욕적 탐색(greedy search)을 사용했습니다.

#### 자동 음성 인식(ASR)

우리는 Multilingual LibriSpeech (MLS; Pratap et al., 2020), LibriSpeech (Panayotov et al., 2015), VoxPopuli (Wang et al., 2021a)와 다국어 FLEURS 데이터셋(Conneau et al., 2023)의 영어 데이터셋에서 ASR 성능을 평가했습니다. 평가에서는 디코딩 결과를 Whisper 텍스트 정규화기를 사용해 후처리하여 다른 모델의 보고된 결과와의 일관성을 유지했습니다. 모든 벤치마크에서 우리는 표준 테스트 세트에서 Llama 3의 음성 인터페이스의 단어 오류율을 측정했습니다. 단, 중국어, 일본어, 한국어 및 태국어에 대해서는 문자 오류율을 보고했습니다.

테이블 31은 ASR 평가 결과를 보여줍니다. 이는 Llama 3(및 멀티모달 기반 모델 전반적으로)이 음성 인식 작업에서 강력한 성능을 발휘함을 보여줍니다. 우리 모델은 Whisper와 SeamlessM4T와 같은 음성에 특화된 모델들보다 모든 벤치마크에서 우수한 성능을 보였습니다. MLS 영어에서 Llama 3는 Gemini와 유사한 성능을 보였습니다.

#### 음성 번역

우리는 비영어 음성을 영어 텍스트로 번역하는 음성 번역 작업에서도 모델을 평가했습니다. 이러한 평가에서 FLEURS와 Covost 2(Wang et al., 2021b) 데이터셋을 사용하여 번역된 영어의 BLEU 점수를 측정했습니다. 테이블 32는 이러한 실험의 결과를 보여줍니다. 음성 번역에서 우리 모델의 성능은 음성 번역과 같은 작업에서 멀티모달 기반 모델의 장점을 강조합니다.

#### 음성 질문 응답

Llama 3의 음성 인터페이스는 뛰어난 질문 응답 능력을 보여줍니다. 모델은 그러한 데이터에 사전 노출 없이도 코드 스위칭된 음성을 쉽게 이해할 수 있습니다. 특히, 모델이 단일 턴 대화만을 학습했음에도 불구하고, 확장된 일관된 다중 턴 대화 세션에 참여할 수 있습니다. 그림 30은 이러한 다국어 및 다중 턴 능력을 강조하는 몇 가지 예를 제시합니다.

#### 안전성

우리는 영어와 스페인어로 된 20,000개의 발화와 19개의 다른 언어로 된 4,000개의 발화 각각에 대해 독성 라벨이 부착된 다국어 오디오 기반 데이터셋인 MuTox(Costa-jussà et al., 2023)에서 우리의 음성 모델의 안전성을 평가했습니다. 오디오는 모델에 입력으로 전달되고, 일부 특수 문자를 정리한 후 출력을 독성 여부로 평가합니다. 우리는 MuTox 분류기(Costa-jussà et al., 2023)를 적용하여 Gemini 1.5 Pro와 비교했습니다. 우리는 입력 프롬프트가 안전하고 출력이 독성인 경우의 추가된 독성(AT) 비율과 입력 프롬프트가 독성이고 답변이 안전한 경우의 잃은 독성(LT) 비율을 평가했습니다. 테이블 33은 영어와 평가한 21개 언어 전체 평균에 대한 결과를 보여줍니다. 추가된 독성의 비율은 매우 낮으며, 우리 음성 모델은 영어에서 추가된 독성 비율이 1% 미만으로 가장 낮습니다. 이는 추가된 독성보다 제거된 독성의 비율이 더 높습니다.

![](/assets/images/posts/219/img_61.png)

테이블 31은 음성 인식 작업에 대한 Llama 3의 음성 인터페이스의 단어 오류율을 보여줍니다. 우리는 참조를 위해 Whisper, SeamlessM4T 및 Gemini의 성능을 보고합니다.

![](/assets/images/posts/219/img_62.png)

테이블 32는 음성 번역 작업에 대한 Llama 3의 음성 인터페이스의 BLEU 점수를 보여줍니다. 우리는 참조를 위해 Whisper와 SeamlessM4T의 성능을 보고합니다.

![](/assets/images/posts/219/img_63.png)

#### 그림 30

그림 30은 Llama 3의 음성 인터페이스를 사용한 전사된 대화 예시를 보여줍니다. 이 예시들은 제로샷 다중 턴 및 코드 스위칭 기능을 설명합니다.

### 8.5 음성 생성 결과

음성 생성의 경우, 우리는 텍스트 정규화 및 운율 모델링 작업을 위한 Llama 3 임베딩을 사용한 토큰별 입력 스트리밍 모델의 품질 평가에 중점을 두었습니다. 평가의 초점은 Llama 3 임베딩을 추가 입력으로 사용하지 않는 모델과의 비교입니다.

#### 텍스트 정규화

Llama 3 임베딩의 효과를 측정하기 위해 모델이 사용하는 오른쪽 컨텍스트의 양을 변경하여 실험했습니다. 우리는 유니코드 카테고리로 구분된 3개의 TN 토큰의 오른쪽 컨텍스트를 사용하여 모델을 훈련했습니다. 이 모델을 Llama 3 임베딩을 사용하지 않는 모델과 비교했습니다. 오른쪽 컨텍스트가 3개의 토큰이거나 전체 양방향 컨텍스트를 사용하는 경우입니다. 예상대로, 테이블 34는 전체 오른쪽 컨텍스트를 사용하는 것이 Llama 3 임베딩이 없는 모델의 성능을 향상시킨다는 것을 보여줍니다. 그러나 Llama 3 임베딩을 통합한 모델은 다른 모든 모델보다 우수한 성능을 발휘하여 입력에서 긴 컨텍스트에 의존하지 않고 토큰 단위의 입력/출력 스트리밍을 가능하게 합니다.

![](/assets/images/posts/219/img_64.png)

#### 테이블 33

테이블 33은 MuTox 데이터셋에서 Llama 3의 음성 인터페이스의 독성을 평가한 것입니다. AT는 추가된 독성(%)을, LT는 잃은 독성(%)을 나타냅니다.

![](/assets/images/posts/219/img_65.png)

#### 테이블 34

테이블 34는 샘플별 텍스트 정규화(TN) 정확도를 보여줍니다. 우리는 Llama 3 8B 임베딩을 사용한 모델과 사용하지 않은 모델을, 그리고 다른 오른쪽 컨텍스트 값을 사용한 모델을 비교했습니다.

### 운율 모델링

Llama 3 8B와 함께 사용되는 우리의 운율 모델(PM) 성능을 평가하기 위해 Llama 3 임베딩을 사용한 모델과 사용하지 않은 모델을 비교하는 두 가지 인간 평가 세트를 수행했습니다. 평가자는 다양한 모델에서 생성된 샘플을 듣고 자신의 선호도를 표시했습니다. 최종 음성 파형을 생성하기 위해 우리는 사내 트랜스포머 기반 음향 모델(Wu et al., 2021)을 사용하여 스펙트럴 특징을 예측하고, WaveRNN 신경 vocoder(Kalchbrenner et al., 2018)를 사용하여 최종 음성 파형을 생성했습니다.

먼저, Llama 3 임베딩이 없는 스트리밍 기준 모델과 직접 비교를 수행했습니다. 두 번째 테스트에서는 Llama 3 8B PM을 Llama 3 임베딩이 없는 비스트리밍 기준 모델과 비교했습니다. 테이블 35에 표시된 바와 같이, Llama 3 8B PM은 스트리밍 기준 모델과 비교했을 때 60%의 선호도를 얻었고, 비스트리밍 기준 모델과 비교했을 때 63.6%의 선호도를 얻어 인식된 품질이 크게 향상되었음을 나타냅니다. Llama 3 8B PM의 주요 장점은 토큰 단위 스트리밍 기능(Section 8.2.2)으로, 추론 시 낮은 대기 시간을 유지합니다. 이는 모델의 선행 요구 사항을 줄여 비스트리밍 기준 모델에 비해 더 응답적이고 실시간 음성 합성을 가능하게 합니다. 전반적으로, Llama 3 8B 운율 모델은 기준 모델을 일관되게 능가하여 합성된 음성의 자연스러움과 표현력을 향상시키는 데 효과적임을 입증했습니다.

![](/assets/images/posts/219/img_66.png)

### 테이블 35 운율 모델링(PM) 평가

왼쪽: 스트리밍 전화 전용 기준 모델과 비교한 Llama 3 8B PM의 평가자 선호도.

오른쪽: 비스트리밍 전화 전용 기준 모델과 비교한 Llama 3 8B PM의 평가자 선호도.

### 9 관련 연구

Llama 3의 개발은 언어, 이미지, 비디오, 음성 분야의 기초 모델에 대한 대규모의 기존 연구에 기반합니다. 이러한 작업에 대한 종합적인 개요는 본 논문의 범위를 벗어나므로, Bordes et al. (2024); Madan et al. (2024); Zhao et al. (2023a)를 참조하십시오. 아래에서는 Llama 3 개발에 직접 영향을 미친 주요 연구를 간략히 설명합니다.

#### 9.1 언어

**규모**: Llama 3는 점점 더 큰 규모에서 단순한 방법을 적용하는 지속적인 추세를 따릅니다. 개선은 증가된 연산 능력과 향상된 데이터로 인해 이루어지며, 405B 모델은 Llama 2 70B의 사전 훈련 연산 예산의 거의 50배를 사용합니다. 4050억 개의 매개변수를 포함함에도 불구하고, 가장 큰 Llama 3는 PALM (Chowdhery et al., 2023)과 같은 이전의 훨씬 덜 성능이 좋은 모델보다 적은 매개변수를 포함하고 있으며, 이는 스케일링 법칙에 대한 더 나은 이해에 기인합니다 (Kaplan et al., 2020; Hoffmann et al., 2022). Claude 3나 GPT-4 (OpenAI, 2023a)와 같은 다른 최신 모델의 크기에 대해서는 거의 알려져 있지 않지만, 전체 성능은 비슷합니다.

**소형 모델**: 소형 모델의 발전도 대형 모델과 병행하여 이루어졌습니다. 더 적은 매개변수를 가진 모델은 추론 비용을 크게 줄이고 배포를 간소화할 수 있습니다 (Mehta et al., 2024; Team et al., 2024). 소형 Llama 3 모델은 연산 최적 훈련 지점을 훨씬 넘어서 훈련하여 훈련 연산을 추론 효율성으로 효과적으로 교환합니다. 또 다른 방법은 더 큰 모델을 소형 모델로 증류하는 것으로, Phi (Abdin et al., 2024)에서와 같이 구현됩니다.

**아키텍처**: Llama 3는 Llama 2와 비교하여 최소한의 아키텍처 수정만을 가했지만, 다른 최신 기초 모델들은 다양한 디자인을 탐구했습니다. 가장 주목할 만한 것은 전문가 혼합 아키텍처 (Shazeer et al., 2017; Lewis et al., 2021; Fedus et al., 2022; Zhou et al., 2022)로, Mixtral (Jiang et al., 2024)과 Arctic (Snowflake, 2024)과 같은 모델의 용량을 효율적으로 증가시키는 데 사용될 수 있습니다. Llama 3는 이러한 모델보다 뛰어나며, 이는 밀집 아키텍처가 제한 요소가 아님을 시사하지만, 훈련 및 추론 효율성과 모델 안정성 측면에서 수많은 트레이드오프가 존재합니다.

**오픈 소스**: 오픈 소스 기초 모델은 지난 해 동안 급속히 발전했으며, Llama 3-405B는 현재의 비공개 최고 성능 모델과 경쟁할 수 있습니다. 최근에는 Mistral (Jiang et al., 2023), Falcon (Almazrouei et al., 2023), MPT (Databricks, 2024), Pythia (Biderman et al., 2023), Arctic (Snowflake, 2024), OpenELM (Mehta et al., 2024), OLMo (Groeneveld et al., 2024), StableLM (Bellagente et al., 2024), OpenLLaMA (Geng and Liu, 2023), Qwen (Bai et al., 2023), Gemma (Team et al., 2024), Grok (XAI, 2024), Phi (Abdin et al., 2024)와 같은 모델 가족이 개발되었습니다.

**후 훈련**: Llama 3의 후 훈련은 수백만 개의 인간 지시와 선호도 판단을 포함하여 사전 훈련된 모델을 개선하기 위해 거부 샘플링 (Bai et al., 2022), 지도 세부 튜닝 (Sanh et al., 2022), 직접 선호도 최적화 (Rafailov et al., 2023)와 같은 기술을 포함한 지시 튜닝 (Chung et al., 2022; Ouyang et al., 2022) 및 인간 피드백과의 조정을 따릅니다. 이러한 지시 및 선호 예제를 큐레이팅하기 위해, Llama 3의 초기 버전을 사용하여 필터링 (Liu et al., 2024c), 재작성 (Pan et al., 2024) 또는 프롬프트 및 응답을 생성 (Liu et al., 2024b)하고, 이를 여러 차례의 후 훈련을 통해 적용합니다.

### 9.2 멀티모달리티

Llama 3의 멀티모달 기능에 대한 실험은 여러 모달리티를 공동으로 모델링하는 기초 모델에 대한 오랜 연구의 일환입니다.

#### 이미지

대량의 이미지-텍스트 쌍을 훈련 데이터로 사용하는 이미지 인식 모델에 대한 연구가 상당히 많이 이루어졌습니다. 대표적인 연구로는 Mahajan et al. (2018), Xiao et al. (2024a), Team (2024), OpenAI (2023b)가 있습니다. Radford et al. (2021)은 대조 학습을 통해 이미지와 텍스트를 공동으로 임베딩한 최초의 모델 중 하나를 발표했습니다. 최근에는 Llama 3에서 사용된 접근 방식과 유사한 방법을 연구한 여러 모델이 등장했습니다. 예를 들어, Alayrac et al. (2022), Dai et al. (2023), Liu et al. (2023c, 2023b), Yang et al. (2023b), Ye et al. (2023), Zhu et al. (2023) 등이 있습니다. Llama 3의 접근 방식은 이러한 여러 논문의 아이디어를 결합하여 Gemini 1.0 Ultra (Google, 2023) 및 GPT-4 Vision (OpenAI, 2023b)과 비교할 만한 결과를 달성했습니다(섹션 7.6 참조).

#### 비디오

비디오 입력을 지원하는 기초 모델이 점점 더 많아지고 있지만(Google, 2023; OpenAI, 2023b), 비디오와 언어를 공동으로 모델링하는 연구는 아직 많지 않습니다. Llama 3와 유사하게, 대부분의 현재 연구는 비디오와 언어 표현을 맞추기 위해 어댑터 접근 방식을 채택하고 비디오에 대한 질문 응답 및 추론을 가능하게 합니다(Lin et al., 2023; Li et al., 2023a; Maaz et al., 2024; Zhang et al., 2023; Zhao et al., 2022). 이러한 접근 방식이 최첨단 기술과 경쟁할 수 있는 결과를 도출한다는 것을 발견했습니다(섹션 7.7 참조).

#### 음성

우리의 연구는 언어와 음성 모델링을 결합하는 더 큰 연구의 일환이기도 합니다. 초기의 텍스트와 음성을 공동으로 모델링한 모델로는 AudioPaLM (Rubenstein et al., 2023), VioLA (Wang et al., 2023b), VoxtLM (Maiti et al., 2023), SUTLM (Chou et al., 2023), Spirit-LM (Nguyen et al., 2024)가 있습니다. 우리의 연구는 Fathullah et al. (2024)과 같은 이전의 합성 접근 방식을 기반으로 음성과 언어를 결합합니다. 대부분의 이전 연구와 달리, 우리는 음성 작업에 대해 언어 모델 자체를 미세 조정하지 않기로 선택했습니다. 이는 비음성 작업에서의 경쟁을 초래할 수 있기 때문입니다. 더 큰 모델 규모에서는 이러한 미세 조정 없이도 강력한 성능을 달성할 수 있음을 발견했습니다(섹션 8.4 참조).

### 10 결론

고품질 기초 모델 개발은 여전히 초기 단계에 있습니다. Llama 3 개발 경험을 통해 이러한 모델의 상당한 개선 가능성이 있음을 알 수 있었습니다. Llama 3 모델 가족을 개발하는 동안 고품질 데이터, 확장성, 단순성에 강하게 집중하는 것이 일관되게 최고의 결과를 가져온다는 것을 발견했습니다. 초기 실험에서 더 복잡한 모델 아키텍처와 훈련 레시피를 탐구했지만, 이러한 접근 방식이 모델 개발에 추가 복잡성을 더하는 것에 비해 그 이점이 크지 않다는 결론에 도달했습니다.

Llama 3와 같은 대표적인 기초 모델을 개발하는 것은 많은 기술적 문제를 극복해야 할 뿐만 아니라, 현명한 조직적 결정도 필요합니다. 예를 들어, Llama 3가 일반적으로 사용되는 벤치마크에 과적합되지 않도록 하기 위해, 우리의 사전 훈련 데이터는 외부 벤치마크로 오염되지 않도록 강하게 유도된 별도의 팀에 의해 조달되고 처리되었습니다. 또 다른 예로, 우리의 인간 평가가 신뢰성을 유지하도록 모델 개발에 기여하지 않는 소수의 연구자들만이 이러한 평가를 수행하고 접근할 수 있도록 했습니다. 이러한 조직적 결정은 기술 논문에서 거의 논의되지 않지만, 우리는 이것이 Llama 3 모델 가족의 성공적인 개발에 중요한 역할을 한다고 생각합니다.

우리는 우리의 개발 과정을 공유함으로써: (1) 더 큰 연구 커뮤니티가 기초 모델 개발의 주요 요소를 이해하도록 돕고, (2) 일반 대중이 기초 모델의 미래에 대해 더 잘 알 수 있도록 기여할 수 있다고 믿습니다. 우리는 또한 Llama 3에 멀티모달 기능을 통합하는 초기 실험을 공유했습니다. 이러한 모델은 여전히 활발히 개발 중이며 아직 공개할 준비가 되지 않았지만, 우리의 결과를 조기에 공유함으로써 이 방향으로의 연구가 가속화되기를 바랍니다.

이 논문에서 제시된 상세한 안전 분석의 긍정적인 결과에 따라, 우리는 Llama 3 언어 모델을 공개하여 사회적으로 관련된 다양한 용도의 AI 시스템 개발을 가속화하고 연구 커뮤니티가 우리의 모델을 면밀히 검토하고 이러한 모델을 더 좋고 안전하게 만드는 방법을 식별할 수 있도록 합니다. 우리는 기초 모델의 공개가 이러한 모델의 책임 있는 개발에 중요한 역할을 한다고 믿으며, Llama 3의 공개가 산업계가 AGI의 개방적이고 책임 있는 개발을 수용하도록 장려하기를 바랍니다.

[452387774\_1036916434819166\_4173978747091533306\_n.pdf

8.79MB](./file/452387774_1036916434819166_4173978747091533306_n.pdf)

지표상으로 gpt-4o랑 sonnet 3.5 아직은 더 좋음
