---
title: "Parameter-Efficient Transfer Learning for NLP"
date: 2024-07-02 20:55:57
categories:
  - 인공지능
---

<https://arxiv.org/abs/1902.00751>

[Parameter-Efficient Transfer Learning for NLP](https://arxiv.org/abs/1902.00751)

### 초록

대규모 사전 학습된 모델을 미세 조정(fine-tuning)하는 것은 자연어 처리(NLP)에서 효과적인 전이 학습 메커니즘입니다. 그러나 많은 다운스트림 작업이 있을 때, 미세 조정은 매 작업마다 새로운 모델이 필요하여 매개변수 효율성이 떨어집니다. 이에 대한 대안으로, 우리는 어댑터 모듈을 사용한 전이를 제안합니다. 어댑터 모듈은 컴팩트하고 확장 가능한 모델을 제공합니다. 작업마다 몇 개의 학습 가능한 매개변수만 추가하며, 이전 작업을 다시 방문하지 않고도 새로운 작업을 추가할 수 있습니다. 원래 네트워크의 매개변수는 고정되어 있어 높은 수준의 매개변수 공유를 가능하게 합니다. 어댑터의 효과성을 입증하기 위해, 우리는 최근 제안된 BERT 트랜스포머 모델을 26개의 다양한 텍스트 분류 작업, 포함 GLUE 벤치마크에 전이 학습시켰습니다. 어댑터는 작업마다 몇 개의 매개변수만 추가하면서 거의 최첨단 성능을 달성했습니다. GLUE에서, 우리는 전체 미세 조정 성능에서 0.4% 이내의 성능을 달성하며, 작업마다 3.6%의 매개변수만 추가했습니다. 반면에, 미세 조정은 작업마다 100%의 매개변수를 학습시킵니다.

![](/assets/images/posts/188/img.png)

### 그림 1.

어댑터 조정과 미세 조정에 대해 작업별 매개변수 수와 정확도 간의 절충점. y축은 전체 미세 조정의 성능으로 정규화되었습니다. 자세한 내용은 3장에서 설명합니다. 곡선은 GLUE 벤치마크의 아홉 가지 작업에 대한 20, 50, 80 백분위수의 성능을 보여줍니다. 어댑터 기반 조정은 두 단계 더 적은 학습된 매개변수로 전체 미세 조정과 유사한 성능을 달성합니다.

### 1. 서론

사전 학습된 모델에서의 전이는 많은 NLP 작업에서 강력한 성능을 발휘합니다(Dai & Le, 2015; Howard & Ruder, 2018; Radford et al., 2018). BERT는 대규모 텍스트 코퍼스에서 비지도 학습 손실을 사용하여 학습된 트랜스포머 네트워크로, 텍스트 분류와 추출형 질문 응답에서 최첨단 성능을 달성했습니다(Devlin et al., 2018).

본 논문에서는 작업이 스트림 형태로 도착하는 온라인 설정에 대해 다룹니다. 목표는 각 새로운 작업에 대해 전체 새로운 모델을 학습하지 않고도 모든 작업에서 좋은 성능을 발휘하는 시스템을 구축하는 것입니다. 작업 간의 높은 공유도는 고객으로부터 연속적으로 도착하는 많은 작업을 해결해야 하는 클라우드 서비스와 같은 응용 프로그램에 특히 유용합니다. 이를 위해 우리는 컴팩트하고 확장 가능한 다운스트림 모델을 제공하는 전이 학습 전략을 제안합니다. 컴팩트한 모델은 작업마다 소수의 추가 매개변수를 사용하여 여러 작업을 해결하는 모델을 의미합니다. 확장 가능한 모델은 이전 작업을 잊지 않고 새로운 작업을 점진적으로 학습할 수 있는 모델입니다. 우리의 방법은 성능을 희생하지 않으면서 이러한 모델을 제공합니다.

NLP에서 가장 일반적인 두 가지 전이 학습 기법은 특징 기반 전이와 미세 조정입니다. 대신, 우리는 어댑터 모듈에 기반한 대체 전이 방법을 제시합니다(Rebuffi et al., 2017). 특징 기반 전이는 실수 값 임베딩 벡터를 사전 학습하는 것을 포함합니다. 이러한 임베딩은 단어(Mikolov et al., 2013), 문장(Cer et al., 2019) 또는 단락 수준(Le & Mikolov, 2014)일 수 있습니다. 그런 다음 이 임베딩을 맞춤형 다운스트림 모델에 입력합니다. 미세 조정은 사전 학습된 네트워크의 가중치를 복사하여 다운스트림 작업에 맞게 조정하는 것입니다. 최근 연구는 미세 조정이 특징 기반 전이보다 더 나은 성능을 발휘하는 경우가 많음을 보여줍니다(Howard & Ruder, 2018).

특징 기반 전이와 미세 조정 모두 각 작업에 대해 새로운 가중치 집합이 필요합니다. 네트워크의 하위 계층이 작업 간에 공유되는 경우 미세 조정이 더 매개변수 효율적입니다. 그러나 우리가 제안하는 어댑터 조정 방법은 훨씬 더 매개변수 효율적입니다. 그림 1은 이 절충점을 보여줍니다. x축은 작업당 학습된 매개변수의 수를 나타내며, 이는 각 추가 작업을 해결하는 데 필요한 모델 크기의 증가를 의미합니다. 어댑터 기반 조정은 미세 조정에 비해 두 단계 더 적은 매개변수를 학습하면서 유사한 성능을 달성합니다.

![](/assets/images/posts/188/img_1.png)

어댑터 기반 조정은 멀티 태스크 학습 및 연속 학습과 관련이 있습니다. 멀티 태스크 학습도 컴팩트한 모델을 결과로 가져오지만, 멀티 태스크 학습은 모든 작업에 동시에 접근할 수 있어야 하는 반면, 어댑터 기반 조정은 이를 요구하지 않습니다. 연속 학습 시스템은 끝없는 작업 스트림에서 학습하는 것을 목표로 합니다. 이 패러다임은 네트워크가 재학습 후 이전 작업을 잊어버리는 경향이 있기 때문에 도전적입니다(McCloskey & Cohen, 1989; French, 1999). 어댑터는 작업들이 상호작용하지 않고 공유 매개변수가 고정된다는 점에서 다릅니다. 이는 모델이 소수의 작업별 매개변수를 사용하여 이전 작업을 완벽히 기억할 수 있음을 의미합니다.

우리는 다양한 텍스트 분류 작업 세트에서 어댑터가 NLP에 대해 매개변수 효율적인 조정을 제공함을 입증합니다. 주요 혁신은 효과적인 어댑터 모듈을 설계하고 이를 기본 모델에 통합하는 것입니다. 우리는 간단하면서도 효과적인 병목 구조를 제안합니다. GLUE 벤치마크에서 우리의 전략은 전체 미세 조정된 BERT의 성능과 거의 맞먹으면서도 작업별 매개변수는 3%만 사용하며, 미세 조정은 100% 작업별 매개변수를 사용합니다. 우리는 추가로 17개의 공개 텍스트 데이터셋과 SQuAD 추출형 질문 응답에서도 유사한 결과를 관찰했습니다. 요약하면, 어댑터 기반 조정은 텍스트 분류에서 최첨단 성능에 가까운 단일 확장 가능한 모델을 제공합니다.

### 2. NLP를 위한 어댑터 조정

우리는 여러 다운스트림 작업에 대해 대규모 텍스트 모델을 조정하는 전략을 제시합니다. 우리의 전략은 세 가지 주요 속성을 가집니다:

1. 좋은 성능을 달성합니다.
2. 순차적으로 작업을 학습할 수 있으며, 모든 데이터셋에 동시에 접근할 필요가 없습니다.
3. 작업별로 소수의 추가 매개변수만 추가합니다.

이 속성들은 많은 모델이 일련의 다운스트림 작업에서 학습되어야 하는 클라우드 서비스의 맥락에서 특히 유용합니다. 높은 수준의 공유가 바람직하기 때문입니다.

이 속성을 달성하기 위해 우리는 새로운 병목 어댑터 모듈을 제안합니다. 어댑터 모듈을 사용한 조정은 모델에 소수의 새로운 매개변수를 추가하는 것으로, 이는 다운스트림 작업에서 학습됩니다(Rebuffi et al., 2017). 깊은 네트워크를 일반적인 미세 조정할 때, 네트워크의 최상위 층을 수정해야 합니다. 이는 상위 및 하위 작업의 레이블 공간과 손실이 다르기 때문입니다. 어댑터 모듈은 사전 학습된 네트워크를 다운스트림 작업에 재목적으로 사용할 수 있도록 더 일반적인 아키텍처 수정을 수행합니다. 특히 어댑터 조정 전략은 원래 네트워크에 새로운 층을 주입하는 것을 포함합니다. 원래 네트워크의 가중치는 건드리지 않으며, 새로운 어댑터 층은 무작위로 초기화됩니다. 표준 미세 조정에서는 새로운 최상위 층과 원래 가중치가 함께 학습됩니다. 반면에, 어댑터 조정에서는 원래 네트워크의 매개변수가 고정되어 있으며 따라서 많은 작업에서 공유될 수 있습니다.

어댑터 모듈은 두 가지 주요 특징을 가집니다: 소수의 매개변수와 거의 동일한 초기화입니다. 어댑터 모듈은 원래 네트워크의 층에 비해 작아야 합니다. 이는 더 많은 작업이 추가될 때 총 모델 크기가 상대적으로 천천히 증가함을 의미합니다. 안정적인 모델 학습을 위해 거의 동일한 초기화가 필요합니다. 우리는 이를 3.6장에서 경험적으로 조사합니다. 어댑터를 거의 동일한 함수로 초기화하면, 학습이 시작될 때 원래 네트워크는 영향을 받지 않습니다. 학습 중에 어댑터는 네트워크 전체에서 활성화 분포를 변경하기 위해 활성화될 수 있습니다. 어댑터 모듈은 필요하지 않으면 무시될 수도 있습니다; 3.6장에서 일부 어댑터가 네트워크에 다른 것들보다 더 많은 영향을 미친다는 것을 관찰합니다. 또한 초기화가 동일한 함수에서 너무 멀어지면 모델이 학습에 실패할 수 있음을 관찰합니다.

![](/assets/images/posts/188/img_2.png)

### 그림 2.

어댑터 모듈의 아키텍처와 이를 트랜스포머에 통합한 예시. 왼쪽: 우리는 트랜스포머의 각 층에 어댑터 모듈을 두 번 추가합니다: 다중 헤드 주의 후의 투영 뒤와 두 피드포워드 층 뒤. 오른쪽: 어댑터는 원래 모델의 주의 및 피드포워드 층에 비해 적은 매개변수를 포함하는 병목을 포함합니다. 어댑터는 또한 스킵 연결을 포함합니다. 어댑터 조정 동안, 녹색 층은 다운스트림 데이터에서 학습되며, 여기에는 어댑터, 층 정규화 매개변수, 최종 분류 층(그림에 표시되지 않음)이 포함됩니다.

### 2.1 트랜스포머 네트워크에 대한 구체화

우리는 텍스트 트랜스포머에 대한 어댑터 기반 조정을 구체화합니다. 이 모델들은 번역, 추출형 질문 응답, 텍스트 분류 문제 등 많은 NLP 작업에서 최첨단 성능을 발휘합니다(Vaswani et al., 2017; Radford et al., 2018; Devlin et al., 2018). 우리는 Vaswani et al. (2017)에서 제안한 표준 트랜스포머 아키텍처를 고려합니다. 어댑터 모듈은 많은 아키텍처 선택지를 제공합니다. 우리는 좋은 성능을 발휘하는 간단한 설계를 제공합니다. 우리는 여러 복잡한 설계로 실험을 진행했으며, 3.6장에서 이를 설명하지만, 다음 전략이 많은 데이터셋에서 다른 어떤 테스트한 전략만큼 잘 작동함을 발견했습니다. 그림 2는 우리의 어댑터 아키텍처와 이를 트랜스포머에 적용한 예시를 보여줍니다. 트랜스포머의 각 층은 두 가지 주요 서브 층을 포함합니다: 주의(attention) 층과 피드포워드(feedforward) 층. 두 층 모두 각 층의 입력 크기로 다시 매핑하는 투영(projection)이 바로 뒤따릅니다. 스킵 연결(skip-connection)이 각 서브 층에 적용됩니다. 각 서브 층의 출력은 층 정규화(layer normalization)로 전달됩니다. 우리는 각 서브 층 뒤에 두 개의 직렬 어댑터를 삽입합니다. 어댑터는 항상 투영 후, 스킵 연결을 추가하기 전 서브 층 출력에 직접 적용됩니다. 어댑터의 출력은 바로 다음 층 정규화로 전달됩니다.

매개변수 수를 제한하기 위해, 우리는 병목 아키텍처를 제안합니다. 어댑터는 원래의 d 차원 특징을 더 작은 차원 m으로 투영하고, 비선형성을 적용한 후, 다시 d 차원으로 투영합니다. 바이어스를 포함하여 각 층에 추가되는 매개변수의 총 수는 2md + d + m입니다. m을 d보다 작게 설정함으로써, 우리는 작업당 추가되는 매개변수의 수를 제한합니다; 실제로 우리는 원래 모델의 매개변수의 약 0.5 - 8%를 사용합니다. 병목 차원 m은 성능과 매개변수 효율성 간의 절충을 제공하는 간단한 수단입니다. 어댑터 모듈 자체는 내부적으로 스킵 연결을 가지고 있습니다. 스킵 연결을 통해, 투영 층의 매개변수가 거의 0에 가깝게 초기화되면, 모듈은 대략적인 동일 함수로 초기화됩니다.

어댑터 모듈의 층과 함께, 우리는 작업별로 새로운 층 정규화 매개변수도 학습합니다. 이 기술은 조건부 배치 정규화(De Vries et al., 2017), FiLM(Perez et al., 2018), 및 자기 조절(Chen et al., 2019)과 유사하게 네트워크의 매개변수 효율적인 적응을 제공합니다; 각 층당 2d 매개변수만으로 가능합니다. 그러나 층 정규화 매개변수만 학습하는 것은 좋은 성능을 내기에는 충분하지 않습니다. 이는 3.4장에서 설명합니다.

### 3. 실험

우리는 어댑터가 텍스트 작업에서 매개변수 효율적인 전이를 달성함을 보여줍니다. GLUE 벤치마크(Wang et al., 2018)에서 어댑터 조정은 BERT의 전체 미세 조정보다 0.4% 이내의 성능을 발휘하지만, 미세 조정에서 학습된 매개변수의 3%만 추가합니다. 우리는 이 결과를 추가로 17개의 공개 분류 작업과 SQuAD 질문 응답에서도 확인했습니다. 분석 결과 어댑터 기반 조정은 자동으로 네트워크의 상위 계층에 초점을 맞추는 것으로 나타났습니다.

### 3.1. 실험 설정

우리는 공공의 사전 학습된 BERT 트랜스포머 네트워크를 기본 모델로 사용합니다. BERT를 사용한 분류를 수행하기 위해, 우리는 Devlin et al. (2018)의 접근 방식을 따릅니다. 각 시퀀스의 첫 번째 토큰은 특별한 "분류 토큰"입니다. 우리는 이 토큰의 임베딩에 선형 층을 부착하여 클래스 레이블을 예측합니다.

우리의 학습 절차도 Devlin et al. (2018)을 따릅니다. 우리는 Adam(Kingma & Ba, 2014)을 사용하여 최적화하며, 학습률은 첫 10%의 단계 동안 선형적으로 증가한 후 선형적으로 0으로 감소합니다. 모든 실행은 배치 크기 32로 4개의 Google Cloud TPU에서 학습됩니다. 각 데이터셋과 알고리즘에 대해 우리는 하이퍼파라미터 탐색을 수행하고 검증 세트에서 정확도에 따라 최고의 모델을 선택합니다. GLUE 작업에 대해서는 제출 웹사이트에서 제공된 테스트 지표를 보고합니다. 다른 분류 작업에 대해서는 테스트 세트의 정확도를 보고합니다.

우리는 대규모 사전 학습된 모델의 전이 학습을 위한 현재 표준인 미세 조정과 비교합니다. 미세 조정은 BERT에 의해 성공적으로 사용된 전략입니다. N개의 작업에 대해, 전체 미세 조정은 사전 학습된 모델의 매개변수 수의 N배를 필요로 합니다. 우리의 목표는 전체 미세 조정과 동일한 성능을 달성하면서 총 매개변수를 줄이는 것입니다. 이상적으로는 1배에 가깝게 유지하는 것입니다.

![](/assets/images/posts/188/img_3.png)

### 표 1.

GLUE 테스트 세트에서 GLUE 평가 서버를 사용하여 점수를 매긴 결과. MRPC와 QQP는 F1 점수를 사용하여 평가됩니다. STS-B는 스피어만 상관 계수를 사용하여 평가됩니다. CoLA는 매튜 상관 계수를 사용하여 평가됩니다. 다른 작업들은 정확도를 사용하여 평가됩니다. 어댑터 조정은 전체 미세 조정(80.4)에 비해 1.3배의 매개변수로 전체 점수(80.0)와 비교 가능한 성능을 달성합니다. 어댑터 크기를 64로 고정하면 전체 점수는 약간 감소하여 79.6이 되고, 모델 크기는 약간 더 작아집니다.

![](/assets/images/posts/188/img_4.png)

![](/assets/images/posts/188/img_5.png)

![](/assets/images/posts/188/img_6.png)

**그림 3**: 작업별로 집계된 학습된 매개변수 수에 따른 정확도. 우리는 다양한 크기의 어댑터(오렌지)와 상위 n 개 층의 미세 조정(블루)을 비교합니다. 선과 음영 영역은 작업 전반에 걸쳐 20, 50, 80 백분위수를 나타냅니다. 각 작업과 알고리즘에 대해, 곡선의 각 지점에 대해 최상의 모델을 선택합니다. GLUE에서는 검증 세트 정확도를 보고합니다. 추가 작업에 대해서는 테스트 세트 정확도를 보고합니다. 점수의 작업 내 변동을 제거하기 위해, 해당 작업에 대한 전체 미세 조정의 성능을 빼서 각 모델과 작업의 점수를 정규화합니다.

![](/assets/images/posts/188/img_7.png)

**그림 4**: 세 가지 방법에 대한 학습된 매개변수 수에 따른 검증 세트 정확도: (i) 어댑터 크기 2^n에 따른 어댑터 조정(n=0...9, 오렌지), (ii) 상위 k 개 층의 미세 조정(k=1...12, 블루), (iii) 층 정규화 매개변수만 조정(그린). 오류 막대는 세 가지 랜덤 시드에서 ±1 표준 오차를 나타냅니다.

### 3.4. 매개변수/성능 절충

어댑터 크기는 매개변수 효율성을 제어하며, 더 작은 어댑터는 적은 매개변수를 도입하지만 성능에 영향을 미칠 수 있습니다. 이 절충을 탐구하기 위해, 우리는 다양한 어댑터 크기를 고려하고 두 가지 기준선과 비교합니다: (i) BERTBASE의 상위 k 개 층만 미세 조정, (ii) 층 정규화 매개변수만 조정. 학습률은 3.2장에서 제시한 범위를 사용하여 조정됩니다.

그림 3은 각 작업 모음(GLUE 및 "추가" 작업)에서 모든 분류 작업을 집계한 매개변수/성능 절충을 보여줍니다. GLUE에서는 적은 층을 미세 조정할 때 성능이 급격히 감소합니다. 일부 추가 작업은 적은 층을 학습하는 것이 이득이 되어, 미세 조정의 성능 감소가 훨씬 적습니다. 두 경우 모두, 어댑터는 미세 조정보다 두 단계 적은 매개변수로 좋은 성능을 발휘합니다.

그림 4는 두 개의 GLUE 작업: MNLIm과 CoLA에 대한 자세한 내용을 보여줍니다. 상위 층을 조정하는 것은 모든 k > 2에서 더 많은 작업별 매개변수를 학습합니다. 유사한 수의 작업별 매개변수를 사용하여 미세 조정할 때, 성능은 어댑터와 비교하여 크게 감소합니다. 예를 들어, 상위 층만 미세 조정하면 약 9M의 학습 가능한 매개변수와 MNLIm에서 77.8% ± 0.1%의 검증 정확도를 얻습니다. 반면, 크기 64의 어댑터 조정은 약 2M의 학습 가능한 매개변수와 83.7% ± 0.1%의 검증 정확도를 얻습니다. 비교를 위해, 전체 미세 조정은 MNLIm에서 84.4% ± 0.02%를 달성합니다. CoLA에서도 유사한 경향을 관찰합니다.

또 다른 비교로, 우리는 층 정규화 매개변수만 조정합니다. 이 층들은 점별 추가 및 곱셈만 포함하므로 매우 적은 학습 가능한 매개변수를 도입합니다: BERTBASE의 경우 40k. 그러나 이 전략은 성능이 떨어집니다: CoLA에서 약 3.5%, MNLI에서 약 4% 감소합니다.

요약하면, 어댑터 조정은 매우 매개변수 효율적이며, 전체 미세 조정과 비교할 만한 강력한 성능을 가진 컴팩트한 모델을 생성합니다. 원래 모델의 0.5-5% 크기의 어댑터를 학습시키면, 성능은 BERTLARGE에 대한 경쟁력 있는 출판 결과에서 1% 이내로 유지됩니다.

![](/assets/images/posts/188/img_8.png)

**그림 5**: SQuAD v1.1에 대한 학습된 매개변수 수에 따른 검증 정확도. 오류 막대는 세 개의 시드에서 s.e.m.을 나타내며, 최적의 하이퍼파라미터를 사용합니다.

![](/assets/images/posts/188/img_9.png)

어댑터 크기가 2 (0.1% 매개변수)인 경우에도 SQuAD는 89.9의 F1 점수를 달성하며, 크기 64 (2% 매개변수)인 어댑터는 최고 F1 점수 90.7을 달성합니다.

![](/assets/images/posts/188/img_10.png)

추가 분류 작업에 대한 테스트 정확도. 이 실험에서는 BERTBASE 모델에서 전이 학습을 수행합니다. 각 작업 및 알고리즘에 대해 검증 세트 정확도가 가장 높은 모델을 선택합니다. 우리는 서로 다른 랜덤 시드를 사용한 실행에서 평균 테스트 정확도와 표준 오차를 보고합니다.

![](/assets/images/posts/188/img_11.png)

**그림 6**: 왼쪽, 중앙: 연속적인 층 범위에서 학습된 어댑터를 절제한 결과. 히트맵은 완전히 학습된 적응 모델에 대한 검증 정확도의 상대적 감소를 보여줍니다. y축과 x축은 각각 절제된 첫 번째와 마지막 층을 나타냅니다. 녹색으로 강조된 대각선 셀은 단일 층의 어댑터 절제를 나타냅니다. 오른쪽 상단 셀은 모든 어댑터를 절제한 경우를 나타냅니다. 하단 삼각형의 셀은 의미가 없으므로 0%로 설정됩니다. 오른쪽: 초기 가중치 크기가 다른 어댑터를 사용하는 BERTBASE의 성능. x축은 초기화 분포의 표준 편차를 나타냅니다.

### 3.6 분석 및 논의

우리는 어떤 어댑터가 영향력이 있는지를 결정하기 위해 절제 실험을 수행했습니다. 이를 위해, 일부 학습된 어댑터를 제거하고 검증 세트에서 모델을 재평가했습니다(재훈련 없이). 그림 6은 모든 연속적인 층 범위에서 어댑터를 제거할 때의 성능 변화를 보여줍니다. 이 실험은 MNLI와 CoLA에서 어댑터 크기 64를 사용한 BERTBASE에서 수행되었습니다.

먼저, 단일 층의 어댑터를 제거하는 것이 성능에 미치는 영향은 작다는 것을 관찰했습니다. 히트맵의 대각선 요소는 단일 층에서 어댑터를 제거할 때의 성능을 보여주며, 가장 큰 성능 저하는 2%였습니다. 대조적으로, 네트워크에서 모든 어댑터를 제거하면 성능이 크게 감소합니다: MNLI에서 37%, CoLA에서 69%로 떨어지며, 이는 다수 클래스 예측으로 얻은 점수입니다. 이는 각 어댑터가 전체 네트워크에 미치는 영향은 작지만, 전체 효과는 크다는 것을 나타냅니다.

둘째, 그림 6은 하위 층의 어댑터가 상위 층보다 영향을 덜 미친다는 것을 시사합니다. MNLI에서 0-4층의 어댑터를 제거해도 성능에 거의 영향을 미치지 않습니다. 이는 어댑터가 상위 층을 자동으로 우선시하기 때문에 잘 작동한다는 것을 나타냅니다. 실제로 상위 층에 집중하는 것은 미세 조정에서 인기 있는 전략입니다(Howard & Ruder, 2018). 한 가지 직관은 하위 층이 작업 간에 공유되는 하위 수준의 특징을 추출하는 반면, 상위 층은 다른 작업에 고유한 특징을 구축한다는 것입니다. 이는 일부 작업에 대해 상위 층만 미세 조정하는 것이 전체 미세 조정보다 더 나은 성능을 발휘한다는 우리의 관찰과 관련이 있습니다(표 2 참조).

다음으로, 우리는 뉴런 수와 초기화 규모에 대한 어댑터 모듈의 견고성을 조사했습니다. 주요 실험에서 어댑터 모듈의 가중치는 표준 편차가 10^-2인 평균이 0인 가우시안 분포에서 추출되었으며, 두 표준 편차로 절단되었습니다. 성능에 대한 초기화 규모의 영향을 분석하기 위해, 우리는 표준 편차를 [10^-7, 1] 범위에서 테스트했습니다. 그림 6은 결과를 요약합니다. 두 데이터셋 모두에서 어댑터의 성능은 표준 편차가 10^-2 이하인 경우 견고합니다. 그러나 초기화가 너무 크면 성능이 저하되며, 특히 CoLA에서 더 크게 나타납니다.

뉴런 수에 대한 어댑터의 견고성을 조사하기 위해, 우리는 3.2장의 실험 데이터를 다시 검토했습니다. 어댑터 크기 전반에 걸쳐 모델의 품질은 안정적이며, 모든 작업에 대해 고정된 어댑터 크기를 사용할 수 있으며 성능에 약간의 손해만 발생합니다. 각 어댑터 크기에 대해, 우리는 최적의 학습률과 에포크 수를 선택하여 여덟 개의 분류 작업 전반에 걸쳐 평균 검증 정확도를 계산했습니다. 어댑터 크기 8, 64, 256의 평균 검증 정확도는 각각 86.2%, 85.8%, 85.7%입니다. 이는 그림 4와 5에서 몇 가지 순서의 크기에서도 안정적인 성능을 보여주는 메시지를 더욱 확인해줍니다.

마지막으로, 성능을 크게 향상시키지 않는 어댑터의 아키텍처에 대한 여러 확장을 시도했습니다. 여기서는 완전성을 위해 이를 문서화합니다. 우리는 (i) 어댑터에 배치/층 정규화를 추가, (ii) 어댑터 당 층 수를 증가, (iii) tanh와 같은 다양한 활성화 함수, (iv) 주의층 내부에만 어댑터 삽입, (v) 주요 층과 병렬로 어댑터를 추가하고, 경우에 따라 곱셈 상호작용을 포함하는 실험을 진행했습니다. 모든 경우에, 결과 성능은 2.1장에서 제안한 병목과 유사했습니다. 따라서, 그 단순성과 강력한 성능 때문에, 우리는 원래 어댑터 아키텍처를 권장합니다.

### 4. 관련 연구

#### 사전 학습된 텍스트 표현

사전 학습된 텍스트 표현은 NLP 작업의 성능을 향상시키기 위해 널리 사용됩니다. 이러한 표현은 대규모 코퍼스(주로 비지도 학습)에서 학습되며, 다운스트림 모델의 특징으로 사용됩니다. 딥 네트워크에서는 이러한 특징들이 다운스트림 작업에서 미세 조정될 수도 있습니다. 분포적 정보를 기반으로 학습된 Brown 클러스터는 사전 학습된 표현의 고전적인 예입니다(Brown et al., 1992). Turian et al. (2010)은 단어의 사전 학습된 임베딩이 처음부터 학습된 임베딩보다 뛰어나다는 것을 보여줍니다. 딥 러닝이 인기를 끌면서, 단어 임베딩은 널리 사용되었고, 많은 학습 전략이 등장했습니다(Mikolov et al., 2013; Pennington et al., 2014; Bojanowski et al., 2017). 더 긴 텍스트, 문장 및 단락의 임베딩도 개발되었습니다(Le & Mikolov, 2014; Kiros et al., 2015; Conneau et al., 2017; Cer et al., 2019).

이러한 표현에서 문맥을 인코딩하기 위해, 특징은 MT 시스템(McCann et al., 2017)과 ELMo(Peters et al., 2018)에서 사용된 BiLSTM 언어 모델과 같은 시퀀스 모델의 내부 표현에서 추출됩니다. 어댑터와 마찬가지로, ELMo는 사전 학습된 네트워크의 상위 층이 아닌 다른 층을 활용합니다. 그러나 이 전략은 내부 층에서 읽기만 합니다. 대조적으로, 어댑터는 내부 층에 쓰기(write)하여 전체 네트워크를 통해 특징 처리를 재구성합니다.

#### 미세 조정

사전 학습된 전체 모델을 미세 조정하는 것은 특징 기반 전이의 인기 있는 대안이 되었습니다(Dai & Le, 2015; Howard & Ruder, 2018; Radford et al., 2018). NLP에서는 상위 모델이 보통 신경 언어 모델입니다(Bengio et al., 2003). 최근 질문 응답(Rajpurkar et al., 2016)과 텍스트 분류(Wang et al., 2018)에서의 최첨단 결과는 Masked Language Model 손실(Devlin et al., 2018)을 사용한 트랜스포머 네트워크(Vaswani et al., 2017)의 미세 조정을 통해 달성되었습니다. 성능을 제외하고, 미세 조정의 장점은 작업별 모델 설계를 요구하지 않는다는 점입니다. 그러나 기본 미세 조정은 새로운 작업마다 새로운 네트워크 가중치 집합이 필요합니다.

#### 멀티 태스크 학습

멀티 태스크 학습(MTL)은 작업을 동시에 학습하는 것을 포함합니다. 초기 연구는 작업 간 네트워크 매개변수를 공유하면 작업의 규칙성을 활용하여 성능이 향상된다는 것을 보여줍니다(Caruana, 1997). 연구자들은 네트워크의 하위 층에서 가중치를 공유하고, 상위 층에서는 특화된 층을 사용합니다. 많은 NLP 시스템이 MTL을 활용했습니다. 일부 예로는 텍스트 처리 시스템(품사 태깅, 청킹, 명명된 개체 인식 등)(Collobert & Weston, 2008), 다국어 모델(Huang et al., 2013), 의미 파싱(Peng et al., 2017), 기계 번역(Johnson et al., 2017), 질문 응답(Choi et al., 2017)이 있습니다. MTL은 모든 문제를 해결하기 위한 단일 모델을 제공합니다. 그러나 우리의 어댑터와 달리, MTL은 학습 중 작업에 대한 동시 접근이 필요합니다.

#### 연속 학습

동시 학습의 대안으로, 연속 또는 평생 학습은 작업의 연속에서 학습하는 것을 목표로 합니다(Thrun, 1998). 그러나 재학습될 때, 딥 네트워크는 이전 작업 수행 방법을 잊어버리는 경향이 있습니다; 이를 "catastrophic forgetting"이라고 합니다(McCloskey & Cohen, 1989; French, 1999). 망각을 완화하기 위한 기술이 제안되었으나(Kirkpatrick et al., 2017; Zenke et al., 2017), 어댑터와 달리 기억은 완벽하지 않습니다. 프로그레시브 네트워크는 각 작업에 대해 새로운 네트워크 "열(column)"을 인스턴스화하여 망각을 피합니다(Rusu et al., 2016). 그러나 매개변수 수는 작업 수에 따라 선형적으로 증가합니다. 어댑터는 매우 작기 때문에 우리의 모델은 훨씬 더 유리하게 확장됩니다.

#### 비전(컴퓨터 비전)에서의 전이 학습

ImageNet (Deng et al., 2009)에서 사전 학습된 모델을 미세 조정하는 것은 이미지 인식 모델을 구축할 때 흔히 사용됩니다(Yosinski et al., 2014; Huh et al., 2016). 이 기술은 분류(Kornblith et al., 2018), 세부 분류(Hermans et al., 2017), 분할(Long et al., 2015), 감지(Girshick et al., 2014)를 포함한 많은 비전 작업에서 최첨단 성능을 달성합니다. 비전에서는 컨볼루션 어댑터 모듈이 연구되었습니다(Rebuffi et al., 2017; 2018; Rosenfeld & Tsotsos, 2018). 이러한 연구들은 ResNet(He et al., 2016) 또는 VGG 네트워크(Simonyan & Zisserman, 2014)에 작은 컨볼루션 층을 추가하여 여러 도메인에서 점진적 학습을 수행합니다. 어댑터 크기는 일반적으로 3 × 3 컨볼루션을 사용하는 원래 네트워크에 비해 1 × 1 컨볼루션을 사용하여 제한됩니다. 이는 작업당 전체 모델 크기가 11% 증가하게 합니다. 커널 크기를 더 줄일 수 없기 때문에 추가적인 절감 효과를 얻기 위해 다른 가중치 압축 기술이 필요합니다. 우리의 병목 어댑터는 훨씬 작을 수 있으며, 여전히 좋은 성능을 발휘합니다.

#### 동시 연구

동시 연구에서는 BERT에 대해 유사한 아이디어를 탐구합니다(Stickland & Murray, 2019). 저자들은 우리의 어댑터와 유사한 역할을 하는 작은 층인 Projected Attention Layers (PALs)를 도입합니다. 주요 차이점은 i) Stickland & Murray (2019)가 다른 아키텍처를 사용하고, ii) GLUE 작업 전체에서 BERT를 공동으로 미세 조정하는 멀티태스크 학습을 수행한다는 점입니다. Sina Semnani (2019)는 SQuAD v2.0 (Rajpurkar et al., 2018)에서 우리의 병목 어댑터와 PALs를 실험적으로 비교합니다.

### 감사의 말

우리는 Andrey Khorlin, Lucas Beyer, Noé Lutz, 그리고 Jeremiah Harmsen에게 유용한 의견과 토론에 대해 감사를 표합니다.

[1902.00751v2.pdf

0.83MB](./file/1902.00751v2.pdf)
