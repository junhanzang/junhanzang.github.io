---
title: "Chapter 5 RNN, LSTM, GRU"
date: 2023-05-19 21:46:51
categories:
  - 인공지능
tags:
  - gru
  - RNN
  - LSTM
  - Sequence Modeling
  - Bidirectional LSTM
---

지금까지는 이미지 처리에 중점을 두고 있는 NN에 대해서 알아보았다. 세상에는 많은 데이터가 존재하고 이미지만 데이터가 아닐 것이다. 우리는 가계부나 증권의 오르내림과 같은 순차적인 데이터 처리도 해야한다. 이를 위해서 나온 것이 RNN (Recurrent Neural Network)이다.

기존 CNN은 고정된 입력 크기를 가지고 있어 동적인 데이터 처리에는 제한이 있으며, 이를 해결하기 위해 RNN이 나왔다.

다음은 RNN의 일반적인 형태이다.

![](/assets/images/posts/68/img.png)

이를 어떻게 사용하는지가 더 중요하고 하지만 RNN에 대해서 간단하게 설명하겠다.

RNN은 순차적인 데이터나 시계열 데이터와 같이 시간적인 의존성을 가지는 데이터를 처리하는 데 사용되는 인공 신경망의 한 종류이다. RNN은 입력 데이터의 현재 상태뿐만 아니라 이전 상태를 고려하여 출력을 생성하는 동적인 모델로써, 순차적인 패턴과 시계열 데이터의 특성을 모델링하는 데 적합하다.

RNN의 특징과 작동 방식은 다음과 같다:

1. 순환 구조: RNN은 순환 구조를 가지며, 시간 단계마다 이전 상태의 정보가 현재 상태에 전달됩니다. 이러한 순환 구조를 통해 RNN은 이전 상태에 의존하는 정보를 저장하고 활용할 수 있습니다.
2. 은닉 상태: RNN은 은닉 상태(hidden state)라고 불리는 메모리 요소를 가지고 있습니다. 은닉 상태는 이전 상태의 정보를 기억하고 현재 입력과 결합하여 출력을 생성하는 데 사용됩니다.
3. 시퀀스 처리: RNN은 시퀀스 데이터를 처리할 수 있습니다. 각 시간 단계마다 입력을 받고, 이전 상태와 결합하여 새로운 은닉 상태를 생성합니다. 이 과정은 시퀀스의 길이에 상관없이 반복적으로 수행됩니다.
4. 파라미터 공유: RNN은 각 시간 단계에서 동일한 가중치와 편향을 공유합니다. 이는 모델의 학습 가능한 파라미터 수를 줄이고, 데이터의 시간적인 구조를 잘 모델링하는 데 도움을 줍니다.

RNN은 자연어 처리, 기계 번역, 음성 인식, 음악 생성 등과 같은 다양한 분야에서 사용된다. 예를 들어, 자연어 처리에서 RNN은 문장을 단어 단위로 처리하고, 단어 간의 시퀀스에 대한 의미를 파악하여 문장을 생성하거나 분류 작업을 수행한다. 또한, 시계열 데이터에서는 RNN이 다음 값의 예측, 패턴 인식, 시계열 분류 등에 사용된다.

![](/assets/images/posts/68/img.gif)

RNN

위의 그림처럼 정보 전달을 통해 O5까지 정보들이 전달되는 것을 확인할 수 있다. 여기서 X2, X3, X4, X5 값은 O1, O2, O3, O4가 들어가서 추가적인 정보가 전달 될 수 있다.

Long Term Dependency

Long Term Dependency는 X1~X(t-1)이 과거의 정보를 가지고 있는 h(t-1)에 encode되며, Xt를 처리하는 컨텍스트다.

그림으로 보는게 더 간단할 것이다.

![](/assets/images/posts/68/img_1.png)

Long Term Dependency of Standard RNN

Long Term Dependency of Standard RNN은 기본 RNN 구조의 특성 때문에 발생하는 현상으로 장기 의존성의 문제로 그래디언트 소실 문제(vanishing gradient problem)와 그래디언트 폭주 문제(exploding gradient problem)와 관련이 있다. 그래디언트 소실 문제는 역전파(backpropagation) 과정에서 그래디언트가 시간 단계를 거치면서 지수적으로 작아져서, 초기 시간 단계로 역전파되는 데 어려움을 겪는 현상을 말한다. 반면, 그래디언트 폭주 문제는 그래디언트가 지수적으로 커져서 네트워크의 가중치가 발산하거나 수렴하지 않는 현상을 말한다.   
  
이러한 그래디언트 소실과 그래디언트 폭주 문제로 인해 기본 RNN은 장기 의존성을 제대로 학습하기 어렵다. 장기 의존성이 큰 경우, 이전 시간 단계에서의 정보가 현재 시간 단계로 전파되는 동안 그래디언트가 지수적으로 작아지거나 커져서 그 정보를 적절히 전달할 수 없게 된다. 이로 인해 모델이 장기 의존성을 올바르게 학습하지 못하고, 장기 의존성이 필요한 작업에서 성능이 저하될 수 있다.

다음 그림의 색의 옅어짐이 정보의 옅어짐으로 보면 된다.

![](/assets/images/posts/68/img_2.png)

기본 형태의 RNN은 최대 10 단계 정도까지만 정보 전달이 가능하며, 이후에는 거의 망가진다. 이를 해결하기 위해서 Long Short-Term Memory(LSTM)이 나왔다.

LSTM

LSTM (Long Short-Term Memory)은 장기 의존성 문제를 해결하고 긴 시간적 의존성을 처리할 수 있는 RNN (Recurrent Neural Network)의 한 종류다. LSTM은 기본 RNN의 한계를 극복하기 위해 제안된 발전된 구조로, 시계열 데이터와 순차적인 데이터 처리에 특히 유용하다.

LSTM의 구조와 작동 방식은 다음과 같다:

1. 셀 상태 (Cell State):
   - LSTM은 기본 RNN과 달리 은닉 상태(hidden state) 외에 셀 상태(cell state)라는 메모리 셀을 가지고 있습니다.
   - 셀 상태는 정보를 장기적으로 기억하고 전달하는 역할을 수행합니다.
2. 게이트 메커니즘 (Gate Mechanism):
   - LSTM은 게이트 메커니즘을 도입하여 그래디언트의 흐름을 제어합니다.
   - LSTM은 입력 게이트(input gate), 삭제 게이트(forget gate), 출력 게이트(output gate) 등의 게이트를 가지고 있습니다.
   - 입력 게이트는 어떤 정보를 업데이트할지 결정하고, 삭제 게이트는 어떤 정보를 기억에서 삭제할지 결정하며, 출력 게이트는 어떤 정보를 출력으로 전달할지 결정합니다.
3. 장기 의존성 처리:
   - LSTM은 셀 상태를 통해 장기 의존성을 처리합니다.
   - 셀 상태는 시간 단계를 거치며 정보를 추가하거나 삭제하여 업데이트됩니다.
   - 게이트 메커니즘을 통해 어떤 정보를 추가하고 어떤 정보를 삭제할지를 결정하며, 이를 통해 장기적인 의존성을 학습하고 유지할 수 있습니다.

LSTM은 자연어 처리, 기계 번역, 음성 인식, 음악 생성 등 다양한 분야에서 사용된다. LSTM은 기본 RNN보다 더 긴 시간적 의존성을 처리할 수 있으며, 장기 의존성이 필요한 작업에서 더 우수한 성능을 제공한다. LSTM의 구조와 게이트 메커니즘을 통해 장기 의존성을 처리하고, 중요한 정보를 기억하면서도 불필요한 정보를 잊어버릴 수 있는 강력한 모델을 제공한다.

LSTM을 설명하는 많은 구조가 있지만 다음의 구조를 통해 설명하고자 한다.

![](/assets/images/posts/68/img_3.png)

i는 input gate, f는 forget gate, o는 output gate, g는 self-recurrent(자체 반복), c는 internal memory, y는 final output이다.

LSTM의 구조를 빗대어 설명하겠다:

1. 입력 게이트 (i):
   - 입력 게이트는 현재 입력과 이전 은닉 상태를 기반으로 어떤 정보를 업데이트할지를 결정합니다.
   - 입력 게이트는 시그모이드 함수를 통과한 값으로, 0과 1 사이의 범위를 가지며 각 입력의 중요도를 제어합니다.
2. 삭제 게이트 (f):
   - 삭제 게이트는 이전 셀 상태의 정보 중 어떤 정보를 삭제할지를 결정합니다.
   - 삭제 게이트는 시그모이드 함수를 통과한 값으로, 0과 1 사이의 범위를 가지며 이전 셀 상태의 어떤 정보를 유지할지를 제어합니다.
3. 출력 게이트 (o):
   - 출력 게이트는 현재 입력과 이전 은닉 상태를 기반으로 어떤 정보를 출력으로 전달할지를 결정합니다.
   - 출력 게이트는 시그모이드 함수를 통과한 값으로, 0과 1 사이의 범위를 가지며 현재 셀 상태의 어떤 정보를 출력으로 전달할지를 제어합니다.
4. 자체 반복 (g):
   - 자체 반복은 현재 입력과 이전 은닉 상태를 기반으로 현재 셀 상태를 업데이트하는 데 사용됩니다.
   - 자체 반복은 하이퍼볼릭 탄젠트(tanh) 함수를 통과한 값으로, -1과 1 사이의 범위를 가지며 현재 셀 상태의 잠재적인 값을 계산합니다.
5. 내부 메모리 (c):
   - 내부 메모리는 이전 셀 상태에 현재 셀 상태를 업데이트하여 장기 의존성을 기억하는 데 사용됩니다.
   - 내부 메모리는 입력 게이트와 자체 반복을 곱하고, 삭제 게이트와 이전 셀 상태를 곱한 값과 합산됩니다.
6. 최종 출력 (y):
   - 최종 출력은 출력 게이트와 현재 셀 상태를 곱한 값으로, 현재 시간 단계의 정보를 최종 출력으로 전달합니다.

이렇게 다양한 요소들이 함께 동작하여 LSTM은 장기 의존성을 처리하고, 정보를 기억하고 전달하며, 적절한 출력을 생성하는 강력한 모델로 작동한다. LSTM은 기본 RNN보다 장기 의존성 문제를 해결하고 더 긴 시간적 의존성을 처리할 수 있는 구조를 제공한다.

학습은 어떻게 진행될까?

![](/assets/images/posts/68/img_4.png)

LSTM 학습 flow

ct에서 ct-1로의 역전파는 f에 의한 요소별(elementwise) 곱셈만 수행하고, W에 의한 행렬 곱셈은 수행하지 않는다.

맨 위의 c(internal memory)를 통해 역전파가 흘러간다. 즉, 여러개가 겹치면 다음과 같이 나온다.

![](/assets/images/posts/68/img_5.png)

LSTM은 연산량이 너무 많다. 그렇다면 이를 줄일 수 있을까?

위에 대한 대답으로 GRU가 탄생하였다.

GRU(Gated Recurrent Unit)는 2014년 뉴욕대학교 조경현 교수님이 집필한 논문에서 제안되었다. GRU는 LSTM의 장기 의존성 문제에 대한 해결책을 유지하면서, 은닉 상태를 업데이트하는 계산을 줄였다. 다시 말해서, GRU는 성능은 LSTM과 유사하면서 복잡했던 LSTM의 구조를 간단화 시켰다.

GRU의 구조는 다음과 같다.

![](/assets/images/posts/68/img_6.png)

여기서 r은 Reset Gate, z는 Update Gate, y는 output이다.

GRU의 구조와 작동 방식은 다음과 같다:

1. 업데이트 게이트 (Update Gate):
   - GRU는 업데이트 게이트라는 게이트를 도입하여 은닉 상태를 업데이트하는 데 사용합니다.
   - 업데이트 게이트는 현재 입력과 이전 은닉 상태를 기반으로 현재 은닉 상태를 얼마나 업데이트할지를 결정합니다.
   - 시그모이드 함수를 통과한 값으로, 0과 1 사이의 범위를 가지며 각 요소의 중요도를 제어합니다.
2. 리셋 게이트 (Reset Gate):
   - GRU는 리셋 게이트라는 게이트를 도입하여 이전 은닉 상태의 어떤 정보를 잊을지를 결정합니다.
   - 리셋 게이트는 현재 입력과 이전 은닉 상태를 기반으로 이전 은닉 상태의 어떤 정보를 삭제할지를 결정합니다.
   - 시그모이드 함수를 통과한 값으로, 0과 1 사이의 범위를 가지며 이전 은닉 상태의 어떤 정보를 유지할지를 제어합니다.
3. 새로운 은닉 상태 계산:
   - GRU는 새로운 은닉 상태를 계산하는 데 사용되는 게이트를 가지고 있습니다.
   - 업데이트 게이트와 리셋 게이트를 사용하여 현재 입력과 이전 은닉 상태의 정보를 결합하여 새로운 은닉 상태를 생성합니다.
   - 현재 입력과 이전 은닉 상태를 결합한 값은 하이퍼볼릭 탄젠트(tanh) 함수를 통과한 후, 업데이트 게이트와 곱셈과 리셋 게이트와의 조합으로 계산됩니다.

일반적으로 데이터 양이 적을 때는 매개 변수의 양이 적은 GRU가 조금 더 낫고, 데이터 양이 더 많으면 LSTM이 더 낫다고도 한다.

우리는 지금까지 RNN, LSTM, GRU의 모델에 대해서 설명했다. 그렇다면 이것을 유용하게 사용하는 방법으로는 무엇이 있을까?

순차적인 데이터나 시계열 데이터를 다루고 모델링하는 기술이나 접근 방식을 Sequence Modeling이라고 한다. 이는 주어진 시퀀스의 패턴을 이해하고 예측하거나 생성하는 작업을 포함한다.

시퀀스 모델링은 다양한 분야에서 활용된다. 예를 들면:

1. 자연어 처리 (Natural Language Processing, NLP): 문장 또는 문서의 의미 파악, 기계 번역, 질의 응답 시스템, 감성 분석 등에서 시퀀스 모델링이 중요한 역할을 합니다.
2. 음성 인식 (Speech Recognition): 음성 입력을 텍스트로 변환하는 작업에서 시퀀스 모델링은 음성의 시간적인 특성을 모델링하고 음소 또는 단어의 시퀀스를 예측합니다.
3. 음악 생성: 음악은 시간적인 연속성을 가지는 시퀀스로 볼 수 있으며, 시퀀스 모델링은 음악의 구조와 패턴을 학습하여 새로운 음악을 생성하는 데 사용됩니다.
4. 동영상 분류: 비디오 프레임의 연속성을 모델링하여 동영상의 내용을 분류하는 작업에서 시퀀스 모델링이 활용됩니다.

이를 활용하는 Sequence Modeling에 대해서 알아보자.

Sequential Data Modeling으로는 Next Step Prediction, Classification, Sequence Generation, Machine Translation, Speech Recognition, Image Caption Generation이 있다.

![](/assets/images/posts/68/img_7.png)

Sequential Data Modeling

![](/assets/images/posts/68/img_8.png)

Sequential Data Modeling

Types of Processes로는 one to many, many to one, many to many, synched many to many가 있다.

![](/assets/images/posts/68/img_9.png)

one&nbsp;to&nbsp;many

![](/assets/images/posts/68/img_10.png)

many to one

![](/assets/images/posts/68/img_11.png)

many to many

![](/assets/images/posts/68/img_12.png)

synched many to many

Sequential Data Modeling은 결국 Types of Processes 안에 포함되기 때문에 Types of Processes를 이해하면 Sequential Modeling을 이해하는 것과 같다.

One to Many는 하나의 입력 시퀀스에 대해 여러 개의 출력 시퀀스를 생성하는 작업을 말한다. 이는 주어진 입력에 대해 다양한 형태의 출력을 생성하는 다양한 응용 분야에서 사용된다.  
예를 들어, 자연어 처리에서 One to Many 작업은 문장을 입력으로 받아 문장의 다음 단어를 예측하거나, 이미지 캡셔닝에서 이미지를 입력으로 받아 이미지에 대한 설명 문장을 생성하는 작업 등을 포함할 수 있다.

One to Many 작업의 훈련과 테스트는 다음과 같이 수행된다:

1. Training (훈련):
   - 훈련 단계에서는 입력 시퀀스와 해당하는 출력 시퀀스 쌍을 사용하여 모델을 학습시킵니다.
   - 입력 시퀀스와 출력 시퀀스의 길이는 다를 수 있으며, 출력 시퀀스의 길이는 가변적일 수 있습니다.
   - 모델은 입력 시퀀스를 처리하고, 적절한 컨텍스트를 학습하여 다양한 출력 시퀀스를 생성할 수 있도록 훈련됩니다.
2. Testing (테스트):
   - 테스트 단계에서는 훈련된 모델을 사용하여 새로운 입력 시퀀스에 대한 출력 시퀀스를 생성합니다.
   - 입력 시퀀스가 주어지면, 모델은 해당 입력에 대한 컨텍스트를 이용하여 다양한 출력 시퀀스를 생성합니다.
   - 출력 시퀀스의 길이는 모델의 아키텍처나 작업의 요구에 따라 다를 수 있습니다.

One to Many 작업은 입력 시퀀스와 출력 시퀀스 간의 시간적인 의존성을 모델링해야 한다. 이를 위해 RNN (Recurrent Neural Network)이나 그 변형인 LSTM (Long Short-Term Memory) 또는 GRU (Gated Recurrent Unit)와 같은 모델 아키텍처를 사용하여 시퀀스 데이터의 특성을 잘 처리할 수 있도록 한다.

Training과 Testing의 그림은 더보기에 추가했다.

![](/assets/images/posts/68/img_13.png)

![](/assets/images/posts/68/img_14.png)

![](/assets/images/posts/68/img_15.png)

![](/assets/images/posts/68/img_16.png)

결국 one to many의 training은 추가적인 input이 없이 output y를 사용하여 목표점 E에 도달하는 것을 말한다. Testing은 output을 y의 값들을 사용해서 이를 확인할 수 있다는 것을 보여주는 것이다.

Many to One은 여러 개의 입력 시퀀스에 대해 하나의 출력을 생성하는 작업을 말한다. 이는 다양한 입력 시퀀스를 처리하여 단일 출력을 예측하거나 분류하는 작업에서 사용된다.  
예를 들어, 감성 분석에서 Many to One 작업은 문장이나 문서의 여러 개의 단어를 입력으로 받아 해당 문장이 긍정적인지 혹은 부정적인지를 분류하는 작업을 포함할 수 있다.

Many to One 작업의 훈련과 테스트는 다음과 같이 수행된다:

1. Training (훈련):
   - 훈련 단계에서는 다수의 입력 시퀀스와 해당하는 출력을 사용하여 모델을 학습시킵니다.
   - 입력 시퀀스와 출력은 쌍을 이루며, 입력 시퀀스의 길이는 다를 수 있습니다.
   - 모델은 입력 시퀀스를 처리하고, 그 결과로 단일 출력을 예측하도록 훈련됩니다.
2. Testing (테스트):
   - 테스트 단계에서는 훈련된 모델을 사용하여 새로운 입력 시퀀스에 대한 출력을 생성합니다.
   - 다수의 입력 시퀀스가 주어지면, 모델은 입력 시퀀스들을 처리하고, 그 결과로 단일 출력을 생성합니다.
   - 출력은 보통 클래스 레이블이나 확률값과 같은 형태로 나타나며, 입력 시퀀스의 특성에 따라 다양한 방식으로 사용될 수 있습니다.

Many to One 작업은 입력 시퀀스의 다양한 정보를 기반으로 단일 출력을 예측하거나 분류한다. 이를 위해 RNN (Recurrent Neural Network)이나 그 변형인 LSTM (Long Short-Term Memory) 또는 GRU (Gated Recurrent Unit)와 같은 모델 아키텍처를 사용하여 시퀀스 데이터의 특성을 잘 처리한다.

Training과 Testing의 그림은 더보기에 추가했다.

![](/assets/images/posts/68/img_17.png)

![](/assets/images/posts/68/img_18.png)

결국 Many to One의 training은 추가적인 input을 사용하고 목표점 E에 도달하는 것을 말한다. Testing은 결국 입력 값들이 E를 잘 맞추지로 판별해야한다.

Many to Many는 여러 개의 입력 시퀀스에 대해 여러 개의 출력 시퀀스를 생성하는 작업을 말한다. 이는 다양한 입력 시퀀스에 대해 다양한 출력 시퀀스를 생성하는 작업을 포함한다.   
Many to Many 작업은 다양한 형태의 응용 분야에서 사용될 수 있다. 예를 들면, 기계 번역에서 Many to Many 작업은 하나의 언어로 구성된 문장을 입력으로 받아 다른 언어로 번역된 문장을 출력하는 작업을 포함할 수 있다.

Many to Many 작업의 훈련과 테스트는 다음과 같이 수행된다:

1. Training (훈련):
   - 훈련 단계에서는 입력 시퀀스와 해당하는 출력 시퀀스 쌍을 사용하여 모델을 학습시킵니다.
   - 입력 시퀀스와 출력 시퀀스의 길이는 다를 수 있으며, 입력 시퀀스와 출력 시퀀스는 일대일, 일대다, 다대일 또는 다대다 형태일 수 있습니다.
   - 모델은 입력 시퀀스를 처리하고, 적절한 컨텍스트를 학습하여 다양한 출력 시퀀스를 생성할 수 있도록 훈련됩니다.
2. Testing (테스트):
   - 테스트 단계에서는 훈련된 모델을 사용하여 새로운 입력 시퀀스에 대한 출력 시퀀스를 생성합니다.
   - 입력 시퀀스가 주어지면, 모델은 해당 입력에 대한 컨텍스트를 이용하여 다양한 출력 시퀀스를 생성합니다.
   - 출력 시퀀스의 길이는 모델의 아키텍처나 작업의 요구에 따라 다를 수 있습니다.

Many to Many 작업은 입력 시퀀스와 출력 시퀀스 간의 시간적인 의존성을 모델링하고, 다양한 입력-출력 시퀀스 쌍을 훈련하여 모델을 학습시킨다. RNN (Recurrent Neural Network) 구조를 활용하여 시퀀스 데이터의 특성을 처리할 수 있습니다. LSTM (Long Short-Term Memory)이나 GRU (Gated Recurrent Unit)와 같은 RNN 변형은 Many to Many 작업에 특히 유용하다.

Training과 Testing의 그림은 더보기에 추가했다.

![](/assets/images/posts/68/img_19.png)

![](/assets/images/posts/68/img_20.png)

![](/assets/images/posts/68/img_21.png)

![](/assets/images/posts/68/img_22.png)

![](/assets/images/posts/68/img_23.png)

![](/assets/images/posts/68/img_24.png)

![](/assets/images/posts/68/img_25.png)

결국 many to many의 training은 초기 input이 들어간 후, 이에 대한 정보가 집약되어 있는 s를 만들어 활용하여 output y를 사용하여 목표점 ot들에 도달하는 것을 말한다. Testing은 output을 y의 값들을 사용해서 이를 확인할 수 있다는 것을 보여주는 것이다.

Synced Many to  Many는 여러 개의 입력 시퀀스와 여러 개의 출력 시퀀스가 동기화된 상태로 처리되는 작업을 말한다. 이는 입력과 출력 시퀀스 간의 일대일 대응이 있는 작업을 포함한다.  
예를 들어, 동기화된 음성 및 텍스트 데이터에서 Synced Many to Many 작업은 음성 입력과 해당 텍스트 출력의 시간적 대응 관계를 고려하여 음성을 텍스트로 변환하는 음성 인식 작업을 포함할 수 있다.

Synced Many to Many 작업의 훈련과 테스트는 다음과 같이 수행된다:

1. Training (훈련):
   - 훈련 단계에서는 여러 개의 입력 시퀀스와 해당하는 출력 시퀀스 쌍을 사용하여 모델을 학습시킵니다.
   - 입력 시퀀스와 출력 시퀀스는 동일한 길이를 가지며, 각 입력 시퀀스와 출력 시퀀스는 일대일 대응됩니다.
   - 모델은 입력 시퀀스와 출력 시퀀스 간의 동기화된 관계를 학습하여 입력과 출력의 상호작용을 잘 모델링할 수 있도록 훈련됩니다.
2. Testing (테스트):
   - 테스트 단계에서는 훈련된 모델을 사용하여 새로운 입력 시퀀스에 대한 동기화된 출력 시퀀스를 생성합니다.
   - 동기화된 입력 시퀀스가 주어지면, 모델은 해당 입력에 대한 동기화된 출력 시퀀스를 생성합니다.
   - 출력 시퀀스의 길이와 형태는 입력 시퀀스와 동일하며, 입력과 출력 간의 시간적 대응 관계가 유지됩니다.

Synced Many to Many 작업은 입력 시퀀스와 출력 시퀀스 간의 시간적인 대응 관계를 중요시하여 처리된다. RNN (Recurrent Neural Network) 구조를 활용하여 입력과 출력 사이의 동기화된 관계를 학습하고 모델링할 수 있다. LSTM (Long Short-Term Memory)이나 GRU (Gated Recurrent Unit)와 같은 RNN 변형은 Synced Many to Many 작업에 효과적으로 사용된다

Training과 Testing의 그림은 더보기에 추가했다.

![](/assets/images/posts/68/img_26.png)

![](/assets/images/posts/68/img_27.png)

![](/assets/images/posts/68/img_28.png)

![](/assets/images/posts/68/img_29.png)

![](/assets/images/posts/68/img_30.png)

수식이 많이들어가 있지만 결국 초기 chapter에서 보았던 것과 같다. E를 위해 gradient descent를 사용하는 것이다. 결국 Synced Many to Many는 training시 초기 input이 들어간 후, 이에 대한 정보를 바탕으로 output o를 사용하여 목표점 E에 도달하는 것을 말한다. Testing은 output을 o의 값들이 E와 얼만큼 일치하는 가를 활용하여 이를 확인할 수 있다는 것을 보여주는 것이다.

이제 예를 한번 그림으로 살펴보자.

![](/assets/images/posts/68/img_31.png)

One to Many

One to Many를 사용하는 Caption Generation이다. 이미지를 CNN을 통해 들어가면 softmax를 통해 단어들이 나온다.

![](/assets/images/posts/68/img_32.png)

Many to Many

Many to Many를 사용하는 Word Embedding이다. 나의 언어로 구성된 문장을 입력으로 받아 다른 언어로 번역된 문장을 출력하는 작업을 보여주고 있다.

One to Many에서 우리는 Encoder가 사용된다고 하였다. 그렇다면 정보가 들어가면 나오는 것은 Decoder라고 부를수 있지 않을까? 따라서 다음의 그림에서은 형태를 이렇게 나타낼 수 있다.

![](/assets/images/posts/68/img_33.png)

One to Many

![](/assets/images/posts/68/img_34.png)

무슨말을 하고자 하는거면 RNN은 Encoder와 Decoder 역할이 가능하며, 일반적으로 CNN은 Encoder로 사용된다는 것이다.

하지만 이를 활용해도 몇가지 문제점들이 존재한다.

- 인코더가 전체 소스 문장을 단일 벡터로 압축하기 어렵다  
- 문장 길이가 길어질수록 성능이 저하됨  
- 단일 벡터로는 디코더가 올바른 단어를 생성하기에 충분하지 않을 수 있다

즉, 다음의 그림처럼 모든 단계에서 모든 입력이 똑같이 유용하지는 않다.

![](/assets/images/posts/68/img_35.png)

컨텍스트와 관련된 입력이 더 유용할 수 있다.

그렇다면 해당 부분에 Attention을 주면 더 좋지 않을까?

즉, 다음 그리과 같은 형태를 띄는 것이다.

![](/assets/images/posts/68/img_36.png)

더 세부적으로 보면 모든 입력은 일치 정도를 위해 동일한 NN을 공유하게 된다.

![](/assets/images/posts/68/img_37.png)

- 1단계: 일치도 평가

컨텍스트에 대한 각 입력의 일치도 평가

스칼라 매칭도 생성 (높은 값일수록 주의)

모든 입력은 동일한 NN을 공유합니다.

![](/assets/images/posts/68/img_38.png)

1단계:&nbsp;일치도&nbsp;평가

- 2단계: 매칭도 정규화

![](/assets/images/posts/68/img_39.png)

2단계:&nbsp;매칭도&nbsp;정규화

- 3단계: 입력 집계

각 입력은 si로 스케일링되고 z로 합산됩니다.

z는 현재 컨텍스트에 초점을 맞춘 입력입니다.

![](/assets/images/posts/68/img_40.png)

3단계:&nbsp;입력&nbsp;집계

이렇게 단계를 거치면 완성본은 다음 그림과 같다.

![](/assets/images/posts/68/img_41.png)

따라서 Matching NN은 입력과 컨텍스트의 내적으로 대체될 수 있다.

입력에 따른 Attention도 적용되었겠다 그렇다면 단방향으로 진행되는 정보 전달을 양방향으로 적용시킬 수 있지 않을까? 이렇게 나온게 Bidirectional LSTM이다. 구조는 다음과 같다. hi -> 는 과거 정보이며, hi<-는 미래 정보를 나타낸다.

![](/assets/images/posts/68/img_42.png)

Bidirectional LSTM

더 간소화하면 다음과 같다.

![](/assets/images/posts/68/img_43.png)

Bidirectional LSTM

Bidirectional LSTM의 구조와 작동 방식은 다음과 같다:

1. Forward LSTM (순방향 LSTM):
   - 입력 시퀀스를 처음부터 끝까지 순서대로 처리합니다.
   - 현재 입력과 이전 순방향 LSTM의 은닉 상태를 기반으로 현재 은닉 상태를 계산합니다.
   - 시간적인 의존성을 고려하여 입력의 순서에 따라 은닉 상태가 업데이트됩니다.
2. Backward LSTM (역방향 LSTM):
   - 입력 시퀀스를 역순으로 처리합니다.
   - 현재 입력과 이전 역방향 LSTM의 은닉 상태를 기반으로 현재 은닉 상태를 계산합니다.
   - 입력의 순서와 반대로 진행되기 때문에, 역방향 LSTM은 시퀀스의 이후 부분에 대한 정보를 처리합니다.
3. Concatenation (연결):
   - 순방향 LSTM과 역방향 LSTM의 출력을 연결하여 하나의 특성 벡터로 만듭니다.
   - 이를 통해 입력 시퀀스의 양방향 정보가 모두 반영된 특성 벡터를 얻을 수 있습니다.

Bidirectional LSTM은 순방향과 역방향 LSTM을 결합하여 양방향으로 시퀀스 데이터를 처리하므로, 이전과 이후의 정보를 모두 고려할 수 있다. 이를 통해 모델은 입력 시퀀스의 양쪽 방향에서 나타나는 의미와 패턴을 파악하여 더 정확한 예측이나 분류를 수행할 수 있다. 하지만 학습시 그만큼 많은 시간과 자원이 소모된다.

Attention Model의 또 하나의 장점은 모델이 수행하는 작업을 해석하고 시각화할 수 있다.

![](/assets/images/posts/68/img_44.png)

추가적인 장점으로는 다음과 같습니다.

- Attention은 NMT(Neural Machine Translation) 성능을 크게 향상시킨다

Attention은 디코더가 소스의 특정 부분에 집중할 수 있도록 해주는 것이 매우 유용하다  
- Attention은 병목 현상을 해결한다  
Attention은 디코더가 소스를 직접 보고 병목 현상을 우회할 수 있게 한다  
- Attention은 사라져 버리는 그래디언트 문제를 해결하는 데 도움을 준다  
먼 상태로의 바로 가기(short cut)를 제공한다  
- Attention은 일부 해석 가능성을 제공한다  
어텐션 분포를 검사함으로써 디코더가 어떤 부분에 집중했는지 볼 수 있다  
우리는 정렬 결과를 무료로 얻을 수 있다  
이것은 명시적으로 정렬 시스템을 훈련시킨 적이 없기 때문에 흥미로운 점이 있다  
네트워크가 스스로 정렬을 학습했다

마지막으로 Attention Model 예시로 마무리하겠다

![](/assets/images/posts/68/img_45.png)

![](/assets/images/posts/68/img_46.png)
