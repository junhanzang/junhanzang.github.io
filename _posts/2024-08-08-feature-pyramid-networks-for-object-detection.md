---
title: "Feature Pyramid Networks for Object Detection"
date: 2024-08-08 21:36:29
categories:
  - 인공지능
---

<https://arxiv.org/abs/1612.03144>

[Feature Pyramid Networks for Object Detection](https://arxiv.org/abs/1612.03144)

요약

피라미드 특징(feature pyramids)은 다양한 크기의 객체를 인식하는 시스템에서 기본적인 구성 요소입니다. 하지만 최근의 딥러닝 객체 탐지기들은 피라미드 표현을 피했는데, 이는 계산 및 메모리 집약적이기 때문입니다. 본 논문에서는 딥 컨볼루션 네트워크의 내재된 다중 스케일, 피라미드적 계층 구조를 활용하여 추가 비용이 거의 들지 않는 특징 피라미드를 구성합니다. 모든 스케일에서 고수준의 의미론적 특징 맵을 구축하기 위해 상향식 아키텍처와 측면 연결을 개발했습니다. 이 아키텍처는 특징 피라미드 네트워크(Feature Pyramid Network, FPN)라고 하며, 여러 응용 프로그램에서 일반적인 특징 추출기로서 상당한 개선을 보입니다. FPN을 기본 Faster R-CNN 시스템에 사용하여, 추가적인 기술 없이도 COCO 탐지 벤치마크에서 최신의 단일 모델 결과를 달성하며, COCO 2016 챌린지 우승자들을 포함한 모든 기존의 단일 모델 항목들을 능가합니다. 또한, 이 방법은 GPU에서 초당 6 프레임으로 실행 가능하여 다중 스케일 객체 탐지에 실용적이고 정확한 솔루션을 제공합니다. 코드는 공개될 예정입니다.

![](/assets/images/posts/244/img.png)

그림 1. (a) 이미지 피라미드를 사용하여 특징 피라미드를 구축하는 방법. 각 이미지 스케일에서 독립적으로 특징을 계산하는데, 이는 느립니다. (b) 최근 탐지 시스템은 더 빠른 탐지를 위해 단일 스케일 특징만을 사용하는 것을 선택했습니다. (c) 대안으로, ConvNet에 의해 계산된 피라미드 특징 계층을 마치 특징화된 이미지 피라미드처럼 재사용하는 방법이 있습니다. (d) 우리가 제안한 특징 피라미드 네트워크(FPN)는 (b)와 (c)처럼 빠르면서도 더 정확합니다. 이 그림에서 특징 맵은 파란색 윤곽선으로 표시되며, 두꺼운 윤곽선은 의미적으로 더 강력한 특징을 나타냅니다.

### 서론

매우 다양한 크기의 객체를 인식하는 것은 컴퓨터 비전에서 기본적인 도전 과제입니다. 이미지 피라미드를 기반으로 구축된 특징 피라미드(이하 특징화된 이미지 피라미드)는 표준 솔루션의 기본을 형성합니다 [1] (그림 1(a)). 이러한 피라미드는 객체의 크기 변화를 피라미드의 레벨 이동으로 상쇄시키는 방식으로 규모 불변(scale-invariant)입니다. 직관적으로, 이 속성은 모델이 다양한 크기의 객체를 피라미드의 위치와 레벨을 모두 스캔하여 탐지할 수 있게 합니다. 특징화된 이미지 피라미드는 손으로 설계된 특징이 사용되던 시절에 많이 사용되었습니다 [5, 25]. 이러한 피라미드는 매우 중요해서 DPM 같은 객체 탐지기 [7]는 좋은 결과를 얻기 위해 촘촘한 스케일 샘플링을 필요로 했습니다 (예: 옥타브당 10개의 스케일).

인식 작업에서 설계된 특징은 주로 딥 컨볼루션 네트워크(ConvNets)에 의해 계산된 특징으로 대체되었습니다 [19, 20]. ConvNets는 고수준의 의미를 표현할 수 있을 뿐만 아니라, 크기의 변동에 더 강건하여 단일 입력 스케일에서 계산된 특징으로 인식이 가능합니다 [15, 11, 29] (그림 1(b)). 그러나 이러한 강건함에도 불구하고, 가장 정확한 결과를 얻기 위해서는 피라미드가 여전히 필요합니다. ImageNet [33] 및 COCO [21] 탐지 챌린지의 최근 상위 항목들은 모두 특징화된 이미지 피라미드에서 다중 스케일 테스트를 사용합니다 (예: [16, 35]). 이미지 피라미드의 각 레벨을 특징화하는 주된 이점은 모든 레벨이 의미론적으로 강력한 다중 스케일 특징 표현을 생성한다는 것입니다. 그러나 이미지 피라미드의 각 레벨을 특징화하는 데에는 명백한 한계가 있습니다. 추론 시간이 상당히 증가하여 (예: 4배 [11]), 실제 응용 프로그램에서는 이 접근 방식이 비현실적입니다. 또한, 이미지 피라미드에서 끝까지 딥 네트워크를 학습하는 것은 메모리 측면에서 불가능하여, 이미지 피라미드는 테스트 시간에만 사용됩니다 [15, 11, 16, 35]. 이는 학습/테스트 시간 추론 간의 불일치를 초래합니다. 이러한 이유로 Fast 및 Faster R-CNN [11, 29]은 기본 설정에서 특징화된 이미지 피라미드를 사용하지 않습니다.

그러나 다중 스케일 특징 표현을 계산하는 방법은 이미지 피라미드만 있는 것이 아닙니다. 딥 ConvNet은 계층별로 특징 계층을 계산하며, 하위 샘플링 레이어로 인해 특징 계층은 본질적으로 다중 스케일, 피라미드 형태를 갖습니다. 네트워크 내 특징 계층은 서로 다른 공간 해상도의 특징 맵을 생성하지만, 깊이 차이로 인해 큰 의미론적 격차를 도입합니다. 고해상도 맵은 객체 인식을 위한 표현 능력을 해치는 저수준 특징을 가집니다.

Single Shot Detector (SSD) [22]는 ConvNet의 피라미드 특징 계층을 특징화된 이미지 피라미드처럼 사용하는 첫 시도 중 하나입니다 (그림 1(c)). 이상적으로, SSD 스타일의 피라미드는 앞으로의 계산에서 서로 다른 레이어에서 다중 스케일 특징 맵을 재사용하여 비용을 들이지 않습니다. 그러나 저수준 특징 사용을 피하기 위해 SSD는 이미 계산된 레이어를 재사용하지 않고 네트워크의 높은 곳에서 피라미드를 시작하고 (예: VGG 넷의 conv4 3 [36]) 몇 개의 새로운 레이어를 추가합니다. 따라서 특징 계층의 고해상도 맵을 재사용할 기회를 놓치게 됩니다. 우리는 이것이 작은 객체를 탐지하는 데 중요하다는 것을 보여줍니다.

이 논문의 목표는 ConvNet의 특징 계층의 피라미드 형태를 자연스럽게 활용하면서 모든 스케일에서 강력한 의미를 가지는 특징 피라미드를 생성하는 것입니다. 이를 위해, 저해상도 의미론적으로 강한 특징을 고해상도 의미론적으로 약한 특징과 결합하는 상향식 경로 및 측면 연결을 결합한 아키텍처에 의존합니다 (그림 1(d)). 그 결과, 모든 레벨에서 풍부한 의미를 가지는 특징 피라미드가 단일 입력 이미지 스케일에서 빠르게 구축됩니다. 즉, 우리는 네트워크 내 특징 피라미드를 생성하여 특징화된 이미지 피라미드를 대체할 수 있는 방법을 보여주며, 표현력, 속도 또는 메모리를 희생하지 않습니다.

상향식 경로와 스킵 연결을 채택한 유사한 아키텍처는 최근 연구에서 인기를 끌고 있습니다 [28, 17, 8, 26]. 이들의 목표는 예측이 이루어지는 세밀한 해상도의 단일 고수준 특징 맵을 생성하는 것입니다 (그림 2 상단). 반면, 우리의 방법은 아키텍처를 특징 피라미드로 활용하여 각 레벨에서 독립적으로 예측(예: 객체 탐지)을 수행합니다 (그림 2 하단). 우리 모델은 이들 연구에서 탐구되지 않은 특징화된 이미지 피라미드를 반영합니다.

우리는 우리의 방법인 특징 피라미드 네트워크(FPN)를 탐지 및 분할 시스템 [11, 29, 27]에서 평가합니다. 특별한 기교 없이, 우리는 FPN과 기본 Faster R-CNN 탐지기 [29]만을 기반으로 도전적인 COCO 탐지 벤치마크 [21]에서 최첨단 단일 모델 결과를 보고하며, 기존의 대회 우승자들의 세심하게 설계된 단일 모델 항목들을 모두 능가합니다. 축소 실험에서, 우리는 경계 상자 제안에서 FPN이 평균 재현율(AR)을 8.0 포인트 증가시키며, 객체 탐지에서 COCO 스타일 평균 정밀도(AP)를 2.3 포인트, PASCAL 스타일 AP를 3.8 포인트 개선한다는 것을 발견했습니다. 우리의 방법은 또한 마스크 제안으로 쉽게 확장되어 이미지 피라미드에 크게 의존하는 최신 방법들보다 인스턴스 분할 AR과 속도 모두를 개선합니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

- 평균 재현율(AR, Average Recall): 객체 탐지의 민감도를 측정하는 지표
- 평균 정밀도(AP, Average Precision): 객체 탐지의 정확도를 측정하는 지표
- COCO와 PASCAL: 객체 탐지 성능을 평가하는 데 사용되는 대표적인 데이터셋 및 평가 방식

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

또한, 우리의 피라미드 구조는 모든 스케일에서 끝까지 학습될 수 있으며, 학습/테스트 시간에 일관되게 사용됩니다. 이는 이미지 피라미드를 사용하는 것이 메모리 측면에서 불가능한 경우에 해당됩니다. 결과적으로, FPN은 기존의 모든 최첨단 방법보다 더 높은 정확도를 달성할 수 있습니다. 더욱이, 이러한 개선은 단일 스케일 기준의 테스트 시간 증가 없이 이루어졌습니다. 우리는 이러한 진보가 미래 연구와 응용에 기여할 것이라고 믿습니다. 우리의 코드는 공개될 예정입니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

여기서 말하는 "모든 스케일"은 실제로 입력 이미지의 해상도(예: 1024x1024, 4048x4048)를 직접적으로 의미하는 것은 아닙니다. 대신, 이는 네트워크 내부의 특징 맵(feature map)의 다양한 크기를 가리킵니다. 이에 대해 더 자세히 설명해 드리겠습니다:

1. 특징 맵 피라미드: FPN에서 "스케일"은 네트워크 내부의 여러 레벨의 특징 맵을 의미합니다. 일반적으로 이들은 원본 입력 이미지의 1/2, 1/4, 1/8, 1/16, 1/32 등의 크기를 가집니다.
2. 다양한 수용 영역: 각 스케일의 특징 맵은 입력 이미지의 다른 크기의 영역을 "볼 수" 있습니다. 상위 레벨은 더 넓은 영역을, 하위 레벨은 더 작은 영역을 표현합니다.
3. 객체 크기 대응: 이러한 다중 스케일 구조는 이미지 내의 다양한 크기의 객체를 효과적으로 탐지할 수 있게 해줍니다. 큰 객체는 상위 레벨에서, 작은 객체는 하위 레벨에서 더 잘 탐지됩니다.
4. 입력 이미지 크기와의 관계: FPN은 다양한 크기의 입력 이미지(예: 1024x1024나 4048x4048)를 처리할 수 있지만, 내부적으로는 이를 일련의 고정된 비율로 축소된 특징 맵으로 변환합니다.
5. 스케일 불변성: 이 구조는 입력 이미지의 크기에 상관없이 일관된 방식으로 작동하며, 이는 "스케일 불변성"이라고 불립니다.

따라서, "모든 스케일에서 끝까지 학습"된다는 것은 네트워크가 이러한 다양한 크기의 내부 특징 맵을 모두 효과적으로 활용하여 학습한다는 의미입니다. 이는 다양한 크기의 객체를 포함한 여러 해상도의 입력 이미지를 처리할 수 있는 능력을 제공합니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

![](/assets/images/posts/244/img_1.png)

그림 2. 상단: 스킵 연결이 있는 상향식 아키텍처로, 예측이 가장 세밀한 레벨에서 이루어집니다 (예: [28]). 하단: 유사한 구조를 가지지만 모든 레벨에서 독립적으로 예측을 수행하는 특징 피라미드로 활용되는 우리의 모델.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

unet과 비슷한 구조

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

### 2. 관련 연구

#### 손으로 설계된 특징과 초기 신경망

SIFT 특징 [25]은 원래 스케일-스페이스 극값에서 추출되어 특징 점 매칭에 사용되었습니다. HOG 특징 [5]과 이후의 SIFT 특징도 전체 이미지 피라미드에서 밀집하게 계산되었습니다. 이러한 HOG와 SIFT 피라미드는 이미지 분류, 객체 탐지, 인간 자세 추정 등 많은 작업에서 사용되었습니다. 특징화된 이미지 피라미드를 빠르게 계산하는 것에 대한 많은 관심도 있었습니다. Dollár 등 [6]은 스케일을 드물게 샘플링한 피라미드를 먼저 계산한 다음, 누락된 레벨을 보간하여 빠른 피라미드 계산을 보여주었습니다. HOG와 SIFT 이전에, ConvNet을 사용한 얼굴 탐지 초기 연구는 이미지 피라미드 위에서 얕은 네트워크를 계산하여 다양한 스케일에서 얼굴을 탐지했습니다 [38, 32].

#### 딥 ConvNet 객체 탐지기

현대 딥 ConvNet의 발전과 함께 [19], OverFeat [34] 및 R-CNN [12]과 같은 객체 탐지기는 정확도에서 극적인 향상을 보여주었습니다. OverFeat은 초기 신경망 얼굴 탐지기와 유사한 전략을 채택하여 이미지 피라미드에서 슬라이딩 윈도우 탐지기로 ConvNet을 적용했습니다. R-CNN은 ConvNet으로 분류하기 전에 각 제안을 스케일-정규화하는 제안 기반 전략을 채택했습니다 [37]. SPPnet [15]은 이러한 지역 기반 탐지기가 단일 이미지 스케일에서 추출한 특징 맵에서 훨씬 더 효율적으로 적용될 수 있음을 보여주었습니다. 최신 및 더 정확한 탐지 방법인 Fast R-CNN [11]과 Faster R-CNN [29]은 정확도와 속도 사이의 균형을 제공하기 때문에 단일 스케일에서 계산된 특징을 사용할 것을 권장합니다. 그러나 다중 스케일 탐지는 여전히 더 나은 성능을 발휘하며, 특히 작은 객체에 대해서 그렇습니다.

#### 여러 레이어를 사용하는 방법

최근의 여러 접근법은 ConvNet의 다른 레이어를 사용하여 탐지 및 분할을 개선합니다. FCN [24]은 여러 스케일에 걸쳐 각 카테고리에 대한 부분 점수를 합산하여 의미론적 분할을 계산합니다. Hypercolumns [13]은 객체 인스턴스 분할을 위해 유사한 방법을 사용합니다. 다른 여러 접근법 (HyperNet [18], ParseNet [23], ION [2])은 예측을 계산하기 전에 여러 레이어의 특징을 연결하며, 이는 변환된 특징을 합산하는 것과 같습니다. SSD [22]와 MS-CNN [3]은 특징 계층의 여러 레이어에서 객체를 예측하되, 특징이나 점수를 결합하지 않습니다. 최근에는 해상도와 의미론적 수준을 가로지르는 저수준 특징 맵을 연결하는 측면/스킵 연결을 활용하는 방법들이 있습니다. U-Net [31]과 SharpMask [28]는 분할을 위해, Recombinator 네트워크 [17]는 얼굴 탐지를 위해, Stacked Hourglass 네트워크 [26]는 키포인트 추정을 위해 사용됩니다. Ghiasi 등 [8]은 점진적으로 분할을 정제하기 위해 FCN에 대한 라플라시안 피라미드 프레젠테이션을 제시합니다. 이러한 방법들은 피라미드 형태의 아키텍처를 채택하지만, 특징화된 이미지 피라미드 [5, 7, 34]와는 달리 모든 레벨에서 독립적으로 예측을 수행하지 않습니다 (그림 2 참조). 사실, 그림 2 (상단)의 피라미드 아키텍처의 경우, 여러 스케일에서 객체를 인식하기 위해 이미지 피라미드가 여전히 필요합니다 [28].

![](/assets/images/posts/244/img_2.png)

그림 3. 측면 연결과 상향식 경로를 더해 합쳐지는 빌딩 블록을 보여줍니다.

### 3. 특징 피라미드 네트워크 (FPN)

우리의 목표는 ConvNet의 피라미드 형태 특징 계층을 활용하여, 모든 레벨에서 고수준의 의미를 갖는 특징 피라미드를 구축하는 것입니다. 결과적으로 생성된 특징 피라미드 네트워크(FPN)는 범용으로 사용할 수 있으며, 이 논문에서는 슬라이딩 윈도우 제안자(Region Proposal Network, RPN) [29]와 영역 기반 탐지기(Fast R-CNN) [11]에 중점을 둡니다. 또한, 섹션 6에서 FPN을 인스턴스 분할 제안에 일반화합니다.

우리의 방법은 임의 크기의 단일 스케일 이미지를 입력으로 받아, 여러 레벨에서 비율에 맞는 특징 맵을 완전한 컨볼루션 방식으로 출력합니다. 이 과정은 백본 컨볼루션 아키텍처(e.g., [19, 36, 16])와 독립적이며, 이 논문에서는 ResNets [16]를 사용한 결과를 제시합니다. 우리의 피라미드 구축은 다음과 같이 상향식 경로, 하향식 경로 및 측면 연결로 구성됩니다.

#### 상향식 경로

상향식 경로는 백본 ConvNet의 순방향 계산으로, 스케일 단계가 2인 여러 스케일의 특징 맵으로 구성된 특징 계층을 계산합니다. 동일한 크기의 출력 맵을 생성하는 여러 레이어가 있으며, 이 레이어들을 같은 네트워크 단계에 있다고 말합니다. 우리의 특징 피라미드에서는 각 단계마다 하나의 피라미드 레벨을 정의합니다. 각 단계의 마지막 레이어 출력을 우리의 특징 맵 참조 집합으로 선택하여 피라미드를 생성합니다. 이는 각 단계의 가장 깊은 레이어가 가장 강력한 특징을 가지고 있기 때문에 자연스러운 선택입니다.

특히, ResNets [16]의 경우 각 단계의 마지막 잔여 블록에서 출력되는 특징 활성화를 사용합니다. 이러한 마지막 잔여 블록의 출력을 conv2, conv3, conv4, conv5 출력에 대해 각각 C2,C3,C4,C5​로 표시하며, 입력 이미지에 대해 4, 8, 16, 32 픽셀의 스트라이드를 가집니다. 우리는 큰 메모리 풋프린트 때문에 conv1은 피라미드에 포함하지 않습니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

각 단계(stage)마다 특징 맵의 크기가 절반으로 줄어듭니다(스케일 2).

상향식 경로는 마치 망원경을 거꾸로 들여다보는 것과 같습니다. 처음에는 세세한 것들(C2)이 보이지만, 점점 더 넓은 영역을 한 번에 보게 됩니다(C3→C4→C5). 각 단계는 다른 "확대/축소 수준"을 나타내며, 이 모든 수준의 정보를 조합하여 다양한 크기의 객체를 효과적으로 탐지할 수 있게 됩니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

#### 하향식 경로 및 측면 연결

하향식 경로는 상위 피라미드 레벨의 공간적으로 더 조밀하지만 의미론적으로 강력한 특징 맵을 업샘플링하여 높은 해상도의 특징을 만들어냅니다. 그런 다음, 이러한 특징들은 측면 연결을 통해 상향식 경로의 특징과 결합되어 강화됩니다. 각 측면 연결은 상향식 경로와 하향식 경로의 동일한 공간 크기의 특징 맵을 병합합니다. 상향식 특징 맵은 낮은 수준의 의미를 가지지만, 더 적게 샘플링되었기 때문에 활성화가 더 정확하게 위치합니다.

그림 3은 우리의 하향식 특징 맵을 구성하는 빌딩 블록을 보여줍니다. 더 조밀한 해상도의 특징 맵으로, 우리는 공간 해상도를 2배로 업샘플링합니다(단순화를 위해 최근접 이웃 업샘플링 사용). 업샘플된 맵은 대응되는 상향식 맵과 요소별 덧셈으로 병합됩니다(채널 차원을 줄이기 위해 1x1 컨볼루션 레이어 적용). 이 과정은 가장 세밀한 해상도 맵이 생성될 때까지 반복됩니다. 반복을 시작하기 위해 단순히 C5에 1x1 컨볼루션 레이어를 붙여 가장 조밀한 해상도 맵을 생성합니다. 마지막으로, 각 병합된 맵에 3x3 컨볼루션을 추가하여 업샘플링의 앨리어싱 효과를 줄입니다. 이 최종 특징 맵 집합을 P2,P3,P4,P5​로 부르며, 각각 C2,C3,C4,C5​와 동일한 공간 크기를 가집니다.

피라미드의 모든 레벨이 전통적인 특징화된 이미지 피라미드와 같이 공유된 분류기/회귀자를 사용하기 때문에, 모든 특징 맵의 특징 차원(채널 수, d로 표시)을 고정합니다. 이 논문에서는 d=256으로 설정하여 모든 추가 컨볼루션 레이어가 256채널 출력을 갖도록 합니다. 이러한 추가 레이어에는 비선형성이 없으며, 이는 실험적으로 미미한 영향을 미치는 것으로 나타났습니다. 단순함은 우리의 디자인에서 핵심이며, 우리는 모델이 많은 디자인 선택에 대해 강건하다는 것을 발견했습니다. 더 정교한 블록(예: 다층 잔여 블록 [16]을 연결로 사용하는 것)을 실험했지만 약간의 개선만을 관찰했습니다. 더 나은 연결 모듈을 설계하는 것이 이 논문의 초점이 아니므로, 우리는 위에서 설명한 단순한 디자인을 선택했습니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

비유하자면, 이 과정은 마치 고해상도 지도(하위 레벨)에 중요한 랜드마크 정보(상위 레벨)를 추가하는 것과 같습니다. 상위 레벨의 '큰 그림'을 하위 레벨의 '세부 정보'와 결합하여 더 풍부한 정보를 가진 특징 맵을 만듭니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

### 4. 응용

우리의 방법은 딥 ConvNets 내에서 특징 피라미드를 구축하기 위한 범용 솔루션입니다. 아래에서는 RPN [29]에서 경계 상자 제안 생성을 위해, Fast R-CNN [11]에서 객체 탐지를 위해 우리의 방법을 채택합니다. 우리의 방법의 단순성과 효과를 보여주기 위해, FPN으로 변경할 때 [29, 11]의 원래 시스템에 최소한의 수정만 가합니다.

#### 4.1. RPN을 위한 특징 피라미드 네트워크

RPN [29]은 슬라이딩 윈도우 방식의 클래스 비인식 객체 탐지기입니다. 원래 RPN 설계에서는, 소규모 서브네트워크가 단일 스케일 컨볼루션 특징 맵 위에서 밀집 3x3 슬라이딩 윈도우로 평가되어 객체/비객체 이진 분류 및 경계 상자 회귀를 수행합니다. 이는 3x3 컨볼루션 레이어에 의해 실현되며, 이후 두 개의 형제 1x1 컨볼루션 레이어가 분류 및 회귀를 수행합니다. 객체/비객체 기준 및 경계 상자 회귀 타겟은 앵커라는 참조 상자 집합을 기준으로 정의됩니다. 앵커는 여러 사전 정의된 스케일 및 종횡비를 가지며, 다양한 형태의 객체를 커버하기 위해 사용됩니다.

![](/assets/images/posts/244/img_3.png)

우리는 앵커를 실제 경계 상자와의 IoU 비율을 기준으로 학습 라벨을 할당합니다. 공식적으로, 앵커는 주어진 실제 상자에 대해 가장 높은 IoU를 가지거나 모든 실제 상자에 대해 0.7 이상의 IoU를 가지면 양성 라벨을, 모든 실제 상자에 대해 0.3 이하의 IoU를 가지면 음성 라벨을 받습니다. 실제 상자의 스케일은 피라미드 레벨에 할당하는 데 명시적으로 사용되지 않으며, 대신 앵커가 피라미드 레벨에 할당됩니다. 따라서 [29]의 규칙 외에 추가적인 규칙을 도입하지 않습니다.

헤드의 파라미터는 모든 특징 피라미드 레벨에서 공유됩니다. 파라미터를 공유하지 않는 대안을 평가했으나 유사한 정확도를 관찰했습니다. 파라미터를 공유하는 좋은 성능은 피라미드의 모든 레벨이 유사한 의미론적 수준을 공유한다는 것을 나타냅니다. 이는 공통 헤드 분류기를 어떤 이미지 스케일에서도 계산된 특징에 적용할 수 있는 특징화된 이미지 피라미드를 사용하는 것과 유사합니다.

위의 수정으로, RPN은 [29]와 동일한 방식으로 FPN과 함께 자연스럽게 학습되고 테스트될 수 있습니다. 구현 세부 사항은 실험에서 설명합니다.

#### 4.2. Fast R-CNN을 위한 특징 피라미드 네트워크

Fast R-CNN [11]은 Region-of-Interest (RoI) 풀링을 사용하여 특징을 추출하는 영역 기반 객체 탐지기입니다. Fast R-CNN은 일반적으로 단일 스케일 특징 맵에서 수행됩니다. 이를 FPN과 함께 사용하기 위해, 우리는 서로 다른 스케일의 RoI를 피라미드 레벨에 할당해야 합니다.

![](/assets/images/posts/244/img_4.png)

모든 레벨의 모든 RoI에 예측기 헤드(Fast R-CNN의 경우 클래스별 분류기와 경계 상자 회귀기)를 연결합니다. 다시 말해, 레벨에 상관없이 모든 헤드는 파라미터를 공유합니다. [16]에서는 ResNet의 conv5 레이어(9 레이어 깊이의 서브네트워크)를 conv4 특징 위에 헤드로 채택하지만, 우리의 방법은 이미 conv5를 사용하여 특징 피라미드를 구성했습니다. 따라서 [16]과 달리, 우리는 RoI 풀링을 사용하여 7x7 특징을 추출하고, 최종 분류 및 경계 상자 회귀 레이어 전에 두 개의 숨겨진 1,024-d 완전 연결(fc) 레이어(각각 ReLU가 뒤따름)를 추가합니다. 이러한 레이어는 ResNet에 사전 학습된 fc 레이어가 없기 때문에 무작위로 초기화됩니다. 표준 conv5 헤드와 비교할 때, 우리의 2-fc MLP 헤드는 가볍고 더 빠릅니다.

이러한 수정 사항을 바탕으로, 우리는 특징 피라미드 위에서 Fast R-CNN을 학습하고 테스트할 수 있습니다. 구현 세부 사항은 실험 섹션에 제공됩니다.

### 5. 객체 탐지 실험

우리는 80개 카테고리의 COCO 탐지 데이터셋 [21]에서 실험을 수행합니다. 80k개의 학습 이미지와 35k개의 검증 이미지 하위 집합(trainval35k [2])을 결합하여 학습하고, 5k개의 검증 이미지 하위 집합(minival)에서 결과를 보고합니다. 또한 라벨이 공개되지 않은 표준 테스트 세트(test-std) [21]에서 최종 결과를 보고합니다.

일반적인 관행처럼 [12], 모든 네트워크 백본은 ImageNet1k 분류 세트 [33]에서 사전 학습된 후 탐지 데이터셋에서 미세 조정됩니다. 우리는 공개적으로 사용 가능한 사전 학습된 ResNet-50 및 ResNet-101 모델을 사용합니다. 우리의 코드는 Caffe2를 사용하여 py-faster-rcnn의 재구현입니다.

#### 5.1. RPN을 사용한 영역 제안

우리는 COCO 스타일 평균 재현율(AR)과 작은, 중간, 큰 객체에 대한 AR(ARs, ARm, ARl)을 [21]의 정의에 따라 평가합니다. 우리는 이미지당 100개 및 1000개의 제안(AR100 및 AR1k)에 대한 결과를 보고합니다.

구현 세부 사항

표 1의 모든 아키텍처는 끝까지 학습됩니다. 입력 이미지는 짧은 쪽이 800픽셀이 되도록 크기 조정됩니다. 우리는 8개의 GPU에서 동기화된 SGD 학습을 채택합니다. 미니 배치는 GPU당 2개의 이미지를 포함하며, 이미지당 256개의 앵커를 사용합니다. 가중치 감쇠는 0.0001, 모멘텀은 0.9로 설정합니다. 학습률은 처음 30k 미니 배치 동안 0.02, 다음 10k 미니 배치 동안 0.002입니다. 모든 RPN 실험(기준선 포함)에서, 우리는 학습을 위해 이미지 밖에 있는 앵커 박스를 포함합니다. 이는 [29]와 달리 이러한 앵커 박스를 무시하지 않습니다. 다른 구현 세부 사항은 [29]와 동일합니다. COCO에서 8개의 GPU로 FPN을 사용하여 RPN을 학습하는 데 약 8시간이 걸립니다.

#### 5.1.1 축소 실험

![](/assets/images/posts/244/img_5.png)

RPN에 FPN을 사용하면 AR1k가 56.3으로 향상되며, 이는 단일 스케일 RPN 기준선에 비해 8.0 포인트 증가한 것입니다(표 1(c)). 또한, 작은 객체에 대한 성능(AR1k\_s)이 12.9 포인트 크게 향상되었습니다. 우리의 피라미드 표현은 RPN의 객체 크기 변이에 대한 강건성을 크게 향상시킵니다.

#### 상향식 경로의 중요성

표 1(d)는 상향식 경로 없이 특징 피라미드를 사용한 결과를 보여줍니다. 이 수정에서는 1x1 측면 연결 후 3x3 컨볼루션이 상향식 피라미드에 부착됩니다. 이 아키텍처는 피라미드 특징 계층을 재사용하는 효과를 시뮬레이션합니다(그림 1(b)).

표 1(d)의 결과는 RPN 기준선과 비슷하며 우리의 결과에 비해 크게 뒤처집니다. 우리는 이것이 상향식 피라미드의 서로 다른 레벨 사이에 큰 의미론적 격차가 있기 때문이라고 추측합니다(그림 1(b)), 특히 매우 깊은 ResNets의 경우 그렇습니다. 우리는 또한 표 1(d)의 변형을 평가했지만 헤드의 파라미터를 공유하지 않았지만 유사하게 성능이 저하되었습니다. 이 문제는 레벨별 헤드로 간단히 해결할 수 없습니다.

#### 측면 연결의 중요성

표 1(e)는 1x1 측면 연결이 없는 상향식 특징 피라미드를 사용한 축소 결과를 보여줍니다. 이 상향식 피라미드는 강력한 의미론적 특징과 세밀한 해상도를 가지고 있습니다. 그러나 이러한 특징의 위치가 정확하지 않다고 주장할 수 있습니다. 이는 이러한 맵이 여러 번 다운샘플링되고 업샘플링되었기 때문입니다. 특징의 더 정확한 위치는 상향식 맵의 더 세밀한 레벨에서 측면 연결을 통해 상향식 맵으로 직접 전달될 수 있습니다. 결과적으로, FPN은 표 1(e)보다 AR1k 점수가 10 포인트 높습니다.

#### 피라미드 표현의 중요성

피라미드 표현 대신, 헤드를 P2의 최고 해상도, 강한 의미론적 특징 맵에 연결할 수 있습니다(즉, 우리의 피라미드에서 가장 세밀한 레벨). 단일 스케일 기준선과 유사하게, 우리는 모든 앵커를 P2 특징 맵에 할당합니다. 이 변형(표 1(f))은 기준선보다 나쁘지만 우리 접근법보다는 열등합니다. RPN은 고정 창 크기를 가진 슬라이딩 윈도우 탐지기이므로 피라미드 레벨을 통해 스캔하면 크기 변이에 대한 강건성이 증가할 수 있습니다. 또한, P2만 사용하면 큰 공간 해상도로 인해 더 많은 앵커(750k, 표 1(f))가 발생함을 알 수 있습니다. 이 결과는 더 많은 앵커가 자체적으로 정확도를 향상시키기에 충분하지 않음을 시사합니다.

![](/assets/images/posts/244/img_6.png)

### 표 1. RPN을 사용한 경계 상자 제안 결과

COCO minival 세트에서 평가된 RPN [29]을 사용한 경계 상자 제안 결과입니다. 모든 모델은 trainval35k 세트에서 학습되었습니다. "lateral"과 "top-down" 열은 각각 측면 연결과 상향식 경로의 존재 여부를 나타냅니다. "feature" 열은 헤드가 연결된 특징 맵을 나타냅니다. 모든 결과는 ResNet-50을 기반으로 하며 동일한 하이퍼 파라미터를 공유합니다.

![](/assets/images/posts/244/img_7.png)

### 표 2. 고정된 제안 세트(RPN, P\_k​, 표 1(c))를 사용한 Fast R-CNN [11]을 사용한 객체 탐지 결과

COCO minival 세트에서 평가된 고정된 제안 세트(RPN, P\_k​, 표 1(c))를 사용한 Fast R-CNN [11]을 사용한 객체 탐지 결과입니다. 모델은 trainval35k 세트에서 학습되었습니다. 모든 결과는 ResNet-50을 기반으로 하며 동일한 하이퍼 파라미터를 공유합니다.

![](/assets/images/posts/244/img_8.png)

### 표 3. Faster R-CNN [29]을 사용한 객체 탐지 결과

COCO minival 세트에서 평가된 Faster R-CNN [29]을 사용한 객체 탐지 결과입니다. RPN의 백본 네트워크는 Fast R-CNN과 일관됩니다. 모델은 trainval35k 세트에서 학습되었으며 ResNet-50을 사용합니다. (해당 결과는 [16]의 저자들이 제공한 것입니다.)

### 5.2. Fast/Faster RCNN을 사용한 객체 탐지

다음으로, 우리는 FPN을 영역 기반(슬라이딩 윈도우가 아닌) 탐지기에서 조사합니다. 우리는 COCO 스타일 평균 정밀도(AP)와 PASCAL 스타일 AP(단일 IoU 임계값 0.5에서)를 사용하여 객체 탐지를 평가합니다. 또한 [21]의 정의를 따르며 작은, 중간, 큰 크기의 객체에 대한 COCO AP(APs, APm, APl)도 보고합니다.

#### 구현 세부 사항

입력 이미지는 짧은 쪽이 800픽셀이 되도록 크기 조정됩니다. 모델은 8개의 GPU에서 동기화된 SGD로 학습됩니다. 각 미니 배치는 GPU당 2개의 이미지를 포함하며 이미지당 512개의 RoI를 사용합니다. 가중치 감쇠는 0.0001, 모멘텀은 0.9로 설정합니다. 학습률은 처음 60k 미니 배치 동안 0.02, 다음 20k 미니 배치 동안 0.002입니다. 학습에는 이미지당 2000개의 RoI, 테스트에는 1000개의 RoI를 사용합니다. FPN을 사용한 Fast R-CNN을 COCO 데이터셋에서 학습하는 데 약 10시간이 소요됩니다.

#### 5.2.1 고정된 제안 세트를 사용한 Fast R-CNN

FPN이 영역 기반 탐지기에 미치는 영향을 더 잘 조사하기 위해, 우리는 고정된 제안 세트를 사용한 Fast R-CNN의 축소 실험을 수행합니다. 탐지기가 인식할 작은 객체에 대해 좋은 성능을 보이는 FPN의 RPN으로 계산된 제안을 고정합니다(표 1(c)). 단순화를 위해 Fast R-CNN과 RPN 간의 특징을 공유하지 않습니다(명시된 경우 제외).

ResNet 기반 Fast R-CNN 기준선으로서, [16]을 따라 RoI 풀링을 출력 크기 14x14로 사용하고 모든 conv5 레이어를 헤드의 숨겨진 레이어로 추가합니다. 이는 표 2(a)에서 31.9의 AP를 제공합니다. 표 2(b)는 우리의 아키텍처에서 헤드와 유사한 2개의 숨겨진 fc 레이어를 가진 MLP 헤드를 사용한 기준선입니다. 이는 28.8의 AP를 기록하며, 이는 2-fc 헤드가 표 2(a)의 기준선에 비해 독립적인 이점을 제공하지 않음을 나타냅니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

- 단순히 헤드 구조를 변경하는 것만으로는 성능 향상을 얻지 못했음을 보여줍니다.
- 2-fc MLP 헤드가 더 가볍고 빠르지만, 단독으로는 성능 향상을 가져오지 않았습니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

표 2(c)는 Fast R-CNN에서 우리의 FPN 결과를 보여줍니다. 표 2(a)의 기준선과 비교할 때, 우리의 방법은 AP를 2.0 포인트, 작은 객체 AP를 2.1 포인트 향상시킵니다. 2fc 헤드를 사용하는 기준선(표 2(b))과 비교할 때, 우리의 방법은 AP를 5.1 포인트 향상시킵니다. 이러한 비교는 우리의 특징 피라미드가 영역 기반 객체 탐지기에 대해 단일 스케일 특징보다 우수함을 나타냅니다.

표 2(d)와 (e)는 상향식 연결이나 측면 연결을 제거하면 성능이 떨어진다는 것을 보여줍니다. 이는 RPN에서 관찰한 결과와 유사합니다. 상향식 연결을 제거하면(표 2(d)) 정확도가 크게 저하되며, 이는 Fast R-CNN이 고해상도 맵에서 저수준 특징을 사용하는 것에서 문제가 발생함을 시사합니다.

표 2(f)에서 우리는 P2의 단일 가장 세밀한 스케일 특징 맵에서 Fast R-CNN을 채택합니다. 그 결과(33.4 AP)는 모든 피라미드 레벨을 사용하는 경우(33.9 AP, 표 2(c))보다 약간 열등합니다. 우리는 이것이 RoI 풀링이 왜곡과 유사한 작업이기 때문에 영역의 스케일에 덜 민감하기 때문이라고 주장합니다. 이 변형의 좋은 정확도에도 불구하고, 이는 fP\_k의 RPN 제안에 기반하고 있으며, 따라서 이미 피라미드 표현의 이점을 누리고 있습니다.

![](/assets/images/posts/244/img_9.png)

### 표 4. COCO 탐지 벤치마크에서 단일 모델 결과 비교

COCO 탐지 벤치마크에서 단일 모델 결과 비교입니다. 일부 결과는 test-std 세트에서 제공되지 않아, test-dev 결과와 Multipath [40]의 minival 결과도 포함하였습니다.

- y: <http://image-net.org/challenges/talks/2016/GRMI-COCO-slidedeck.pdf>
- z: <http://mscoco.org/dataset/#detections-leaderboard>
- x: AttractioNet [10]은 제안 생성을 위해 VGG-16을, 객체 탐지를 위해 Wide ResNet [39]을 사용하므로 엄밀히 말하면 단일 모델 결과가 아닙니다.

![](/assets/images/posts/244/img_10.png)

### 표 5. Faster R-CNN과 우리의 FPN을 사용한 추가 객체 탐지 결과

minival 세트에서 평가된 Faster R-CNN과 FPN을 사용한 추가 객체 탐지 결과입니다. 특징 공유는 학습 시간을 1.5배 증가시키지만(4단계 학습 [29] 사용), 테스트 시간을 줄입니다.

### 5.2.2 Faster R-CNN (일관된 제안을 사용한 경우)

위에서는 고정된 제안 세트를 사용하여 탐지기를 조사했습니다. 그러나 Faster R-CNN 시스템 [29]에서는 특징 공유를 가능하게 하기 위해 RPN과 Fast R-CNN이 동일한 네트워크 백본을 사용해야 합니다. 표 3은 RPN과 Fast R-CNN에 일관된 백본 아키텍처를 사용하는 우리 방법과 두 기준선 간의 비교를 보여줍니다. 표 3(a)는 [16]에 설명된 기준 Faster R-CNN 시스템을 재현한 것입니다. 제어된 설정 하에서, 우리의 FPN (표 3(c))은 이 강력한 기준선보다 AP에서 2.3 포인트, AP@0.5에서 3.8 포인트 더 우수합니다. 주목할 점은 표 3(a)와 (b)가 He 등 [16]이 표 3()에서 제공한 기준선보다 훨씬 강력한 기준선이라는 것입니다. 우리는 다음의 구현이 격차에 기여한다고 생각합니다: (i) [11, 16]에서 사용한 600픽셀이 아닌 800픽셀의 이미지 스케일 사용; (ii) [11, 16]에서 64개의 RoI 대신 이미지당 512개의 RoI로 학습하여 수렴 속도 가속화; (iii) [16]에서 4개 대신 5개의 스케일 앵커 사용(32² 추가); (iv) 테스트 시 이미지당 300개 대신 1000개의 제안 사용. 따라서 표 3()에서 He 등의 ResNet-50 Faster R-CNN 기준선과 비교할 때, 우리의 방법은 AP에서 7.6 포인트, AP@0.5에서 9.6 포인트 개선되었습니다.

#### 특징 공유

위에서는 단순화를 위해 RPN과 Fast R-CNN 간의 특징을 공유하지 않았습니다. 표 5에서, 우리는 [29]에 설명된 4단계 학습을 따르며 특징 공유를 평가합니다. [29]와 유사하게, 우리는 특징 공유가 소폭의 정확도 향상을 가져옴을 발견했습니다. 특징 공유는 또한 테스트 시간을 줄입니다.

#### 실행 시간

특징 공유를 통해, ResNet-50을 사용한 우리의 FPN 기반 Faster R-CNN 시스템은 단일 NVIDIA M40 GPU에서 이미지당 0.148초의 추론 시간을 가지며, ResNet-101의 경우 0.172초입니다. 비교를 위해, 표 3(a)에서 단일 스케일 ResNet-50 기준선은 0.32초입니다. 우리의 방법은 FPN의 추가 레이어로 인해 약간의 추가 비용이 들지만, 더 가벼운 헤드를 가지고 있습니다. 전체적으로 우리의 시스템은 ResNet 기반 Faster R-CNN에 비해 더 빠릅니다. 우리의 방법의 효율성과 단순성이 향후 연구와 응용에 도움이 될 것이라고 믿습니다.

### 5.2.3 COCO 대회 우승자와의 비교

우리는 표 5에서 ResNet-101 모델이 기본 학습률 스케줄로 충분히 학습되지 않았음을 발견했습니다. 따라서 Fast R-CNN 단계를 학습할 때 각 학습률에서 미니 배치 수를 2배로 늘렸습니다. 이는 minival에서 AP를 35.6으로 증가시켰으며, 특징을 공유하지 않은 상태입니다. 이 모델은 표 4에 표시된 COCO 탐지 리더보드에 제출한 모델입니다. 제한된 시간으로 인해 특징 공유 버전을 평가하지 않았으며, 이는 표 5에서 암시하듯 약간 더 나을 것입니다.

표 4는 우리의 방법을 COCO 대회 우승자들의 단일 모델 결과와 비교합니다. 여기에는 2016년 우승자 G-RMI와 2015년 우승자 Faster R-CNN+++가 포함됩니다. 추가적인 기교 없이도, 우리의 단일 모델 항목은 이 강력하고 세심하게 설계된 경쟁자들을 능가했습니다.

![](/assets/images/posts/244/img_11.png)

### 그림 4. 객체 세그먼트 제안을 위한 FPN

특징 피라미드는 객체 탐지를 위해 사용된 것과 동일한 구조로 구축됩니다. 우리는 5x5 윈도우에서 작은 MLP를 적용하여 출력 차원이 14x14인 밀집 객체 세그먼트를 생성합니다. 오렌지색으로 표시된 것은 각 피라미드 레벨에 해당하는 마스크가 대응하는 이미지 영역의 크기입니다(여기에는 P3-P5 레벨이 표시됨). 대응 이미지 영역 크기(연한 오렌지색)와 표준 객체 크기(진한 오렌지색)가 모두 표시됩니다. 반 옥타브는 7x7 윈도우(7 × 5sqrt{2}​)에서 MLP로 처리되며, 이는 여기에는 표시되지 않았습니다. 자세한 내용은 부록에 있습니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

- 오렌지색으로 표시: 각 피라미드 레벨의 마스크가 대응하는 이미지 영역
- 연한 오렌지색: 대응하는 이미지 영역의 크기
- 진한 오렌지색: 표준 객체 크기

이 접근 방식의 핵심은 다양한 크기의 객체를 효과적으로 세그먼트화할 수 있는 유연하고 효율적인 구조를 제공하는 것입니다. FPN을 통해 다양한 스케일의 특징을 추출하고, 각 레벨에서 적절한 크기의 마스크를 생성함으로써 정확하고 효율적인 인스턴스 세그멘테이션을 가능하게 합니다.

- 피라미드 구조:
  - 상위 레벨(예: P5)에서 하위 레벨(예: P3)로 내려갑니다.
  - 각 레벨은 이미지의 다른 해상도/스케일을 나타냅니다.
- 14x14 마스크 생성 과정:
  - 각 RoI(Region of Interest)에 대해 적절한 피라미드 레벨이 선택됩니다.
  - 선택된 레벨의 특징 맵에서 RoI 영역을 추출합니다.
  - 이 추출된 특징에 5x5 윈도우의 작은 MLP(Multi-Layer Perceptron)를 적용합니다.
  - MLP의 출력으로 14x14 크기의 마스크가 생성됩니다.
- 14x14 마스크의 의미:
  - 이는 객체의 대략적인 형태를 나타내는 저해상도 마스크입니다.
  - 계산 효율성과 충분한 세부 정보 사이의 균형을 제공합니다.
- 적용 방식:
  - MLP는 특징 맵을 슬라이딩 윈도우 방식으로 처리합니다.
  - 각 위치에서 5x5 영역의 특징을 입력으로 받아 하나의 마스크 픽셀을 출력합니다.
  - 이 과정을 14x14번 반복하여 전체 마스크를 생성합니다.
- 스케일 적응:
  - 큰 객체: 상위 레벨(예: P5)의 특징 맵 사용
  - 작은 객체: 하위 레벨(예: P3)의 특징 맵 사용
  - 이를 통해 다양한 크기의 객체에 대해 일관된 크기의 마스크 생성
- 후처리:
  - 생성된 14x14 마스크는 필요에 따라 원본 이미지 크기로 리사이즈될 수 있습니다.

14x14 마스크 자체가 예측(prediction)입니다. MLP는 특징 맵의 각 위치에서 해당 픽셀이 객체에 속하는지 여부를 예측이고, 출력은 0에서 1 사이의 값으로, 각 픽셀이 객체에 속할 확률을 나타냅니다. IOU 맵은 객체의 형태를 나타내는 확률 맵(probability map)입니다. 14x14 마스크는 일반적으로 원본 이미지 크기로 리사이즈되며, 리사이즈된 마스크에 임계값을 적용하여 최종 세그멘테이션 결과를 얻습니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

![](/assets/images/posts/244/img_12.png)

### 표 6. 인스턴스 세그먼트 제안 평가

처음 5k개의 COCO 검증 이미지에서 평가된 인스턴스 세그먼트 제안입니다. 모든 모델은 학습 세트에서 학습되었습니다. DeepMask, SharpMask, FPN은 ResNet-50을 사용하고 Instance-FCN은 VGG-16을 사용합니다. DeepMask와 SharpMask 성능은 <https://github.com/facebookresearch/deepmask>에서 사용할 수 있는 모델로 계산되었습니다(둘 다 '줌' 변형입니다).

- y 실행 시간은 NVIDIA M40 GPU에서 측정되었으며, InstanceFCN 타이밍은 더 느린 K40을 기반으로 합니다.

테스트-개발 세트에서, 우리의 방법은 기존 최고 결과보다 AP에서 0.5 포인트(36.2 vs. 35.7) 및 AP@0.5에서 3.4 포인트(59.1 vs. 55.7) 증가했습니다. 주목할 점은 우리의 방법이 이미지 피라미드에 의존하지 않고 단일 입력 이미지 스케일만 사용하지만, 여전히 소형 객체에 대한 뛰어난 AP를 보인다는 것입니다. 이는 이전 방법들에서는 고해상도 이미지 입력으로만 달성할 수 있었습니다.

또한, 우리의 방법은 반복적 회귀 [9], 하드 네거티브 마이닝 [35], 컨텍스트 모델링 [16], 강력한 데이터 증강 [22] 등의 많은 인기 있는 개선을 활용하지 않았습니다. 이러한 개선은 FPN에 보완적이며 정확도를 더욱 향상시킬 수 있습니다.

최근 FPN은 COCO 대회의 모든 트랙(탐지, 인스턴스 세그멘테이션, 키포인트 추정)에서 새로운 최고 결과를 가능하게 했습니다. 자세한 내용은 [14]를 참조하세요.

### 6. 확장: 세그멘테이션 제안

우리의 방법은 일반적인 피라미드 표현 방식이며 객체 탐지 외의 응용에도 사용할 수 있습니다. 이 섹션에서는 DeepMask/SharpMask 프레임워크 [27, 28]를 따라 세그멘테이션 제안을 생성하기 위해 FPN을 사용합니다.

DeepMask/SharpMask는 인스턴스 세그먼트와 객체/비객체 점수를 예측하기 위해 이미지 크롭에서 학습되었습니다. 추론 시, 이 모델들은 이미지에서 밀집된 제안을 생성하기 위해 컨볼루션 방식으로 실행됩니다. 여러 스케일에서 세그먼트를 생성하려면 이미지 피라미드가 필요합니다 [27, 28].

FPN을 마스크 제안 생성에 적응시키는 것은 쉽습니다. 우리는 학습과 추론 모두에 완전한 컨볼루션 설정을 사용합니다. 섹션 5.1에서 설명한 대로 특징 피라미드를 구축하고 d=128로 설정합니다. 특징 피라미드의 각 레벨 위에, 14x14 마스크와 객체 점수를 완전한 컨볼루션 방식으로 예측하기 위해 작은 5x5 MLP를 적용합니다(그림 4 참조). 또한, [27, 28]의 이미지 피라미드에서 옥타브당 2개 스케일을 사용하는 것을 참고하여, 반 옥타브를 처리하기 위해 입력 크기 7x7의 두 번째 MLP를 사용합니다. 이 두 MLP는 RPN의 앵커와 유사한 역할을 합니다. 아키텍처는 끝까지 학습되며, 전체 구현 세부 사항은 부록에 있습니다.

### 6.1. 세그멘테이션 제안 결과

결과는 표 6에 나와 있습니다. 우리는 항상 1000개의 제안에 대해 세그먼트 AR과 소형, 중형, 대형 객체에 대한 세그먼트 AR을 보고합니다. 단일 5x5 MLP를 가진 기본 FPN 모델은 43.4의 AR을 달성합니다. 약간 더 큰 7x7 MLP로 전환해도 정확도는 크게 변하지 않습니다. 두 MLP를 함께 사용하면 정확도가 45.7 AR로 증가합니다. 마스크 출력 크기를 14x14에서 28x28로 증가시키면 AR이 또 한 포인트 증가합니다(더 큰 크기는 정확도를 저하시킵니다). 마지막으로, 학습 반복을 두 배로 늘리면 AR이 48.1로 증가합니다.

우리는 또한 이전 최첨단 방법인 DeepMask [27], SharpMask [28], InstanceFCN [4]과 비교합니다. 우리는 이러한 접근법의 정확도를 8.3 포인트 이상 AR로 능가합니다. 특히, 소형 객체에 대한 정확도가 거의 두 배로 증가합니다. 기존의 마스크 제안 방법 [27, 28, 4]은 밀집 샘플링된 이미지 피라미드를 기반으로 하며(e.g., [27, 28]에서 2^{-2:0.5:1}로 스케일됨), 계산 비용이 많이 듭니다. FPN에 기반한 우리의 접근법은 훨씬 빠릅니다(우리의 모델은 6-7 FPS로 실행됩니다). 이러한 결과는 우리의 모델이 일반적인 특징 추출기이며, 다른 다중 스케일 탐지 문제를 위해 이미지 피라미드를 대체할 수 있음을 보여줍니다.

### 7. 결론

우리는 ConvNets 내부에서 특징 피라미드를 구축하기 위한 깔끔하고 단순한 프레임워크를 제시했습니다. 우리의 방법은 여러 강력한 기준선과 대회 우승자들보다 상당한 개선을 보여줍니다. 따라서, 이는 이미지 피라미드를 계산할 필요 없이 특징 피라미드의 연구와 응용에 실용적인 솔루션을 제공합니다. 마지막으로, 우리의 연구는 딥 ConvNets의 강력한 표현력과 스케일 변화에 대한 암묵적 강건성에도 불구하고, 피라미드 표현을 사용하여 다중 스케일 문제를 명시적으로 해결하는 것이 여전히 중요하다는 것을 시사합니다.

### A. 세그멘테이션 제안의 구현

우리는 객체 세그먼트 제안을 효율적으로 생성하기 위해 특징 피라미드 네트워크(FPN)를 사용하며, 객체 탐지에 인기 있는 이미지 중심 학습 전략 [11, 29]을 채택합니다. 우리의 FPN 마스크 생성 모델은 DeepMask/SharpMask [27, 28]의 많은 아이디어와 동기를 계승합니다. 그러나 이미지 크롭에서 학습하고 추론을 위해 밀집 샘플링된 이미지 피라미드를 사용한 이들 모델과 달리, 우리는 특징 피라미드에서 마스크 예측을 위해 완전한 컨볼루션 학습을 수행합니다. 이는 많은 세부 사항을 변경해야 하지만, 우리의 구현은 DeepMask와 본질적으로 유사합니다. 구체적으로, 각 슬라이딩 윈도우에서 마스크 인스턴스의 라벨을 정의하기 위해, 우리는 이 윈도우를 입력 이미지의 크롭으로 간주하여 DeepMask의 긍정/부정 정의를 계승합니다. 더 자세한 내용은 다음과 같습니다. 또한 시각화는 그림 4를 참조하세요.

우리는 섹션 5.1에서 설명한 것과 동일한 아키텍처를 사용하여 P2-P6로 특징 피라미드를 구축합니다. d=128로 설정합니다. 우리의 특징 피라미드의 각 레벨은 다른 스케일에서 마스크를 예측하는 데 사용됩니다. DeepMask에서와 같이, 우리는 마스크의 스케일을 너비와 높이의 최대값으로 정의합니다. 스케일이 {32, 64, 128, 256, 512} 픽셀인 마스크는 각각 {P2, P3, P4, P5, P6}에 매핑되며, 5x5 MLP로 처리됩니다. DeepMask가 반 옥타브 피라미드를 사용하는 것처럼, 우리는 반 옥타브를 처리하기 위해 크기 7x7의 두 번째 약간 더 큰 MLP를 사용합니다(예: 128√2 스케일 마스크는 P4의 7x7 MLP로 예측됩니다). 중간 스케일의 객체는 로그 공간에서 가장 가까운 스케일에 매핑됩니다.

각 피라미드 레벨에서 MLP는 다양한 스케일의 객체를 예측해야 하므로, 표준 객체 크기 주위에 일부 패딩이 필요합니다. 우리는 25% 패딩을 사용합니다. 이는 5x5 MLP가 {P2, P3, P4, P5, P6}에서 40, 80, 160, 320, 640 크기의 이미지 영역에 매핑된다는 것을 의미합니다(7x7 MLP는 이에 대응하는 2\sqrt{2}2​ 더 큰 크기).

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

25% 패딩:

- 표준 객체 크기에 25%의 추가 공간을 더합니다.

5x5 MLP vs 7x7 MLP:

- 5x5 MLP: 기본 윈도우 크기
- 7x7 MLP: 5x5보다 2√2배 더 큰 영역을 커버 (약 2.83배)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

특징 맵의 각 공간 위치는 다른 위치에서 마스크를 예측하는 데 사용됩니다. 구체적으로, 스케일 P\_k​에서, 특징 맵의 각 공간 위치는 해당 위치에서 2^k 픽셀 이내에 중심이 있는 마스크를 예측하는 데 사용됩니다(특징 맵의 ±1 셀 오프셋에 해당). 이 범위 내에 객체 중심이 없으면, 그 위치는 부정으로 간주되며, DeepMask와 마찬가지로 마스크 브랜치가 아닌 점수 브랜치 학습에만 사용됩니다.

우리가 마스크와 점수를 예측하기 위해 사용하는 MLP는 상당히 간단합니다. 우리는 512개의 출력을 가진 5x5 커널을 적용한 다음, 형제 완전 연결 레이어를 사용하여 14x14 마스크(총 142 출력)와 객체 점수(1 출력)를 예측합니다. 모델은 완전한 컨볼루션 방식으로 구현되며(완전 연결 레이어 대신 1x1 컨볼루션 사용), 반 옥타브 스케일의 객체를 처리하기 위한 7x7 MLP는 입력 영역이 더 큰 것을 제외하고는 5x5 MLP와 동일합니다.

학습 중에는 미니 배치당 2048개의 예제를 무작위로 샘플링합니다(16개의 이미지에서 각 이미지당 128개의 예제)며, 긍정/부정 샘플링 비율은 1:3입니다. 마스크 손실은 점수 손실보다 10배 높은 가중치를 부여받습니다. 이 모델은 동기화된 SGD를 사용하여 8개의 GPU에서 끝까지 학습됩니다(GPU당 2개의 이미지). 우리는 학습률을 0.03으로 시작하여 80k 미니 배치 동안 학습하며, 60k 미니 배치 후 학습률을 10배로 줄입니다. 학습 및 테스트 중에 이미지 스케일은 800픽셀로 설정됩니다(스케일 지터는 사용하지 않습니다). 추론 중에 우리의 완전한 컨볼루션 모델은 모든 위치와 스케일에서 점수를 예측하고, 가장 높은 점수를 받은 1000개의 위치에서 마스크를 예측합니다. 비최대 억제 또는 후처리는 수행하지 않습니다.

[1612.03144v2.pdf

0.75MB](./file/1612.03144v2.pdf)
