---
title: "Group Normalization"
date: 2025-01-24 23:39:15
categories:
  - 인공지능
tags:
  - group normalization
---

<https://arxiv.org/abs/1803.08494>

[Group Normalization](https://arxiv.org/abs/1803.08494)

**초록(Abstract)**  
Batch Normalization(BN)은 다양한 네트워크가 학습될 수 있도록 한 딥러닝 발전의 이정표적인 기법이다. 그러나 미니배치 차원을 기준으로 정규화하는 과정에서 문제가 발생하는데, 배치 통계량 추정이 부정확해짐에 따라 배치 크기가 작아질수록 BN의 오류가 급격히 커진다. 이로 인해, 메모리 제한으로 인해 소규모 배치가 필요한 대규모 모델 학습이나 물체 탐지, 분할, 비디오 등과 같은 컴퓨터 비전 과제에서 BN을 활용하기가 어려워진다.  
본 논문에서는 BN의 간단한 대안으로 Group Normalization(GN)을 제안한다. GN은 채널들을 여러 그룹으로 나눈 뒤, 각 그룹 내에서 평균과 분산을 계산해 정규화한다. GN의 연산은 배치 크기에 좌우되지 않으며, 다양한 배치 크기 구간에서도 안정적인 정확도를 유지한다. ImageNet 데이터셋으로 ResNet-50을 학습했을 때, 배치 크기를 2로 설정하면 GN은 BN보다 오류율을 10.6% 낮추었으며, 일반적으로 널리 사용하는 배치 크기에서도 BN에 상응하는 성능을 보이고 다른 정규화 방식보다 우수한 결과를 얻었다.  
더 나아가, GN은 사전 학습(pre-training)에서 미세 조정(fine-tuning)으로 자연스럽게 전이될 수 있다. GN은 COCO에서의 물체 탐지와 분할,1 그리고 Kinetics에서의 비디오 분류 작업에서 BN 기반 기법보다 우수한 성능을 보이며, 이는 다양한 과제에서 강력한 BN을 대체할 수 있음을 시사한다. 또한 GN은 현대 라이브러리에서 몇 줄의 코드만으로 간단히 구현 가능하다.

1. COCO 작업 예시 코드

**1 서론(Introduction)**  
Batch Normalization(이하 Batch Norm 또는 BN) [26]은 딥러닝에서 매우 효과적인 구성 요소로 자리 잡아, 컴퓨터 비전 [59, 20]뿐 아니라 다른 분야 [54]의 발전에도 크게 기여해왔다. BN은 (미니)배치 내에서 계산된 평균과 분산을 사용해 특징(feature)을 정규화하며, 이는 최적화를 쉽게 하고 매우 깊은 네트워크가 수렴하도록 돕는 것으로 다양한 실험을 통해 확인되었다. 또한 배치 통계량(batch statistics)의 확률적 불확실성은 정규화 과정에서 일반화 성능을 높여주는 규제(regularizer) 역할도 수행한다. 이러한 이유로 BN은 최신 컴퓨터 비전 알고리즘 상당수의 핵심 기반으로 사용된다.

![](/assets/images/posts/498/img.png)

**Figure 1: ImageNet 분류 에러율과 배치 크기의 관계.**  
ResNet-50 모델을 8개의 작업자(GPU)를 사용해 ImageNet 학습 세트에서 학습한 후, 검증 세트에서 평가한 결과이다.

BN이 큰 성공을 거두었음에도, 배치 차원을 기준으로 정규화한다는 BN의 특수한 동작 방식이 몇 가지 단점을 야기한다. 대표적으로, BN이 제대로 동작하려면 충분히 큰 배치 크기(예: 작업자당 32개2  
2 여기서 “배치 크기”는 작업자(예: GPU)당 샘플 수를 의미한다. 많은 라이브러리에서 BN의 통계는 작업자별로만 계산되고, 여러 작업자 간에 공유되지 않는다.  
[26, 59, 20])가 필요하다. 배치 크기가 작아지면 배치 통계량을 부정확하게 추정하게 되고, 이는 BN의 배치 크기를 줄일 때 모델 오차가 급격히 증가하는 결과를 낳는다(그림 1). 이러한 이유로 최근의 많은 모델 [59, 20, 57, 24, 63]은 메모리를 많이 소모하더라도 일정 규모 이상의 배치 크기를 사용해 학습된다. 그리고 BN에 크게 의존하는 학습 방식은, 메모리 제한으로 인해 더 큰 용량의 모델 설계를 시도하기 어렵게 만든다.

이 배치 크기에 대한 제약은 물체 탐지 [12, 47, 18], 분할(segmentation) [38, 18], 비디오 인식 [60, 6], 그리고 이들에 기반한 고수준 시스템에서 더욱 중요하다. 예를 들어, Fast/er와 Mask R-CNN 프레임워크 [12, 47, 18]는 해상도가 큰 이미지를 사용하기 때문에 배치 크기를 1~2 정도로 설정하며, 이때 BN은 사실상 선형 계층(linear layer)으로 변형되어 “동결(frozen)”된다 [20]. 3D 합성곱을 사용하는 비디오 분류 [60, 6]의 경우에도 공간-시간적 특징 때문에 시간 축 길이와 배치 크기 사이에서 트레이드오프가 발생한다. 따라서 BN을 사용하는 시스템은 모델 설계와 배치 크기 사이에서 타협해야 하는 문제가 생긴다.

본 논문에서는 이러한 문제를 해결하기 위해 **Group Normalization(GN)**을 간단한 대안으로 제안한다. 우리는 기존의 SIFT [39]나 HOG [9]와 같은 전통적인 특징들이 그룹 단위로 정의되어 있으며, 그룹 단위 정규화를 포함한다는 점에 주목했다. 예를 들어, HOG 벡터는 여러 공간적 셀들의 결과물인데, 각 셀은 정규화된 방향 히스토그램을 의미한다. 이러한 아이디어를 참고해, 우리는 채널을 여러 그룹으로 나눈 뒤(Figure 2), 각 그룹 내에서만 평균과 분산을 계산해 정규화하는 GN 계층을 고안했다. GN은 배치 차원을 활용하지 않으므로 그 연산이 배치 크기에 독립적이다.

GN은 매우 다양한 배치 크기 구간에서도 안정적으로 동작한다(그림 1). 예를 들어, 배치 크기를 2로 설정했을 때 ImageNet [50]의 ResNet-50 [20] 실험에서, GN은 BN 대비 10.6% 더 낮은 오차율을 보였다. 일반적인 규모의 배치 크기에서도 GN은 BN과 비슷하거나(오차 차이가 약 0.5%) 다른 정규화 방식들 [3, 61, 51]보다 더 나은 성능을 낸다. 또한 배치 크기가 달라지더라도, GN은 사전 학습(pre-training)에서 미세 조정(fine-tuning)으로 자연스럽게 전이될 수 있다. GN은 COCO [37]에서의 Mask R-CNN 물체 탐지 및 분할 작업, 그리고 Kinetics [30] 데이터셋에서의 3D 합성곱 네트워크 비디오 분류 작업에서 BN 기반 방법보다 더 나은 결과를 보인다. 이는 ImageNet, COCO, Kinetics처럼 BN이 지배적이었던 과제에서도 GN이 충분히 경쟁력 있는 대안이 될 수 있음을 시사한다.

이미 배치 차원을 사용하지 않는 방법으로는 Layer Normalization(LN) [3]이나 Instance Normalization(IN) [61] 등(Figure 2)이 있다. 이들은 순차 모델(RNN/LSTM [49, 22])이나 생성 모델(GAN [15, 27]) 학습에서 효과적이라고 알려져 있다. 하지만 본 논문에서 보이듯, LN과 IN은 일반적인 시각 인식 태스크에서는 성능이 제한적이며 GN이 더 나은 결과를 제공한다. 반대로 GN은 LN이나 IN 대신 사용할 수도 있으므로, 순차적 혹은 생성 모델 분야에도 적용 가능하다. 이는 본 논문의 범위를 벗어나지만 향후 연구 방향을 시사한다.

## **2 관련 연구(Related Work)**

정규화(Normalization)

입력 데이터를 정규화하면 학습이 빨라진다는 사실은 잘 알려져 있다 [33]. 은닉(중간) 특징(hidden feature)을 정규화하기 위한 초기화 기법 [33, 14, 19]들은 특징 분포에 대한 강한 가정에 기반해 유도되었는데, 학습이 진행되면서 이 가정이 깨질 수 있다는 문제가 있었다.

딥 네트워크에서 정규화 계층(normalization layer)은 이미 BN이 개발되기 전부터 널리 사용되어 왔다. 예컨대, Local Response Normalization(LRN) [40, 28, 32]은 AlexNet [32] 및 후속 모델들 [64, 53, 58]에서 사용되었다. 하지만 LRN은 최근의 정규화 방식들 [26, 3, 61]과 달리, 각 픽셀 주변의 작은 영역에 대해서만 통계를 계산한다는 특징이 있다.

Batch Normalization(BN) [26]은 배치 차원에 걸쳐 더 전역적인 정규화를 수행하며(또한 모든 계층에 이를 적용하자고 제안했다는 점에서 중요하다), 이 “배치”라는 개념이 항상 고정적인 것은 아니다. 예컨대 추론(inference) 시에는 배치 단위 정규화가 합리적이지 않으므로, 학습 단계에서 추정한 평균과 분산을 [26] 사전 계산(pre-compute)하여(주로 러닝 평균) 테스트 시에는 정규화 과정을 수행하지 않는다. 그러나 목표 데이터 분포가 바뀌면 [45] 이 사전 계산된 통계량 역시 변경될 수 있다. 이는 학습과 전이(transfer), 테스트 시점에서의 일관성 문제를 유발한다. 게다가 앞서 언급했듯이 배치 크기가 줄어들면 배치 통계량의 추정이 부정확해져 모델 성능이 크게 저하될 수 있다.

이러한 배치 의존성을 피하기 위해 여러 정규화 기법들이 제안되었다 [3, 61, 51, 2, 46]. 예컨대, Layer Normalization(LN) [3]은 채널 차원에 걸쳐 정규화를 수행하며, Instance Normalization(IN) [61]은 각 샘플별로 BN과 유사한 계산을 적용한다(그림 2 참고). Weight Normalization(WN) [51]은 특징 대신 필터 가중치를 정규화한다. 이들 기법들은 배치 차원에서 비롯되는 문제들은 피할 수 있지만, 시각 인식 태스크 전반에서 BN만큼의 정확도에 도달하지 못했다. 이후 섹션에서는 이 방법들과 본 논문에서 제안하는 방법을 비교해볼 것이다.

### 소규모 배치 문제 해결(Addressing small batches)

Ioffe [25]는 Batch Renormalization(BR)을 제안하여, 작은 배치 사이즈에서 BN이 겪는 문제를 완화하려고 시도했다. BR은 추가 파라미터 두 개를 도입해 BN에서 추정하는 평균과 분산이 일정 범위를 넘지 못하도록 제한함으로써, 배치 크기가 작을 때 통계량이 지나치게 흔들리는 현상을 줄여준다. 실제로 소규모 배치 상황에서 BR은 BN보다 더 나은 정확도를 보이지만, 여전히 배치 차원에 의존적이며 배치 크기가 감소할수록 정확도가 떨어지는 문제는 남아 있다 [25].

소규모 배치를 회피하려는 다른 시도도 있다. 예컨대 [43]에서는 여러 GPU 간에 평균과 분산을 동기화(synchronized)하여 계산하는 기법을 사용한다. 그러나 이는 작은 배치 문제를 해결하기보다는, 오히려 BN의 요구사항에 맞춰 충분히 많은 GPU를 확보해야 하는 공학적·하드웨어적 부담으로 이어진다. 또한 동기화된 BN 계산은, 대규모 학습에서 산업계에서 널리 쓰이는 비동기 SGD(ASGD) [10] 기법과 양립하기 어려운 단점이 있다. 이러한 점은 동기화 BN의 적용 범위를 제한한다.

본 논문의 방법은 배치 통계량 자체를 다루는 [25, 43] 등의 접근과 달리, 아예 배치 통계량 계산을 필요로 하지 않도록 설계된 정규화 기법이다.

![](/assets/images/posts/498/img_1.png)

Figure 2: 정규화 방식들. 각 서브 그림(subplot)은 특징 맵 텐서를 나타내며, N은 배치 축, C는 채널 축, (H, W)는 공간 축이다. 파란색으로 표시된 픽셀들은 동일한 평균과 분산으로 정규화되며, 이는 이 픽셀들의 값들을 종합해 계산된다.

### 그룹 단위 계산(Group-wise computation)

그룹 합성곱(group convolution)은 AlexNet [32]이 모델을 두 개의 GPU로 분산하기 위해 사용한 적이 있으며, 이후로 그룹이라는 개념은 모델 설계 차원에서 더욱 적극적으로 연구되고 있다. 예컨대 ResNeXt [63]는 깊이(depth), 너비(width), 그룹 수 사이의 트레이드오프를 탐구해, 동일한 계산량에서 그룹 수를 늘리면 정확도가 향상될 수 있음을 보였다. MobileNet [23]과 Xception [7]에서는 채널 단위 합성곱(“depth-wise” 합성곱이라 부르기도 함)을 이용하는데, 이는 채널 수만큼 그룹을 나눈 그룹 합성곱과 동일한 개념이다. ShuffleNet [65]은 그룹화된 특징 맵의 채널 축을 뒤섞는 “채널 셔플(channel shuffle)” 연산을 제안한다. 이처럼 여러 연구에서 채널을 그룹으로 나누는 방식을 활용하고 있다.

하지만 이 논문에서 제안하는 Group Normalization(GN)은 그룹 합성곱이 반드시 필요한 것은 아니다. GN은 일반적인 레이어로서, 예를 들어 표준 ResNet [20] 구조에서도 문제없이 적용 가능한 정규화 기법이다.

## **3 Group Normalization**

시각적 표현(visual representation)의 채널들은 완전히 독립적이지 않다. 예를 들어 SIFT [39], HOG [9], GIST [41]와 같은 고전적인 특징들은 설계상 그룹 단위 표현(group-wise representation)으로, 각 채널 그룹이 일종의 히스토그램을 통해 구성된다. 이러한 특징들은 일반적으로 히스토그램 또는 방향(orientation) 단위로 그룹 정규화 과정을 거친다. VLAD [29]나 Fisher Vector(FV) [44]처럼 더 높은 수준의 특징들도 클러스터와 연관된 하위 벡터(sub-vector)를 그룹으로 볼 수 있어, 역시 그룹 단위 특징으로 간주할 수 있다.

이와 유사하게, 딥 뉴럴 네트워크의 특징들을 구조가 없는(unstructured) 벡터로만 볼 필요는 없다. 예를 들어 네트워크의 첫 번째 합성곱 계층(conv1)을 생각해보면, 필터 하나와 이 필터의 수평 대칭(horizontal flipping)을 적용했을 때 자연 이미지에서 유사한 필터 반응(distribution)이 나타날 것이라 기대할 수 있다. conv1이 우연히 이 한 쌍의 필터를 학습했거나, 혹은 수평 대칭(또는 다른 변환)이 설계 차원에서 네트워크 구조에 포함되어 있다면 [11, 8], 이들 필터에 해당하는 채널들은 함께 정규화될 수 있다.

고차원 계층들은 더 추상적이며 그 동작 방식이 직관적이지 않을 수 있다. 그러나 방향(orientation) 정보(SIFT [39], HOG [9], 혹은 [11, 8])뿐만 아니라, 빈도(frequency), 형태(shape), 조명(illumination), 질감(texture) 등 여러 요소들이 그룹화를 야기할 수 있고, 이들의 계수(coefficient)들은 상호 의존적일 수 있다. 실제로 신경과학 분야의 잘 확립된 계산 모델은 세포 응답(cell responses) 간 정규화 과정을 가정하고 있으며 [21, 52, 55, 5], “다양한 수용 영역 중심(시각 영역을 포괄)과 다양한 시공간적 주파수 특성”을 고려한다고 알려져 있다([21] p.183). 이는 1차 시각 피질(primary visual cortex)뿐 아니라 “시각 체계 전체(throughout the visual system)”에서 나타날 수 있다 [5]. 본 논문에서는 이러한 연구에서 동기를 받아, 딥 뉴럴 네트워크를 위한 새로운 범용 그룹 단위 정규화(group-wise normalization) 기법을 제안한다.

**3.1 수식(Formulation)**

우선 일반적인 특징 정규화(feature normalization)의 수식을 설명한 뒤, 이 수식 안에서 GN(Group Normalization)이 어떻게 정의되는지 살펴보겠다. BN, LN, IN, GN을 포함하는 특징 정규화 기법들은 공통적으로 다음 과정을 수행한다:

![](/assets/images/posts/498/img_2.png)

![](/assets/images/posts/498/img_3.png)

![](/assets/images/posts/498/img_4.png)

![](/assets/images/posts/498/img_5.png)

![](/assets/images/posts/498/img_6.png)

#### 기존 연구와의 관계(Relation to Prior Work)

- **LN, IN, GN 공통점**  
  LN, IN, GN은 모두 배치 축에 대해 독립적으로 계산이 이뤄진다. GN의 그룹 수가 달라지면 LN이나 IN과 같은 형태가 될 수 있어(그림 2 참고), 이들은 모두 동일한 일반화된 틀 안에 있다.
- **Layer Normalization [3]와의 관계**  
  G=1로 설정하면 GN은 LN과 동일해진다. LN은 “계층 내 모든 채널이 비슷한 기여를 한다”라는 가정 [3]을 두지만, [3]에서도 언급했듯이 합성곱 계층에는 이 가정이 잘 들어맞지 않을 수 있다. GN은 채널 전체가 아니라 그룹 단위로 공유된 평균과 분산을 적용하므로 LN보다 제약이 덜하다. 이는 실험 결과(그림 4)에서 GN이 더 낮은 학습/검증 오차를 보이는 이유가 된다.
- **Instance Normalization [61]과의 관계**  
  G=C로 설정하면 GN은 IN과 동일하다(즉, 채널 하나가 하나의 그룹이 됨). 하지만 IN은 공간 차원으로만 평균과 표준편차를 계산하여 채널 간 상호 의존성을 전혀 고려하지 못한다.

아래는 TensorFlow 기반으로 작성한 GN 파이썬 예시 코드다.

```
def GroupNorm(x, gamma, beta, G, eps=1e-5):
    # x: 입력 특징 텐서 [N, C, H, W]
    # gamma, beta: 스케일 및 오프셋 파라미터, 크기 [1, C, 1, 1]
    # G: GN에 사용할 그룹 수
    N, C, H, W = x.shape
    x = tf.reshape(x, [N, G, C // G, H, W])
    mean, var = tf.nn.moments(x, [2, 3, 4], keep_dims=True)
    x = (x - mean) / tf.sqrt(var + eps)
    x = tf.reshape(x, [N, C, H, W])
    return x * gamma + beta
```

**Figure 3:** TensorFlow 기반 Group Norm 구현 예시 코드.

**3.2 구현(Implementation)**

GN(Group Normalization)은 PyTorch [42]와 TensorFlow [1] 같은 자동 미분 기능을 지원하는 딥러닝 프레임워크에서 몇 줄의 코드만으로 간단히 구현할 수 있다. 그림 3은 TensorFlow를 이용해 작성한 예시 코드를 보여준다. 실제로는 정규화 방식을 정의하는 축(axes)을 설정한 뒤, 해당 축에 대해 평균과 분산(“moments”)을 계산하기만 하면 된다.

![](/assets/images/posts/498/img_7.png)

![](/assets/images/posts/498/img_8.png)

**Figure 4**: 배치 크기가 GPU당 32개 이미지일 때 에러율 곡선 비교. ResNet-50 모델에서 ImageNet 학습 에러(왼쪽)와 검증 에러(오른쪽)를 각각 학습 에폭(epoch) 수에 따라 도시했다.

![](/assets/images/posts/498/img_9.png)

![](/assets/images/posts/498/img_10.png)

**Figure 5**: 배치 크기에 대한 민감도(sensitivity) 분석: BN(왼쪽)과 GN(오른쪽)을 각각 GPU당 32, 16, 8, 4, 2개 이미지로 학습했을 때 ResNet-50의 검증 에러를 나타냈다.

### **4 실험(Experiments)**

### 4.1 Image Classification in ImageNet

우리는 ImageNet 분류 데이터셋 [50]을 활용해 실험을 진행하였으며, 이 데이터셋은 1000개의 클래스로 구성되어 있다. 약 128만(1.28M) 개의 학습 이미지를 사용해 모델을 학습하고, 검증 이미지 5만(50,000) 장에 대해 평가를 수행한다. 모델로는 ResNet 계열 [20]을 사용하였다.

#### 구현 상세(Implementation details)

일반적인 관행에 따라 [20, 17], 모든 모델을 8개의 GPU에서 학습했다. 이때 BN(Batch Norm)의 배치 평균과 분산은 각 GPU별로 별도 계산한다. 모든 합성곱 계층(convolution)에 대해서는 [19]의 방법을 이용해 초기화하였으며, 모든 γ 파라미터는 1로 초기화했다. 다만 각 잔차(residual) 블록의 마지막 정규화 계층에 대해서만 [16]을 따라 γ=0으로 초기화하여, 초기 상태가 항등 함수(identity function)에 가깝도록 했다. 또한 모든 가중치 계층(여기에는 γ와 β 포함)에 대해, [17]과 동일하게 weight decay=0.0001을 적용한다(단, 이는 [20, 16]과는 다르다).

모든 모델은 100 에폭(epoch) 동안 학습하고, 30, 60, 90 에폭에서 학습률을 1/10씩 낮춘다. 학습 과정에서는 [58]에서 제안하고 [17]이 구현한 데이터 증강(data augmentation)을 사용했다. 검증 시에는 224×224 중심 부분(center crop)에 대해 top-1 분류 에러를 평가한다. 무작위 요인(random variation)을 줄이기 위해, 최종 5개 에폭에서의 에러율 중 중앙값(median)을 보고한다 [16]. 그 외 구현 세부 사항은 [17]을 따른다.

BN으로 학습된 ResNet을 기준(baseline)으로 삼았으며, LN·IN·GN을 비교하기 위해 BN 자리에 해당 방식을 대체했다. 이때 다른 하이퍼파라미터들은 모두 동일하게 유지한다. GN은 기본적으로 그룹 수 G=32를 사용한다.

#### 특징 정규화 기법 비교(Comparison of feature normalization methods)

우선 GPU당 32개의 이미지를 사용하는 “일반적인” 배치 크기 설정에서 실험을 진행했다 [26, 20]. 이 배치 크기에서는 BN이 문제없이 잘 동작하므로, BN과의 비교 기준이 된다. 그림 4(Figure 4)는 에러율 곡선을, 표 1(Table 1)은 최종 결과를 보여준다.

![](/assets/images/posts/498/img_11.png)

**표 1(Table 1)**: ResNet-50을 ImageNet에 대해 GPU당 배치 크기 32로 학습했을 때의 검증 에러율(%) 비교. 에러 곡선은 그림 4(Figure 4)에 제시됨.

그림 4(Figure 4)를 보면, 모든 정규화 기법이 수렴(converge)한다는 것을 확인할 수 있다. LN은 BN에 비해 1.7% 정도 정확도가 낮아졌지만, 합성곱 계층 전체 채널을 한꺼번에 정규화(LN)하는 접근도 어느 정도 효과가 있음을 보여준다. IN은 모델이 수렴하긴 했지만, BN 대비 4.8% 낮은 정확도를 보인다.  
(주석)3) 참고로, 필터(filter) 단위를 정규화하는 WN(Weight Normalization) [51]으로도 ResNet-50을 학습해본 결과, 28.2%의 에러율이 나왔다.

BN이 이미 잘 동작하는 이 배치 크기 설정에서, GN은 BN과 매우 비슷한 정확도를 달성한다. 검증 세트 기준으로 BN보다 0.5% 정도 오차율이 높다. 반면 그림 4(Figure 4, 왼쪽)를 보면, GN이 BN보다 더 낮은 학습 에러율을 보이는데, 이는 GN이 최적화(optimization)에 유리하게 작용함을 시사한다. 검증 에러가 조금 더 높은 이유는 BN이 배치 평균과 분산을 확률적으로 추정함으로써 일종의 규제(regularization) 효과를 얻는 반면 [26], GN(및 LN/IN)은 이러한 불확실성(uncertainty)을 활용하지 못하기 때문인 것으로 보인다. GN이 적절한 규제 기법과 결합하면 더 나은 결과를 낼 가능성도 있으며, 이는 향후 연구 과제로 남겨둘 수 있다.

배치 크기에 따른 민감도 분석(batch size sensitivity)을 위해, GPU당 이미지 개수를 32, 16, 8, 4, 2로 달리하면서 BN과 GN을 비교했다. 표 2(Table 2)는 각 설정에서의 ImageNet 검증 에러율(%)을, 그림 5(Figure 5)는 에러 곡선을 나타낸다.

![](/assets/images/posts/498/img_12.png)

**표 2(Table 2)**: 배치 크기에 따른 ResNet-50의 ImageNet 검증 에러율(%). 맨 아래 행(△)은 BN 대비 GN의 차이를 나타낸다. 에러 곡선은 그림 5(Figure 5)에, 그리고 이 표 자체는 그림 1(Figure 1)에도 시각화돼 있다.

![](/assets/images/posts/498/img_13.png)

![](/assets/images/posts/498/img_14.png)

![](/assets/images/posts/498/img_15.png)

**Figure 6**: VGG-16의 conv5\_3 출력(정규화와 ReLU 이전)에 대한 특징 분포가 학습 도중 어떻게 변화하는지 {1, 20, 80, 99} 분위(percentile)를 이용해 시각화했다. 표 오른쪽에는 ImageNet 검증 에러율(%)이 제시되어 있으며, 모델은 GPU당 32개 이미지를 사용해 학습했다.

**소규모 배치 크기(Small batch sizes)**  
BN은 일부 상황에서 배치 차원의 확률적 특성(stochasticity) 덕분에 이점을 얻지만, 배치 크기가 줄어들수록 추정의 불확실성이 커져서 오류가 증가한다. 이를 그림 1, 그림 5, 그리고 표 2에서 확인할 수 있다.

우리는 GPU 한 장당 32, 16, 8, 4, 2개의 이미지를 배치 크기로 설정해 실험했다. 모든 경우 BN의 평균 및 분산은 각 GPU별로 독립적으로 계산되며, 동기화되지 않는다. 모델 학습에는 8개의 GPU를 사용한다. 이때, 배치 크기 변화에 적응하기 위해 [31, 4, 16]의 “선형 학습률 스케일링 규칙(linear learning rate scaling rule)”을 적용했다. 예를 들어 배치 크기가 32일 때 학습률을 0.1로 설정하고, 배치 크기가 N이면 학습률을 0.1×(N/32)로 조정한다. 이 규칙은 실제 산업 현장에서 종종 사용되는, “GPU 수를 늘려 전체 배치 크기를 증가시키지만 GPU당 배치 크기는 그대로 유지하는” 경우 BN과 잘 맞는 방법이다 [16]. 모든 설정에서 학습 에폭 수는 동일하게 유지했으며(그림 5의 x축), 나머지 하이퍼파라미터도 동일하게 적용했다.

그림 5(왼쪽)을 보면, BN은 배치 크기가 작아질수록 오류가 상당히 커진다. 반면 GN은 훨씬 안정적이며 배치 크기에 덜 민감하다. 실제로 그림 5(오른쪽)은 GN의 에러 곡선이 배치 크기 32에서 2까지 매우 유사한 양상을 보임을 보여준다(무작위 편차는 존재). 특히 배치 크기가 2일 때, GN은 같은 설정의 BN 대비 오류가 10.6%p나 낮다(24.1% vs. 34.7%).

이런 결과는, 배치 크기가 4나 2처럼 매우 작을 경우 배치 평균과 분산을 추정하는 과정에서 불확실성이 지나치게 커질 수 있음을 시사한다. 하지만 만약 통계를 1개의 샘플만으로 계산한다면(즉, 배치가 사실상 1인 경우), BN은 학습 시 IN과 유사해진다. 실제로 IN은 배치 크기가 2일 때(28.4%) BN(34.7%)보다 더 나은 결과를 보였다.

표 2의 GN 결과가 보여주듯, GN은 소규모 배치 상황에서도 매우 견고한 성능을 발휘한다. 이는 BN이 impose했던 배치 크기 제약에서 벗어나도록 해주며, 그만큼 메모리를 크게(예: 16배 이상) 절약할 수 있음을 의미한다. 덕분에 기존에는 메모리 제약으로 불가능했던 더 큰 모델을 학습할 수 있는 길이 열릴 것이고, 이는 새로운 아키텍처 설계 가능성을 제시한다.

![](/assets/images/posts/498/img_16.png)

**표 3**: 그룹 분할에 따른 성능 비교. GPU당 배치 크기가 32일 때 ResNet-50의 ImageNet 검증 에러율(%)을 보고한다.  
**위(Top)**: 그룹 수를 고정하여 실험.  
**아래(Bottom)**: 그룹당 채널 수를 고정하여 실험.  
마지막 행은 가장 나은 결과와의 차이를 나타낸다.

![](/assets/images/posts/498/img_17.png)

**그룹 분할(Group division)**  
지금까지의 GN 실험들은 모두 그룹 수 G=32를 사용했다. 먼저 그룹 수를 여러 값으로 바꿔보았을 때(표 3 상단), GN은 다양한 G 값에서 준수한 성능을 보인다. G=1인 극단적인 경우, GN은 LN과 동일해지며 에러율이 G>1인 경우보다 높게 나타난다.

또한 그룹당 채널 수를 고정하는 경우(표 3 하단)도 실험했다. 이때는 레이어마다 채널 수가 달라지므로 레이어별 G 값이 달라질 수 있다. 채널 1개가 곧 1개의 그룹이 되는 극단적인 경우엔 GN이 IN과 동일하다. 채널당 2개만 할당해도 IN(28.4%)보다 훨씬 낮은 에러율(25.6%)을 달성할 수 있음을 확인했고, 이는 정규화 시 채널 간 그룹화(grouping)가 중요한 역할을 한다는 점을 보여준다.

**더 깊은 모델(Deeper models)**  
ResNet-101 [20]로도 BN과 GN을 비교했다. 배치 크기를 32로 했을 때, BN 기반 ResNet-101은 22.0%의 검증 에러율을 보였고 GN 기반 모델은 22.4%로 약 0.4%p 높았다. 하지만 배치 크기가 2인 극단적인 상황에서 GN은 에러율이 23.0%로 안정적인 반면, BN은 무려 31.9%로 GN 대비 8.9%p나 높았다.

**VGG 모델 결과 및 분석(Results and analysis of VGG models)**  
정규화 계층이 없는 경우와 비교하기 위해, VGG-16 [56] 모델을 사용했다. VGG-16은 원래 배치 정규화가 없어도 학습이 가능한 모델이다. 여기서 우리는 각 합성곱 계층 뒤에 BN 또는 GN을 적용한 버전을 만들어 비교했다.

그림 6(Figure 6)은 conv5\_3(마지막 합성곱 계층)의 출력(정규화와 ReLU 이전 단계) 분포가 학습 도중 어떻게 변해가는지 보여준다. BN과 GN은 분포 동작 양상이 크게 다르지 않은 반면, 정규화를 전혀 적용하지 않은 경우와는 현저하게 다른 것을 확인할 수 있다(이는 다른 합성곱 계층들도 마찬가지). 이 비교는 특징 분포를 제어하기 위해 정규화가 필수적임을 시사한다.

VGG-16 모델에서는 GN이 BN보다 0.4% 더 나은 결과를 얻었다(그림 6, 오른쪽). 이는 VGG-16 구조에서는 BN이 제공하는 규제 효과가 상대적으로 덜 유용하며, GN(학습 에러가 더 낮음)이 유리하게 작용했을 가능성을 시사한다.

**4.2 COCO에서의 객체 탐지와 분할(Object Detection and Segmentation in COCO)**

이제 학습된 모델을 미세조정(fine-tuning)하여 객체 탐지와 분할로 전이(transfer)할 때의 성능을 평가한다. 이러한 컴퓨터 비전 과제들은 대개 더 높은 해상도의 입력을 사용하므로, 실제로는 배치 크기가 작아지는 경향이 있다(GPU 1장당 1~2장 정도 [12, 47, 18, 36]). 그 결과로, BN은 사전 학습(pre-training)에서 추정된 μ와 σ 값을 고정(frozen)하여 다음과 같은 선형 계층으로 전환된다:

![](/assets/images/posts/498/img_18.png)

이를 BN\*라고 부르며, 실제로는 미세조정 과정에서 정규화를 전혀 수행하지 않는다. 우리는 미세조정 시 BN 자체를 학습(fine-tuning)하도록 시도해봤으나(즉, 정규화 동작 유지, 비동결), 배치 크기를 2로 했을 때 성능이 ∼6 AP만큼 떨어지는 결과를 얻었으므로 이 방법은 제외한다.

**실험 설정**  
마스크 R-CNN(Mask R-CNN) [18]을 기반으로 한 Detectron [13]의 공개 코드베이스를 활용했다. [13]과 동일한 엔드 투 엔드 방식, 동일한 하이퍼파라미터를 사용하며, 미세조정 시 BN\* 대신 GN을 적용한다. 이때 ImageNet에서 사전 학습한 모델을 그대로 이어서 쓴다.4  
4 Detectron [13]에서는 [20] 저자들이 제공한 사전 학습 모델을 사용하지만, 공정한 비교를 위해 본 논문의 사전 학습 모델을 사용했다. 두 모델로 얻는 객체 탐지/분할 성능은 통계적으로 유의미한 차이가 없다.

미세조정 시 γ와 β 파라미터에는 weight decay를 0으로 설정했는데, 이는 γ와 β를 다시 학습할 때 탐지 성능을 좋게 만드는 데 중요하다. 배치 크기는 GPU당 1장, 총 8 GPU를 사용한다.

![](/assets/images/posts/498/img_19.png)

![](/assets/images/posts/498/img_20.png)

![](/assets/images/posts/498/img_21.png)

**Figure 7**: Kinetics 데이터셋에서 입력 길이 32 프레임으로 실험할 때의 에러 곡선. ResNet-50 I3D의 검증 에러를 BN(왼쪽)과 GN(오른쪽) 각각 배치 크기 8 및 4 클립/ GPU로 보여준다. 여기서 모니터링하는 검증 에러는 학습 세트와 동일한 데이터 증강을 적용한 “1-clip” 평가 시 기준이며, 표 8의 최종 검증 정확도는 데이터 증강 없이 “10-clip” 평가로 측정된다.

#### C4 백본(Backbone) 결과

표 4는 ResNet-50의 conv4 레이어를 백본으로 사용하는(C4) Mask R-CNN 실험 결과다 [18]. 이 C4 변형(C4 variant)은 ResNet conv4까지의 레이어를 특징 맵 추출용 백본으로 쓰고, conv5 레이어를 RoI(Region of Interest) 헤드로 사용한다. 이 과정에서 백본과 헤드 모두 사전 학습된 모델에서 계승되므로, 둘 다 정규화 계층이 포함된다.

이 베이스라인에서 GN은 BN\* 대비 박스 AP가 1.1, 마스크 AP가 0.8 더 높았다. 사전 학습된 GN 모델은 ImageNet 기준으로 BN보다 다소 낮은 성능(24.1% vs. 23.6%)이었지만, 그럼에도 미세조정 시 BN\*보다 더 좋은 성능을 내는 것이 흥미롭다. 이는 사전 학습과 미세조정 시점의 불일치(동결된 BN\*)가 정확도 저하를 야기했을 수 있다.

LN(Layer Normalization) 변형도 시험해본 결과, GN보다 박스 AP가 1.9 낮았고, BN\*보다도 0.8 낮았다. LN 역시 배치 크기에 독립적이지만, 그 표현력 자체가 GN보다 약하다는 사실을 확인할 수 있다.

![](/assets/images/posts/498/img_22.png)

**표 4**: Mask R-CNN(ResNet-50 C4)으로 COCO에서 탐지/분할 실험 결과. BN\*는 BN이 동결된 상태.

#### FPN 백본(Backbone) 결과

다음으로, 현 시점 COCO에서 가장 성능이 뛰어난 방법 중 하나인 Feature Pyramid Network(FPN) [35] 백본을 사용하는 Mask R-CNN에서 GN과 BN\*를 비교한다. C4 변형과 달리, FPN은 사전 학습된 모든 레이어를 활용해 피라미드를 구성하고, 헤드(head) 부분에는 임의로 초기화되는 레이어를 추가한다. [35]에서는 박스 헤드로 완전 연결 계층(fully-connected layer) 2개짜리(2fc)를 사용하지만, 우리는 이 부분을 4conv1fc(합성곱 4개 + fc 1개)로 대체하면 GN이 더 잘 활용된다는 사실을 발견했다. 그 결과를 표 5에 정리했다.

베이스라인인 BN\*는 4conv1fc 헤드를 사용할 때 박스 AP가 38.6이며, 이는 동일 사전 학습 모델에 2fc 헤드를 쓴 결과(38.5)와 유사하다. 여기서 박스 헤드의 합성곱 레이어들에 GN을 적용(BN\* 백본은 그대로)하면, 박스 AP가 0.9 증가하여 39.5가 된다(표 5의 2번째 행). 이는 탐지 성능 향상의 상당 부분이 헤드에서의 정규화(이는 C4 변형도 동일하게 적용)를 통해 기인함을 보여준다. 한편, 박스 헤드에 BN을 직접 적용하면(이미지 1장당 512개의 RoI를 배치로 삼을 때), i.i.d. 분포가 아니므로 배치 통계 추정에 문제가 생겨 ∼9 AP 정도 떨어지는 결과를 얻는다 [25]. 반면 GN은 이런 문제를 겪지 않는다.

다음으로, FPN 백본 자체도 GN으로 대체(즉, 사전 학습 단계부터 GN을 적용한 모델 사용)한 결과를 보면(3번째 행), 백본 교체만으로 박스 AP가 39.5에서 40.0으로 0.5 추가 상승했다. 이는 특성(feature) 전이(transfer) 시 GN이 도움이 됨을 시사한다.

표 6은 Mask R-CNN+FPN 모델에서 백본뿐 아니라 박스 헤드와 마스크 헤드 모두 GN으로 바꾼 완전한 결과를, Detectron [13]의 BN\* 디폴트 베이스라인과 비교한 것이다. [13]과 동일한 학습 스케줄을 쓰면 GN이 BN\*보다 충분히 높은 성능을 달성한다. 게다가 GN은 [13]의 기본 스케줄(180k)로는 완전히 수렴하지 않는 듯 보여, 학습 횟수를 270k로 늘려보았다(이때 BN\*는 학습을 더 늘려도 별 이득이 없었다). 최종적으로 ResNet-50 GN 모델(“long”)은 BN\* 대비 박스 AP 2.2, 마스크 AP 1.6의 차이로 우수하다.

![](/assets/images/posts/498/img_23.png)

**표 5**: Mask R-CNN(ResNet-50 FPN)에 4conv1fc 박스 헤드를 사용하는 COCO 탐지/분할 결과. BN\*는 BN을 동결한 상태.

![](/assets/images/posts/498/img_24.png)

**표 6**: Mask R-CNN + FPN으로 COCO에서 탐지/분할 결과. BN\*는 Detectron [13] 기본값이며, GN은 백본·박스 헤드·마스크 헤드 모두에 적용했다. “long”은 더 많은 반복 횟수(이터레이션)로 학습한 모델을 의미한다.  
이 표의 코드 구현은 [링크](https://github.com/facebookresearch/Detectron/blob/master/projects/GN)에서 확인 가능.

**마스크 R-CNN을 처음부터(scratch) 학습**  
GN을 활용하면, 사전 학습 없이 처음부터(from scratch) 객체 탐지기를 학습하는 실험을 손쉽게 수행할 수 있다. 그 결과를 표 7에 정리했으며, GN 모델은 270k 이터레이션 동안 학습했다.5  
5 scratch 학습의 경우, Detectron 디폴트로 설정된 StopGrad(초기 몇 계층을 동결하는 방식)를 해제했다.

![](/assets/images/posts/498/img_25.png)

![](/assets/images/posts/498/img_26.png)

**표 7**: Mask R-CNN + FPN으로 COCO를 처음부터 학습한 결과. 여기서 BN 결과는 [34]에서 발췌했으며, BN은 GPU 간 동기화되어 있고 [43], 동결되지 않았다.  
이 표의 코드 구현은 [링크](https://github.com/facebookresearch/Detectron/blob/master/projects/GN)에서 확인 가능.

**4.3 Kinetics에서의 비디오 분류(Video Classification in Kinetics)**

마지막으로, Kinetics [30] 데이터셋에서 비디오 분류를 평가한다. 많은 비디오 분류 모델들 [60, 6]은 3차원 시공간(spatial-temporal) 차원으로 특징을 확장하는데, 이는 메모리 소모가 많아 배치 크기와 모델 설계에 제약을 준다.

우리는 Inflated 3D(I3D) 합성곱 네트워크 [6]를 사용한다. ResNet-50 I3D 기본 설정은 [62]를 따르며, 모델은 ImageNet에서 사전 학습한다. BN과 GN 모두에서 정규화 축을 (H,W)에서 (T,H,W)로 확장했는데, 여기서 T는 시간 축이다. Kinetics 400클래스 학습 세트로 학습하고 검증 세트로 평가하며, 표준 “10-clip 테스트” 방식(10개 클립을 고르게 샘플해 소프트맥스 점수를 평균)으로 top-1과 top-5 분류 정확도를 보고한다.

실험은 두 가지 다른 시간 길이(clip length)를 사용한다: 32프레임, 64프레임.

- 32프레임은 원본(raw) 비디오에서 프레임 간격이 2가 되도록 정규 간격으로 샘플링한다.
- 64프레임은 연속적으로 샘플링한다.  
  모델은 시공간적으로 완전 합성곱(fully convolutional)이므로, 64프레임 버전은 32프레임 버전에 비해 메모리를 약 2배 더 많이 사용한다. 배치 크기는 메모리 제한 때문에, 32프레임일 경우 GPU당 8 또는 4 클립, 64프레임일 경우 GPU당 4 클립으로 설정한다.

![](/assets/images/posts/498/img_27.png)

**표 8**: Kinetics 비디오 분류 결과. ResNet-50 I3D 기반 모델의 top-1 / top-5 정확도(%).

### 32프레임 입력 결과

표 8(1,2열)은 32프레임 클립을 사용했을 때의 정확도를 보여준다. 배치 크기가 8일 때 GN은 BN 대비 top-1 기준 0.3%, top-5 기준 0.1% 뒤쳐진다. 이는 BN이 잘 동작하는 상황에서 GN도 충분히 경쟁력 있음을 시사한다. 배치 크기가 4로 줄어들면 GN의 정확도는 크게 변하지 않는(72.8 / 90.6) 반면, BN은 72.1 / 90.0으로 정확도가 하락한다(배치 크기를 8에서 4로 줄였을 때 -1.2%).

그림 7은 에러율 곡선을 보여주는데, BN(왼쪽)은 배치 크기가 8에서 4로 줄어들 때 에러율 곡선에 뚜렷한 차이가 생긴다. 반면 GN(오른쪽)의 에러 곡선은 거의 동일한 양상을 띤다.

### 64프레임 입력 결과

표 8(3열)은 64프레임 클립을 사용했을 때 결과다. BN의 정확도는 73.3 / 90.8로, 32프레임(73.3 / 90.7)과 비교했을 때 비슷한 수치다. 그러나 이는 “64프레임으로 시계열 정보를 늘리는 긍정적 효과”가 “배치 크기가 4로 줄어드는 부정적 영향”과 상쇄되어 나타난 결과이다. 실제로 표 8의 2열(32프레임, 배치 4)과 3열(64프레임, 배치 4)을 비교하면, 시계열 길이를 늘리는 데 따른 이득(약 +1.2%)이 BN의 소규모 배치 문제 때문에 가려져 있음을 알 수 있다.

GN은 이 트레이드오프의 영향을 받지 않는다. GN을 사용한 64프레임 모델은 74.5 / 91.7로, 같은 설정의 BN 모델은 물론 다른 BN 변형들을 모두 능가한다. 시계열 길이를 늘린 이점이 그대로 반영되어, 배치 크기가 같음에도 top-1 정확도가 1.7%p(top-5는 1.1%p) 상승했다.

결과적으로 GN은 객체 탐지, 분할, 비디오 분류 등의 작업에서 BN을 대체할 만한 충분히 강력하고 경쟁력 있는 정규화 방식임이 입증되었다.

## 5 결론 및 향후 과제(Discussion and Future Work)

본 논문에서는 배치 차원을 활용하지 않는 효과적인 정규화 계층인 GN(Group Normalization)을 제안했다. GN의 동작을 다양한 응용 분야에서 평가해 보았다. 다만 BN이 워낙 영향력이 커서, 기존의 최신 시스템 및 하이퍼파라미터가 모두 BN을 전제로 설계되어 있다는 점을 고려하면, GN에 특화해 시스템을 재설계하거나 새로운 하이퍼파라미터를 탐색한다면 더 좋은 결과가 나올 가능성도 있다.

또한 GN은 RNN/LSTM 같은 순환 모델이나 GAN 같은 생성 모델을 성공적으로 학습하는 데 쓰이는 LN과 IN과도 밀접한 관련이 있다. 이는 곧 GN이 향후 이 분야들에서도 적용 가능함을 시사한다. 우리는 강화 학습(RL) 과제에서도 GN을 적용해 볼 계획이며, 예를 들어 [54]처럼 아주 깊은 모델을 학습할 때 BN이 중요한 역할을 하는 상황에도 GN이 도움이 될 수 있을지 탐구해볼 것이다.

**감사의 글(Acknowledgement).**  
저자들은 Piotr Dollár와 Ross Girshick에게 유익한 논의를 나눌 수 있었던 점에 감사의 뜻을 전한다.
