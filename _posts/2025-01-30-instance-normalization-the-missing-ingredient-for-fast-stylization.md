---
title: "Instance Normalization: The Missing Ingredient for Fast Stylization"
date: 2025-01-30 02:44:51
categories:
  - 인공지능
tags:
  - instance normalization
---

대회가 마무리 되어가고 있다보니 생각보다 리뷰를 못하는 중이다. monai에서 사용하는 것들이 기억이 안나서 좀 다시 읽고 있는 형태. 무엇을 잘못했는지 대충 이제 보이는 느낌이기도 하다.

<https://arxiv.org/abs/1607.08022>

[Instance Normalization: The Missing Ingredient for Fast Stylization](https://arxiv.org/abs/1607.08022)

**초록(Abstract)**  
본 논문에서는 Ulyanov 등(2016)에서 제안한 빠른 스타일화(fast stylization) 기법을 재조명한다. 우리는 스타일화 아키텍처에 작은 변화를 가함으로써 생성되는 이미지의 품질이 현저하게 개선될 수 있음을 보인다. 이 변화는 배치 정규화(batch normalization)를 인스턴스 정규화(instance normalization)로 교체하고, 이를 학습 및 추론(테스트) 단계 모두에서 적용하는 데에만 국한된다. 이 방법을 통해 실시간 이미지 생성(real-time image generation)을 위한 고성능 아키텍처를 효과적으로 학습할 수 있다. 소스 코드는 <https://github.com/DmitryUlyanov/texture_nets>에서 확인할 수 있으며, 전체 논문은 <https://arxiv.org/abs/1701.02096>에서 찾을 수 있다.

**1 서론(Introduction)**  
최근 Gatys 등(2016)은 한 이미지의 스타일을 다른 이미지로 이전하는 방법을 제안하였으며, 이는 그림 1과 같이 시각적으로 확인할 수 있다. 이 방법에서는 스타일 이미지와 콘텐츠 이미지 각각에 대한 특정 통계량을 동시에 일치시키면서 스타일화된 이미지를 생성한다. 스타일 및 콘텐츠 통계량은 이미지 분류를 위해 사전 학습된 심층 합성곱 신경망(deep convolutional network)에서 추출된다. 스타일 통계량은 공간적 위치 정보를 평균한 형태로 얕은 계층(shallow layers)에서 얻어지며, 콘텐츠 통계량은 공간 정보를 보존하는 더 깊은 계층(deeper layers)에서 추출된다. 이러한 방식으로 스타일 통계량은 스타일 이미지가 가진 “질감(texture)” 특성을 포착하고, 콘텐츠 통계량은 콘텐츠 이미지가 가진 “구조(structure)” 특성을 잡아낸다.

그러나 Gatys 등의 방식은 매우 우수한 시각적 결과물을 내지만, 계산 효율 면에서 비효율적이라는 한계가 있다. 스타일화된 이미지는 목표 통계량과 일치할 때까지 반복 최적화(iterative optimization)를 수행해야 하며, 512×512 해상도 이미지를 스타일화하는 데 일반적으로 수 분이 소요된다. 이러한 문제를 해결하기 위해, Ulyanov 등(2016)과 Johnson 등(2016)은 이를 단일 추론 단계(single pass)만으로 스타일화 이미지를 생성할 수 있는 피드포워드(feed-forward) 방식의 생성기(generator) 신경망을 학습하는 방법을 제안하였다. 이 두 연구는 주로 생성기 아키텍처의 세부 사항에서 차이가 있으며, 유사한 품질의 결과를 보인다. 하지만 여전히 Gatys 등의 반복 최적화 방식만큼 뛰어난 품질을 달성하지는 못했다.

본 논문에서는 Ulyanov 등(2016)의 피드포워드 스타일화 방법을 재평가하고, 생성기 아키텍처에 작은 변화를 주는 것만으로 결과물이 크게 개선될 수 있음을 보인다. 실제로 이 변화로 인해 Gatys 등의 느린 최적화 방식과 견줄 만한 수준의 높은 품질을 확보하면서, 동시에 일반적인 GPU 환경에서 실시간 처리가 가능해진다. 핵심 아이디어(2장)는 생성기 아키텍처에서 배치 정규화(batch normalization) 계층을 인스턴스 정규화(instance normalization) 계층으로 교체하고, 이것을 테스트 시점에서도 유지하는 것이다(즉, 배치 정규화의 일반적인 “동결 및 단순화(freeze and simplify)” 처리 과정을 거치지 않는다). 직관적으로 이러한 정규화 과정은 콘텐츠 이미지의 인스턴스별 대비(contrast) 정보를 제거하여 이미지 생성을 단순화해 주고, 실제로 이러한 방식은 크게 향상된 결과물을 가져온다(3장).

![](/assets/images/posts/499/img.jpg)

**그림 1**: Gatys 등(2016)의 기법으로 생성된 예술적 스타일 전이 예시.

![](/assets/images/posts/499/img.png)

![](/assets/images/posts/499/img_1.png)

**그림 2**: 스타일화된 이미지의 대비(contrast)는 주로 스타일 이미지의 대비에 의해 결정되며, 콘텐츠 이미지의 대비에는 거의 영향을 받지 않는다. 스타일화는 Gatys 등(2016)의 방법을 사용하였다.

![](/assets/images/posts/499/img_2.png)

**그림 3**:

- 1행: 콘텐츠 이미지(왼쪽), 스타일 이미지(가운데), Gatys 등(2016) 방법으로 스타일 전이된 이미지(오른쪽).
- 2행: Ulyanov 등(2016)의 빠른 스타일화 방법을 이용해 많은 횟수의 반복 학습을 거쳤을 때의 전형적인 스타일화 결과 예시. 왼쪽부터 순서대로: 제로 패딩(zero padding)을 사용한 경우, 보다 나은 패딩 기법을 사용한 경우, 제로 패딩과 인스턴스 정규화를 모두 적용한 경우.

**2 방법(Method)**

![](/assets/images/posts/499/img_3.png)

생성기 네트워크 g는 빠르지만, Ulyanov 등(2016)의 저자들은 학습에 너무 많은 예시 이미지를 사용하면 결과물이 오히려 저하된다는 점을 관찰하였다. 실제로 단 16장의 예시 이미지만 학습에 사용했을 때가 수천 장을 학습한 경우보다 더 나은 결과를 보였다. 가장 심각한 아티팩트는 매 합성곱 연산 전에 적용되는 제로 패딩(zero padding)으로 인해 이미지 경계(border) 부근에서 발생했다(그림 3 참고). 더 복잡한 패딩 기법을 사용해도 문제를 완전히 해결하기는 어려웠다. 결국 Ulyanov 등(2016)의 최고 성능 결과들은 소수의 학습 이미지만 사용하고, 학습을 일찍 종료(early stopping)함으로써 얻게 되었다. 우리는 이를 표준 신경망 아키텍처로는 학습 목표 자체가 너무 어려웠기 때문이라고 추정했다.

단순한 관찰로, 스타일화 결과는 일반적으로 콘텐츠 이미지의 대비(contrast)에 의존해서는 안 된다는 점을 들 수 있다(그림 2 참고). 사실 스타일 손실(style loss)은 스타일 이미지의 대비를 유사하게 반영하는 방식으로 콘텐츠 이미지에 스타일 요소들을 전이하도록 설계되었다. 따라서 생성기 네트워크는 콘텐츠 이미지의 대비 정보를 제거(discard)할 수 있어야 한다. 문제는 이러한 대비 정규화(contrast normalization)를 표준적인 CNN 구성 요소들을 단순히 조합함으로써 효율적으로 구현할 수 있느냐, 아니면 아키텍처 차원에서 직접 구현하는 것이 가장 좋은 방법이냐 하는 것이다.

![](/assets/images/posts/499/img_4.png)

![](/assets/images/posts/499/img_5.png)

**3 실험(Experiments)**  
이 장에서는 2장에서 제안한 변경 사항(배치 정규화를 인스턴스 정규화로 대체)을 적용했을 때의 효과를 평가한다. 우리는 이 변경이 서로 다른 아키텍처에서도 유효한지를 확인하기 위해, Ulyanov 등(2016)과 Johnson 등(2016)에서 제안된 두 가지 생성기 아키텍처 모두를 테스트하였다. Johnson 등(2016)의 원본 네트워크에 직접 접근할 수는 없었으나, 논문의 설명을 바탕으로 신중하게 모델을 재현하였다. 결과적으로 두 생성기 네트워크 모두 유사한 성능과 한계를 보임을 확인하였다(그림 5 첫 번째 행).

다음으로 배치 정규화를 인스턴스 정규화로 대체하고, 동일한 하이퍼파라미터를 사용하여 생성기를 재학습하였다. 그 결과 두 아키텍처 모두 인스턴스 정규화를 적용했을 때 상당한 품질 향상을 보였다(그림 5 두 번째 행). 두 생성기의 결과물 품질은 비슷했지만, Johnson 등(2016)의 레지듀얼 구조(residuals architecture)가 좀 더 효율적이고 사용하기 편리했다고 판단되어, 그림 4에 제시된 결과는 이 구조를 채택하여 얻은 것이다.

![](/assets/images/posts/499/img_6.png)

**그림 4**: 제안된 방법을 사용한 스타일화 예시.  
첫 번째 행: 스타일 이미지들  
두 번째 행: 원본 이미지와 스타일화된 여러 결과물

![](/assets/images/posts/499/img_7.png)

**그림 5**: 두 가지 생성기 아키텍처(Ulyanov 등(2016) (왼쪽), Johnson 등(2016) (오른쪽))를 배치 정규화(첫 번째 행)와 인스턴스 정규화(두 번째 행)로 비교한 질적 결과. 두 아키텍처 모두 인스턴스 정규화를 통해 개선된다.

![](/assets/images/posts/499/img_8.png)

**그림 6**: 그림 4에 제시된 콘텐츠 이미지를 Delaunay 스타일로 서로 다른 해상도(512(왼쪽), 1080(오른쪽))에서 처리한 예시.

**4 결론(Conclusion)**  
이 짧은 보고서에서는 배치 정규화를 인스턴스 정규화로 교체함으로써, 이미지 생성에 특화된 일부 심층 신경망 구조의 성능을 극적으로 향상할 수 있음을 보였다. 이 결과는 시사점이 크며, 우리는 현재 이미지 판별(image discrimination) 과업에서도 유사한 아이디어를 적용하기 위해 실험을 진행 중이다.

monai에서 1gpu에 많은 3d 정보량을 담기 어렵기 때문에 기본적으로 사용한다. 개인적으로 그냥 group norm 씁시다.
