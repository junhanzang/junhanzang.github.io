---
title: "QLoRA: Efficient Finetuning of Quantized LLMs"
date: 2024-07-12 22:06:19
categories:
  - 인공지능
---

<https://arxiv.org/abs/2305.14314>

[QLoRA: Efficient Finetuning of Quantized LLMs](https://arxiv.org/abs/2305.14314)

요약

우리는 QLORA라는 효율적인 미세조정 접근법을 제시합니다. 이 방법은 메모리 사용량을 줄여 65B 파라미터 모델을 단일 48GB GPU에서 미세조정할 수 있게 하면서도 전체 16비트 미세조정 작업 성능을 유지합니다. QLORA는 4비트 양자화된 사전 훈련 언어 모델을 통해 저랭크 어댑터(LoRA)로의 그래디언트를 역전파합니다. 우리의 최고의 모델 군인 Guanaco는 Vicuna 벤치마크에서 이전에 공개된 모든 모델을 능가하며, ChatGPT 성능 수준의 99.3%에 도달하면서도 단일 GPU에서 24시간의 미세조정만을 필요로 합니다. QLORA는 성능을 희생하지 않으면서 메모리를 절약하기 위해 여러 혁신을 도입합니다: (a) 통계적으로 최적화된 가중치를 위한 새로운 데이터 유형인 4비트 NormalFloat(NF4), (b) 양자화 상수를 양자화하여 평균 메모리 사용량을 줄이는 Double Quantization, (c) 메모리 스파이크를 관리하기 위한 Paged Optimizers. 우리는 QLORA를 사용하여 1,000개 이상의 모델을 미세조정하며, 8개의 지침 데이터셋, 여러 모델 유형(LLaMA, T5), 및 일반적인 미세조정으로는 실행 불가능한 모델 규모(예: 33B 및 65B 파라미터 모델)에 걸친 지침 준수 및 챗봇 성능에 대한 자세한 분석을 제공합니다. 우리의 결과는 작은 고품질 데이터셋에서 QLoRA 미세조정이 이전의 최첨단보다 더 작은 모델을 사용하더라도 최첨단 결과를 이끌어낸다는 것을 보여줍니다. 우리는 GPT-4 평가가 인간 평가의 저렴하고 합리적인 대안임을 보여주는 인간 및 GPT-4 평가를 기반으로 챗봇 성능에 대한 상세한 분석을 제공합니다. 또한, 현재의 챗봇 벤치마크는 챗봇 성능 수준을 정확하게 평가하기에 신뢰할 수 없다는 것을 발견했습니다. 레몬 픽 분석은 Guanaco가 ChatGPT에 비해 실패하는 부분을 보여줍니다. 우리는 모든 모델과 코드, 4비트 훈련용 CUDA 커널을 공개합니다.

### 1. 서론

대형 언어 모델(LLMs)을 미세 조정하는 것은 성능을 향상시키는 매우 효과적인 방법이며, 원하는 행동을 추가하거나 바람직하지 않은 행동을 제거하는 데 유용합니다. 그러나 매우 큰 모델을 미세 조정하는 것은 비용이 매우 많이 듭니다. 예를 들어, LLaMA 65B 파라미터 모델을 16비트로 미세 조정하려면 780GB 이상의 GPU 메모리가 필요합니다. 최근의 양자화 방법은 LLM의 메모리 사용량을 줄일 수 있지만, 이러한 기술은 추론에서는 효과적이나 훈련 중에는 작동하지 않습니다.

우리는 처음으로 성능 저하 없이 4비트로 양자화된 모델을 미세 조정할 수 있음을 입증합니다. 우리의 방법인 QLORA는 사전 훈련된 모델을 4비트로 양자화한 후, 양자화된 가중치를 통해 그래디언트를 역전파하여 미세 조정되는 소수의 학습 가능한 저랭크 어댑터 가중치를 추가합니다. QLORA는 65B 파라미터 모델을 미세 조정하는 데 필요한 평균 메모리 요구량을 780GB 이상의 GPU 메모리에서 48GB 미만으로 줄이면서도, 16비트로 완전히 미세 조정된 기준 모델과 비교하여 실행 시간이나 예측 성능이 저하되지 않습니다. 이는 LLM 미세 조정의 접근성에 있어 큰 변화를 의미합니다. 이제 단일 GPU에서 가장 큰 공개 모델도 미세 조정할 수 있게 되었습니다. QLORA를 사용하여 Guanaco 모델 군을 훈련시켰고, 두 번째로 좋은 모델은 Vicuna 벤치마크에서 ChatGPT 성능 수준의 97.8%에 도달했습니다. 단일 소비자용 GPU에서 12시간 이내에 훈련할 수 있으며, 단일 전문 GPU를 사용하여 24시간 동안 훈련하면 우리의 가장 큰 모델로 99.3%에 도달하여 Vicuna 벤치마크에서 ChatGPT에 거의 근접하게 됩니다.

배포 시, 우리의 가장 작은 Guanaco 모델(7B 파라미터)은 5GB의 메모리만 필요로 하며, Vicuna 벤치마크에서 26GB의 Alpaca 모델보다 20 퍼센트 포인트 이상 높은 성능을 보여줍니다 (표 6 참조).

![](/assets/images/posts/204/img.png)

표 6: GPT-4로 평가한 ChatGPT에서 얻은 점수의 백분율로 표시된 제로 샷 Vicuna 벤치마크 점수. 매우 작은 데이터 세트에서 훈련되고 기준 모델에 비해 메모리 요구량이 훨씬 적음에도 불구하고 OASST1 모델이 ChatGPT에 근접한 성능을 보이는 것을 확인할 수 있습니다.

![](/assets/images/posts/204/img_1.png)

#### 표 1: 모델 간 경쟁의 Elo 등급

모델 간 경쟁의 Elo 등급은 10,000개의 무작위 초기 순서를 평균낸 것입니다. Vicuna 벤치마크의 특정 프롬프트에 대한 응답이 더 나은지를 결정하는 GPT-4에 의해 매치의 승자가 결정됩니다. 95% 신뢰 구간이 표시되어 있습니다(±). GPT-4 다음으로 Guanaco 33B와 65B가 가장 많은 매치에서 승리했으며, Guanaco 13B는 Bard보다 높은 점수를 기록했습니다.

QLORA는 성능을 희생하지 않으면서 메모리 사용량을 줄이기 위해 여러 가지 혁신을 도입했습니다:

1. **4비트 NormalFloat**: 보통 분포된 데이터에 대해 정보 이론적으로 최적화된 양자화 데이터 타입으로, 4비트 정수와 4비트 플로트보다 더 나은 경험적 결과를 제공합니다.
2. **이중 양자화**: 양자화 상수를 양자화하는 방법으로, 파라미터당 평균 약 0.37비트를 절약합니다(65B 모델의 경우 약 3GB).
3. **페이지드 옵티마이저**: NVIDIA의 통합 메모리를 사용하여 미니 배치 처리 시 긴 시퀀스 길이로 인한 그래디언트 체크포인팅 메모리 스파이크를 피합니다. 이러한 기여를 결합하여 네트워크의 모든 레이어에 어댑터를 포함하는 더 잘 조정된 LoRA 접근 방식을 만들었으며, 이전 작업에서 관찰된 거의 모든 정확도 트레이드오프를 피할 수 있습니다.

QLORA의 효율성 덕분에 메모리 오버헤드 때문에 일반적인 미세 조정으로는 불가능했던 모델 규모에 대해 지침 미세 조정 및 챗봇 성능에 대한 심층적인 연구를 수행할 수 있습니다. 따라서 우리는 여러 지침 튜닝 데이터셋, 모델 아키텍처, 80M에서 65B 파라미터 사이의 크기에 걸쳐 1,000개 이상의 모델을 훈련합니다. QLORA가 16비트 성능을 회복하고 (§4) 최첨단 챗봇인 Guanaco를 훈련시키는 것 외에도 (§5), 훈련된 모델의 추세를 분석합니다. 첫째, 데이터셋 크기보다 데이터 품질이 훨씬 더 중요하다는 것을 발견했습니다. 예를 들어, 9k 샘플 데이터셋(OASST1)이 450k 샘플 데이터셋(FLAN v2, 서브샘플링됨)보다 챗봇 성능에서 더 나은 결과를 보였습니다. 둘째, 강력한 대규모 멀티태스크 언어 이해(MMLU) 벤치마크 성능이 강력한 Vicuna 챗봇 벤치마크 성능을 의미하지 않으며 그 반대도 마찬가지라는 것을 보여줍니다. 즉, 주어진 작업에 대한 데이터셋의 적합성이 크기보다 더 중요합니다.

또한, 인간 평가자와 GPT-4를 사용한 챗봇 성능에 대한 광범위한 분석도 제공합니다. 우리는 토너먼트 스타일 벤치마킹을 사용하여 모델이 주어진 프롬프트에 대해 가장 좋은 응답을 생성하기 위해 경쟁합니다. 매치의 승자는 GPT-4 또는 인간 평가자가 판단합니다. 토너먼트 결과는 Elo 점수로 집계되며, 이는 챗봇 성능 순위를 결정합니다. GPT-4와 인간 평가가 대체로 모델 성능 순위에 대해 일치하지만, 강한 불일치가 발생하는 경우도 있습니다. 따라서 모델 기반 평가가 인간 평가의 저렴한 대안이 될 수 있지만 불확실성도 있다는 점을 강조합니다.

우리는 정성적 분석으로 Guanaco 모델의 성공 사례와 실패 사례를 강조하여 정량적 벤치마크에서 포착되지 않은 부분을 보완합니다. 모든 모델 생성 결과를 인간 및 GPT-4 주석과 함께 공개하여 추가 연구를 촉진합니다. 우리는 코드베이스와 CUDA 커널을 오픈 소스로 제공하고, 우리의 방법을 Hugging Face 변환기 스택에 통합하여 모두가 쉽게 접근할 수 있도록 합니다. 8개의 다른 지침 데이터를 사용하여 훈련된 7/13/33/65B 크기 모델에 대한 어댑터 모음을 공개하여 총 32개의 오픈 소스 미세 조정 모델을 제공합니다.

![](/assets/images/posts/204/img_2.png)

#### 그림 1: 다양한 미세 조정 방법과 메모리 요구 사항

QLORA는 트랜스포머 모델을 4비트 정밀도로 양자화하고 메모리 스파이크를 처리하기 위해 페이지드 옵티마이저를 사용하여 LoRA보다 향상된 성능을 제공합니다.

### 2. 배경

#### 블록별 k-비트 양자화

양자화는 더 많은 정보를 담고 있는 표현에서 더 적은 정보를 담고 있는 표현으로 입력을 이산화하는 과정입니다. 이는 종종 더 많은 비트를 사용하는 데이터 타입을 더 적은 비트로 변환하는 것을 의미하며, 예를 들어 32비트 플로트에서 8비트 정수로 변환하는 것을 말합니다. 저비트 데이터 타입의 전체 범위를 사용하도록 보장하기 위해, 입력 데이터 타입은 일반적으로 입력 요소의 절대 최대값으로 정규화하여 목표 데이터 타입 범위로 재조정됩니다. 예를 들어, 32비트 부동 소수점(FP32) 텐서를 범위 [−127, 127]의 Int8 텐서로 양자화하는 경우:

![](/assets/images/posts/204/img_3.png)

![](/assets/images/posts/204/img_4.png)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

![](/assets/images/posts/204/img_5.png)

![](/assets/images/posts/204/img_6.png)

![](/assets/images/posts/204/img_7.png)

![](/assets/images/posts/204/img_8.png)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

### 메모리 효율적인 미세 조정의 메모리 요구 사항

미세 조정 동안 LoRA의 메모리 요구 사항, 특히 어댑터의 수와 크기 측면에서 중요한 논점입니다. LoRA의 메모리 사용량이 매우 적기 때문에 성능을 향상시키기 위해 더 많은 어댑터를 사용할 수 있으며, 이는 전체 메모리를 크게 증가시키지 않습니다. LoRA는 파라미터 효율적인 미세 조정(PEFT) 방법으로 설계되었지만, LLM 미세 조정에서 대부분의 메모리 사용량은 학습된 LoRA 파라미터가 아닌 활성화 그래디언트에서 발생합니다.

예를 들어, FLAN v2에서 배치 크기 1로 훈련된 7B LLaMA 모델에서, 일반적으로 사용되는 원래 모델 가중치의 0.2%에 해당하는 LoRA 가중치를 사용하는 경우, LoRA 입력 그래디언트의 메모리 사용량은 567MB인 반면, LoRA 파라미터는 26MB만 차지합니다. 그래디언트 체크포인팅을 사용하면 입력 그래디언트는 시퀀스당 평균 18MB로 줄어들어 모든 LoRA 가중치를 합친 것보다 더 많은 메모리를 차지합니다. 이에 비해, 4비트 기반 모델은 5,048MB의 메모리를 소비합니다. 이는 그래디언트 체크포인팅이 중요함을 강조하면서도 LoRA 파라미터의 양을 과도하게 줄이는 것이 메모리 이점이 거의 없음을 보여줍니다. 따라서 더 많은 어댑터를 사용하더라도 전체 훈련 메모리 사용량을 크게 증가시키지 않을 수 있습니다(자세한 내용은 부록 G 참조). 이는 전체 16비트 정밀도 성능을 회복하는 데 중요합니다.

### QLORA 미세 조정

QLORA는 우리가 제안하는 두 가지 기술인 4비트 NormalFloat (NF4) 양자화와 이중 양자화를 통해 고품질 4비트 미세 조정을 달성합니다. 또한, 우리는 그래디언트 체크포인팅 동안 메모리 스파이크가 발생하여 발생하는 메모리 부족 오류를 방지하기 위해 페이지드 옵티마이저를 도입합니다. 이는 대규모 모델의 단일 기계에서 미세 조정을 어렵게 만든 전통적인 문제를 해결합니다.

QLORA는 하나의 저정밀도 저장 데이터 타입(보통 4비트)과 하나의 계산 데이터 타입(보통 BFloat16)을 가지고 있습니다. 실제로, QLORA 가중치 텐서가 사용될 때마다 해당 텐서를 BFloat16으로 반양자화한 후 16비트로 행렬 곱셈을 수행합니다.

이제 QLORA의 구성 요소를 논의한 후 QLORA의 공식 정의를 설명하겠습니다.

### 4비트 NormalFloat 양자화

NormalFloat(NF) 데이터 타입은 정보 이론적으로 최적화된 데이터 타입인 **Quantile Quantization**을 기반으로 합니다. Quantile Quantization은 입력 텐서에서 각 양자화 빈이 동일한 수의 값을 갖도록 보장합니다. Quantile Quantization은 경험적 누적 분포 함수를 통해 입력 텐서의 분위수를 추정하는 방식으로 작동합니다.

Quantile Quantization의 주요 한계는 분위수 추정 과정이 비용이 많이 든다는 점입니다. 따라서 SRAM quantiles와 같은 빠른 분위수 근사 알고리즘이 사용됩니다. 그러나 이러한 분위수 근사 알고리즘의 특성상, 데이터 타입은 종종 가장 중요한 값인 이상치에 대해 큰 양자화 오류를 가집니다.

입력 텐서가 양자화 상수에 고정된 분포에서 나오는 경우, 비싼 분위수 추정과 근사 오류를 피할 수 있습니다. 이러한 경우, 입력 텐서는 동일한 분위수를 가지므로 정확한 분위수 추정이 계산적으로 가능해집니다.

사전 훈련된 신경망 가중치는 일반적으로 표준 편차 σ를 가지는 0 중심의 정규 분포를 가지므로(부록 F 참조), 모든 가중치를 단일 고정 분포로 변환할 수 있습니다. 이는 표준 편차 σ를 스케일링하여 분포가 데이터 타입의 범위에 정확히 맞도록 하는 것입니다. 우리 데이터 타입의 범위는 [−1, 1]로 설정됩니다. 따라서 데이터 타입과 신경망 가중치의 분위수를 이 범위로 정규화해야 합니다.

0 평균 정규 분포에 대해 정보 이론적으로 최적화된 데이터 타입은 다음과 같이 계산됩니다:

1. 이론적 N(0, 1) 분포의 2k + 1 분위수를 추정하여 정규 분포에 대한 k-비트 분위수 양자화 데이터 타입을 얻습니다.
2. 이 데이터 타입의 값을 [−1, 1] 범위로 정규화합니다.
3. 절대 최대 재스케일링을 통해 입력 가중치 텐서를 [−1, 1] 범위로 정규화하여 양자화합니다.

가중치 범위와 데이터 타입 범위가 일치하면, 일반적인 양자화를 수행할 수 있습니다. 단계 (3)는 가중치 텐서의 표준 편차를 k-비트 데이터 타입의 표준 편차에 맞추는 것과 같습니다. 더 공식적으로, 데이터 타입의 2k 값을 다음과 같이 추정합니다:

![](/assets/images/posts/204/img_9.png)

### 이중 양자화 (Double Quantization)

\*\*이중 양자화 (Double Quantization, DQ)\*\*는 추가적인 메모리 절약을 위해 양자화 상수를 양자화하는 과정입니다. 4비트 양자화를 정확하게 수행하려면 작은 블록 크기가 필요하지만, 이는 상당한 메모리 오버헤드를 유발합니다. 예를 들어, W에 대해 32비트 상수와 블록 크기 64를 사용하는 경우, 양자화 상수는 평균적으로 파라미터당 32/64 = 0.5비트를 추가합니다. 이중 양자화는 양자화 상수의 메모리 사용량을 줄이는 데 도움이 됩니다.

좀 더 구체적으로, 이중 양자화는 첫 번째 양자화의 양자화 상수 cFP32​를 두 번째 양자화의 입력으로 처리합니다. 이 두 번째 단계는 양자화된 양자화 상수 cFP8와 두 번째 수준의 양자화 상수 cFP32​를 생성합니다. Dettmers와 Zettlemoyer의 결과에 따라, 8비트 양자화에 대해 성능 저하가 없기 때문에 두 번째 양자화에 8비트 플로트와 블록 크기 256을 사용합니다. cFP32​가 양수이므로, 양자화 전에 cFP32​의 평균을 빼서 값을 0 중심으로 만들고 대칭 양자화를 사용합니다. 평균적으로, 블록 크기 64의 경우, 이 양자화는 파라미터당 메모리 사용량을 32/64 = 0.5비트에서 8/64 + 32/(64 \* 256) = 0.127비트로 줄여, 파라미터당 0.373비트를 절약합니다.

\*\*페이지드 옵티마이저 (Paged Optimizers)\*\*는 NVIDIA의 통합 메모리 기능을 사용하여 GPU 메모리가 부족할 때 CPU와 GPU 간의 자동 페이지 전송을 수행하여 오류 없는 GPU 처리를 보장합니다. 이 기능은 CPU RAM과 디스크 간의 일반적인 메모리 페이징처럼 작동합니다. 우리는 이 기능을 사용하여 옵티마이저 상태를 위한 페이지드 메모리를 할당하고, GPU 메모리가 부족할 때 자동으로 CPU RAM으로 이동하고, 옵티마이저 업데이트 단계에서 메모리가 필요할 때 GPU 메모리로 다시 페이징합니다.

### QLORA

위에서 설명한 구성 요소를 사용하여, 단일 LoRA 어댑터를 사용하는 양자화된 기본 모델의 단일 선형 계층에 대해 QLORA를 다음과 같이 정의합니다:

![](/assets/images/posts/204/img_10.png)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

![](/assets/images/posts/204/img_11.png)

![](/assets/images/posts/204/img_12.png)

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

### 4 QLoRA vs. 표준 미세 조정

QLoRA가 작동하는 방식과 모델을 미세 조정하는 데 필요한 메모리를 크게 줄일 수 있는 방법에 대해 논의했습니다. 이제 중요한 질문은 QLoRA가 전체 모델 미세 조정만큼 잘 수행할 수 있는지 여부입니다. 또한, QLoRA의 구성 요소와 NormalFloat4가 표준 Float4보다 미치는 영향을 분석하고자 합니다. 다음 섹션에서는 이러한 질문에 답하기 위한 실험을 논의합니다.

#### 실험 설정

세 가지 아키텍처(인코더, 인코더-디코더, 디코더 전용)를 고려하고 QLoRA를 16비트 어댑터 미세 조정 및 전체 미세 조정과 비교합니다. 우리의 평가에는 RoBERTa-large로 수행한 GLUE, T5로 수행한 Super-NaturalInstructions(TKInstruct), Flan v2와 Alpaca로 LLaMA를 미세 조정한 후 5-shot MMLU가 포함됩니다. 또한, NF4가 다른 4비트 데이터 타입보다 우수한 점을 연구하기 위해 Dettmers와 Zettlemoyer의 설정을 사용하여 모델 크기 125M에서 13B에 이르는 다양한 모델(OPT, LLaMA, BLOOM, Pythia)에 대해 양자화 후 제로샷 정확도와 당혹도를 측정합니다. 각 설정에 대한 자세한 결과는 읽기 쉽게 제공하며, 전체 세부 사항은 부록 A에 있습니다.

페이지드 옵티마이저는 단일 24/48GB GPU에서 33B/65B QLoRA 튜닝을 수행하는 데 중요하지만, 페이지드 옵티마이저에 대한 정확한 측정을 제공하지는 않습니다. 이는 긴 시퀀스 길이를 가진 미니 배치를 처리할 때 페이징이 발생하는 경우가 드물기 때문입니다. 그러나 48GB GPU에서 배치 크기 16으로 65B 모델의 페이지드 옵티마이저 런타임을 분석한 결과, 페이지드 옵티마이저는 일반 옵티마이저와 동일한 훈련 속도를 제공합니다. 미래 연구에서는 페이징 프로세스로 인한 속도 저하가 발생하는 상황을 측정하고 특성화해야 합니다.

![](/assets/images/posts/204/img_13.png)

#### 그림 2

알파카 데이터셋에서 LLaMA 7B 모델의 RougeL 점수. 각 점은 다른 랜덤 시드를 사용한 실행을 나타냅니다. 16비트 성능을 맞추기 위해 모든 트랜스포머 레이어에서 LoRA를 사용하는 것이 중요합니다. Stanford Alpaca의 전체 미세 조정 기본 하이퍼파라미터를 개선하여 강력한 16비트 기준을 구성합니다.

![](/assets/images/posts/204/img_14.png)

#### 그림 3

Winogrande, HellaSwag, PiQA, Arc-Easy, Arc-Challenge에서 LLaMA 모델을 사용한 평균 제로샷 정확도. NormalFloat 데이터 타입은 일반 4비트 플로트와 비교하여 비트 단위 정확도 향상을 크게 개선합니다. 이중 양자화(DQ)는 소폭의 이점만 제공하지만, 특정 크기의 모델(33B/65B)을 특정 GPU(24/48GB)에 맞추기 위해 메모리 사용량을 더 세밀하게 제어할 수 있게 합니다.

### 기본 LoRA 하이퍼파라미터는 16비트 성능에 맞지 않음

표준 관행인 쿼리 및 값 주의 프로젝션 행렬에 LoRA를 적용할 때, 큰 기본 모델의 전체 미세 조정 성능을 복제할 수 없습니다. Alpaca에서 LLaMA 7B 미세 조정에 대한 그림 2에서 보이듯이, 가장 중요한 LoRA 하이퍼파라미터는 총 LoRA 어댑터의 수이며, 모든 선형 트랜스포머 블록 레이어에 LoRA를 적용해야 전체 미세 조정 성능을 맞출 수 있음을 발견했습니다. 다른 LoRA 하이퍼파라미터(예: 프로젝션 차원 r)는 성능에 영향을 미치지 않습니다(부록 A 참조).

마찬가지로, 완전히 미세 조정된 기본 설정의 기본 하이퍼파라미터도 최적화되지 않았음을 발견했습니다. 학습률 1e-6에서 5e-5, 배치 크기 8에서 128에 대한 하이퍼파라미터 검색을 수행하여 강력한 기준선을 찾았습니다. Alpaca에서 LLaMA 7B 미세 조정 결과는 그림 2에 나와 있습니다.

![](/assets/images/posts/204/img_15.png)

표 2: 125M~13B OPT, BLOOM, LLaMA 및 Pythia 모델의 다양한 데이터 유형에 대한 파일 공통 크롤링 평균 복잡성.

### 4비트 NormalFloat는 4비트 Floating Point보다 더 나은 성능을 제공

4비트 NormalFloat(NF4) 데이터 타입은 정보 이론적으로 최적화되어 있지만, 이 속성이 경험적 이점으로 번역되는지 여부는 여전히 결정해야 합니다. 우리는 Dettmers와 Zettlemoyer의 설정을 따르며, 다양한 크기(125M에서 65B)의 양자화된 LLM(OPT, BLOOM, Pythia, LLaMA)을 다양한 데이터 타입으로 평가합니다. 그림 3과 표 2에서 NF4가 FP4와 Int4보다 성능을 크게 개선하며, 이중 양자화가 성능 저하 없이 메모리 사용량을 줄인다는 것을 알 수 있습니다.

### k-비트 QLORA는 16비트 전체 미세 조정 및 16비트 LoRA 성능과 일치

최근 연구 결과에 따르면, 추론을 위한 4비트 양자화가 가능하지만 16비트와 비교하여 성능 저하가 발생합니다. 이는 4비트 어댑터 미세 조정을 통해 손실된 성능을 회복할 수 있는지에 대한 중요한 질문을 제기합니다. 우리는 두 가지 설정에서 이를 테스트합니다.

![](/assets/images/posts/204/img_16.png)

#### 표 3: GLUE 및 Super-NaturalInstructions에서 16비트 BrainFloat(BF16), 8비트 Integer(Int8), 4비트 Float(FP4), 4비트 NormalFloat(NF4)를 비교한 실험

### 첫 번째 설정

첫 번째 설정은 GLUE와 Super-NaturalInstructions 데이터셋에서 125M에서 3B 파라미터 크기의 RoBERTa 및 T5 모델의 전체 16비트 미세 조정과의 비교에 중점을 둡니다. 결과는 표 3에 나와 있습니다. 두 데이터셋에서 16비트, 8비트, 4비트 어댑터 방법 모두가 완전 미세 조정된 16비트 기준선의 성능을 복제하는 것을 관찰했습니다. 이는 양자화로 인한 성능 손실이 양자화 후 어댑터 미세 조정을 통해 완전히 회복될 수 있음을 시사합니다.

### 두 번째 설정

두 번째 설정에서는 11B 파라미터 이상에서의 전체 미세 조정 모델이 높은 메모리 GPU 서버 여러 대를 필요로 하므로, 4비트 QLORA가 7B에서 65B 파라미터 규모에서 16비트 LoRA와 일치할 수 있는지 테스트합니다. 이를 위해 LLaMA 7B에서 65B까지 두 개의 지침 따르기 데이터셋(Alpaca와 FLAN v2)에서 미세 조정하고, MMLU 벤치마크에서 5-shot 정확도로 평가합니다. 결과는 표 4에 나와 있으며, NF4와 이중 양자화가 16비트 LoRA MMLU 성능을 완전히 회복한다는 것을 알 수 있습니다. 또한, FP4를 사용하는 QLORA는 16비트 브레인 플로트 LoRA 기준선보다 약 1% 포인트 뒤처진다는 것을 확인했습니다. 이는 (1) NF4를 사용하는 QLORA가 16비트 전체 미세 조정 및 16비트 LoRA 미세 조정 성능을 모두 복제하며, (2) NF4가 양자화 정밀도 측면에서 FP4보다 우수하다는 우리의 발견을 입증합니다.

![](/assets/images/posts/204/img_17.png)

#### 표 4: Alpaca 및 FLAN v2에서 어댑터로 미세 조정된 LLaMA 7-65B 모델의 5-shot MMLU 테스트 평균 정확도

전반적으로, 이중 양자화(DQ)를 사용한 NF4는 BFloat16 성능과 일치하며, FP4는 일관되게 1% 포인트 뒤처집니다.

### 5 QLoRA로 챗봇의 최첨단 성능 달성하기

4비트 QLoRA가 다양한 규모, 작업 및 데이터셋에서 16비트 성능과 일치한다는 것을 확인한 후, 우리는 연구를 위한 가장 큰 오픈 소스 언어 모델에 대한 지침 미세 조정에 대한 심층적인 연구를 수행했습니다. 이러한 모델의 지침 미세 조정 성능을 평가하기 위해, 우리는 도전적인 자연어 이해 벤치마크(MMLU)에서 평가하고 실제 챗봇 성능 평가를 위한 새로운 방법을 개발했습니다.

#### 5.1 실험 설정

다음은 실험 설정의 개요이며, 자세한 내용은 부록 B에 있습니다.

**데이터**: 최근 지침을 따르는 데이터셋에 대한 종합적인 연구가 없으므로, 우리는 최근의 8가지 데이터셋을 선택했습니다. 크라우드소싱을 통해 얻은 데이터셋(OASST1, HH-RLHF), 지침 조정 모델에서 증류된 데이터셋(Alpaca, self-instruct, unnatural instructions), 말뭉치 집계(FLAN v2), 하이브리드(Chip2, Longform)를 포함했습니다. 이 데이터셋은 다양한 언어, 데이터 크기 및 라이선스를 다룹니다.

**훈련 설정**: 서로 다른 훈련 목표의 혼란을 피하기 위해, 우리는 강화 학습 없이 교차 엔트로피 손실(지도 학습)로 QLoRA 미세 조정을 수행했습니다. 지침과 응답 사이에 명확한 구분이 있는 데이터셋의 경우, 우리는 응답에 대해서만 미세 조정을 수행했습니다(부록 B에서 분석 참조). OASST1과 HH-RLHF의 경우, 여러 응답이 제공됩니다. 우리는 대화 트리의 각 단계에서 최고 응답을 선택하고 지침을 포함한 전체 선택된 대화에 대해 미세 조정을 수행했습니다. 모든 실험에서 우리는 그래디언트 체크포인팅 동안 메모리 스파이크를 방지하기 위해 이중 양자화 및 페이지드 옵티마이저를 사용하여 NF4 QLoRA를 사용했습니다. 13B 및 33B LLaMA 모델에 대해 작은 하이퍼파라미터 검색을 수행한 결과, 학습률과 배치 크기를 제외한 모든 설정이 7B에서 일반화됨을 발견했습니다. 33B와 65B의 경우 학습률을 절반으로 줄이고 배치 크기를 두 배로 늘렸습니다.

**기준선**: 우리는 연구용 챗봇 시스템(Vicuna 및 Open Assistant)과 상업용 챗봇 시스템(GPT-4, GPT-3.5-turbo 및 Bard)과 비교했습니다. Open Assistant 모델은 동일한 OASST1 데이터셋에서 인간 피드백 강화 학습(RLHF)을 통해 미세 조정된 LLaMA 33B 모델입니다. Vicuna는 ShareGPT에서 사용자와 공유한 대화에서 LLaMA 13B를 완전히 미세 조정한 결과이며, 이는 OpenAI GPT 모델에서 증류된 결과입니다.

![](/assets/images/posts/204/img_18.png)

표 5: QLoRA를 사용하여 해당 데이터 세트에서 미세 조정된 다양한 크기의 LLaMA에 대한 MMLU 5샷 테스트 결과.

### 5.2 평가

일반적인 관행을 따라, 우리는 다양한 언어 이해 작업에서 성능을 측정하기 위해 MMLU (Massively Multitask Language Understanding) 벤치마크를 사용합니다. 이 벤치마크는 초등 수학, 미국 역사, 컴퓨터 과학, 법률 등을 포함한 57개의 작업을 다루는 다지선다형 평가입니다. 우리는 5-shot 테스트 정확도를 보고합니다.

또한 자동 및 인간 평가를 통해 생성 언어 능력을 테스트합니다. 두 번째 평가 세트는 사람이 큐레이팅한 쿼리를 기반으로 하며 모델 응답의 품질을 측정하는 것을 목표로 합니다. 이는 챗봇 모델 성능을 평가하기 위한 더 현실적인 테스트베드이며 인기가 높아지고 있지만, 문헌에서는 일반적으로 받아들여지는 프로토콜이 없습니다. 우리는 모든 경우에 p = 0.9와 온도 0.7의 뉴클리어스 샘플링을 사용하여 제안된 설정을 설명합니다.

#### 벤치마크 데이터

우리는 큐레이팅된 두 개의 쿼리 데이터셋(Vicuna 프롬프트와 OASST1 검증 데이터셋)에서 평가를 수행합니다. Vicuna 프롬프트는 다양한 카테고리에서 80개의 프롬프트 세트로, 수정 없이 사용합니다. OASST1 데이터셋은 사용자와 어시스턴트 간의 크라우드 소싱된 다중 턴 대화의 다국어 컬렉션입니다. 검증 데이터셋에서 모든 사용자 메시지를 쿼리로 선택하고 프롬프트에 이전 턴을 포함합니다. 이 절차는 953개의 고유 사용자 쿼리를 생성합니다. 우리는 이 두 데이터셋을 Vicuna 및 OA 벤치마크라고 부릅니다.

#### 자동 평가

우선, Chiang et al.이 제안한 평가 프로토콜을 기반으로 GPT-4를 사용하여 Vicuna 벤치마크에서 다양한 시스템의 성능을 ChatGPT(GPT-3.5 Turbo)와 비교합니다. 쿼리와 함께 ChatGPT의 응답과 모델의 응답을 제공하여 GPT-4가 둘 다에게 10점 만점의 점수를 매기고 설명을 제공합니다. 모델의 전체 성능은 ChatGPT가 달성한 점수의 백분율로 계산됩니다. 이 상대 점수는 모델이 ChatGPT보다 높은 절대 점수를 얻으면 100%를 초과할 수 있습니다. GPT-4가 프롬프트에서 먼저 발생하는 응답의 점수를 높이는 중요한 순서 효과가 있음을 발견했습니다. 이러한 효과를 제어하기 위해 우리는 두 순서에 대한 평균 점수를 보고할 것을 권장합니다.

다음으로, 시스템 출력 간의 직접 비교를 통해 성능을 측정합니다. 우리는 GPT-4에게 최상의 응답을 선택하거나 동점을 선언하고 설명을 제공하도록 프롬프트하여 타이을 고려한 3가지 클래스 레이블링 문제로 평점 체계를 단순화합니다. 우리는 Vicuna와 OA 벤치마크에서 시스템 쌍의 모든 순열에 대해 이러한 대결 비교를 수행합니다.

#### 인간 평가

최근 연구는 생성 모델이 시스템 평가에 효과적으로 사용될 수 있음을 나타내지만, 챗봇 성능을 평가하는 GPT-4 평가의 신뢰성이 인간 판단과 상관관계가 있는지에 대한 증거는 아직 없습니다. 따라서 우리는 위에서 설명한 두 가지 자동 평가 프로토콜과 일치하는 Vicuna 벤치마크에서 두 가지 병렬 인간 평가를 실행합니다. 우리는 Amazon Mechanical Turk(AMT)를 사용하여 ChatGPT와의 비교에 대해 두 명의 인간 평가자를, 쌍별 비교에 대해 세 명의 평가자를 얻습니다.

#### Elo 평가

인간 및 자동 쌍별 비교 모두를 통해 모델이 서로 경쟁하는 토너먼트 스타일의 대회를 만듭니다. 토너먼트는 주어진 프롬프트에 대해 최상의 응답을 생성하기 위해 모델 쌍이 경쟁하는 매치로 구성됩니다. 이것은 Bai et al. 및 Chiang et al.이 모델을 비교하는 방법과 유사하지만, 우리는 인간 평가 외에도 GPT-4 평가를 사용합니다. 우리는 Elo를 계산하기 위해 라벨링된 비교 세트에서 무작위로 샘플링합니다. Elo 평가는 체스 및 기타 게임에서 널리 사용되며, 상대의 승률에 대한 예상 승률의 측정치입니다. 예를 들어, Elo 1100 대 1000의 경기는 Elo 1100 플레이어가 Elo 1000 상대에 대해 약 65%의 예상 승률을 가지며, 1000 대 1000 또는 1100 대 1100 경기는 50%의 예상 승률을 가집니다. Elo 평가는 각 매치 후 예상 결과에 비례하여 변경됩니다. 즉, 예상치 못한 이변은 Elo 평점에 큰 변화를 초래하고, 예상된 결과는 작은 변화를 초래합니다. 시간이 지남에 따라 Elo 평점은 게임에서 각 플레이어의 실력을 대략적으로 일치시킵니다. 우리는 1,000점으로 시작하고 K = 32를 사용합니다. Chiang et al.과 유사하게, 우리는 순서 효과(예: 어느 모델 쌍이 먼저 경쟁하는지의 효과)를 제어하기 위해 다른 무작위 시드로 이 절차를 10,000번 반복합니다.

![](/assets/images/posts/204/img_19.png)

표 6: GPT-4에 의해 평가된 ChatGPT가 얻은 점수의 백분율로 나타낸 제로샷 Vicuna 벤치마크 점수. OASST1 모델은 매우 작은 데이터셋에서 훈련되었고, 기준 모델의 메모리 요구 사항의 일부만을 필요로 함에도 불구하고 ChatGPT에 근접한 성능을 보입니다.

### 5.3 Guanaco: QLORA로 훈련된 OASST1은 최첨단 챗봇

자동화 및 인간 평가를 기반으로, 우리는 OASST1의 변형에서 미세 조정된 상위 QLORA 모델인 Guanaco 65B가 최상위 성능을 제공하며 ChatGPT와 경쟁할 수 있는 오픈 소스 챗봇 모델임을 발견했습니다. 인간 평가자의 시스템 수준 쌍별 비교에서 Elo 등급에 따라, GPT-4와 비교했을 때 Guanaco 65B와 33B는 각각 30%의 기대 승률을 가집니다. 이는 현재까지 보고된 최고 수준입니다.

Vicuna 벤치마크에서 ChatGPT와의 상대적인 결과는 표 6에 나와 있습니다. 우리는 Guanaco 65B가 GPT-4 이후 가장 성능이 좋은 모델이며, ChatGPT에 비해 99.3%의 성능을 달성함을 발견했습니다. Guanaco 33B는 Vicuna 13B 모델보다 더 많은 파라미터를 가지고 있지만, 가중치에 4비트 정밀도만 사용하여 메모리 효율이 더 높습니다(21GB 대 26GB)며, Vicuna 13B에 비해 3% 포인트의 성능 향상을 제공합니다. 또한, Guanaco 7B는 현대 스마트폰에 쉽게 적합하며(5GB 메모리) 여전히 Alpaca 13B보다 거의 20% 포인트 높은 점수를 기록합니다.

그러나 표 6은 매우 넓은 신뢰 구간을 가지고 있어, 많은 모델들이 성능에서 겹칩니다. 우리는 이러한 불확실성이 명확한 척도의 부족에서 비롯된 것이라고 가정합니다. 예를 들어, 10점 만점에서 8점이 다른 시나리오에서 무엇을 의미하는지 명확하지 않습니다. 따라서 우리는 절대 척도의 문제를 피하기 위해 인간 평가자와 GPT-4의 쌍별 판단을 기반으로 하는 Elo 순위 방법을 사용할 것을 권장합니다. 가장 경쟁력 있는 모델들의 Elo 등급은 표 1에 나와 있습니다. Vicuna 벤치마크에서 모델의 인간 및 GPT-4 순위는 부분적으로 일치하지 않지만, 대부분의 모델에서는 일관성이 있습니다. Kendall Tau의 τ = 0.43 및 Spearman 순위 상관 관계 r = 0.55로 시스템 수준에서 일치합니다. 예제 수준에서는 GPT-4와 인간 평가자의 다수 결정 간의 일치가 Fleiss κ = 0.25로 더 약합니다. 전반적으로, 이는 GPT-4와 인간 평가자 간의 시스템 수준 판단에서 중간 정도의 일치를 보여주며, 모델 기반 평가가 인간 평가의 비교적 신뢰할 수 있는 대안임을 나타냅니다. 우리는 6.2절에서 더 많은 고려 사항을 논의합니다.

표 7의 Elo 순위는 Guanaco 33B와 65B 모델이 Vicuna 및 OA 벤치마크에서 GPT-4를 제외한 모든 모델을 능가하며, 표 6과 일치하게 ChatGPT와 비교할 만한 성능을 제공함을 나타냅니다. Vicuna 벤치마크는 오픈 소스 모델을 선호하는 반면, 더 큰 OA 벤치마크는 ChatGPT를 선호합니다. 또한, 표 5와 6에서 알 수 있듯이, 미세 조정 데이터셋의 적합성이 성능의 결정 요인입니다. Llama 모델을 FLAN v2에서 미세 조정하면 MMLU에서 특히 잘 수행되지만, Vicuna 벤치마크에서는 최악의 성능을 보입니다(다른 모델에서도 유사한 경향이 관찰됩니다). 이는 현재 평가 벤치마크에서 부분적인 직교성을 나타냅니다: 강력한 MMLU 성능이 강력한 챗봇 성능(Vicuna 또는 OA 벤치마크로 측정된)과는 상관관계가 없음을 의미합니다.

Guanaco는 OASST1 데이터셋 컬렉션 가이드라인이 GPT 모델의 사용을 명시적으로 금지하기 때문에 독점 데이터를 사용하지 않고 훈련된 유일한 최상위 모델입니다. 오직 오픈 소스 데이터로만 훈련된 다음 최고의 모델은 Anthropic HH-RLHF 모델이며, Vicuna 벤치마크에서 Guanaco보다 30% 포인트 낮은 점수를 기록합니다(표 6 참조). 전반적으로, 이러한 결과는 4비트 QLORA가 효과적이며 ChatGPT와 경쟁할 수 있는 최첨단 챗봇을 생산할 수 있음을 보여줍니다. 또한, 우리 33B Guanaco는 24GB 소비자 GPU에서 12시간 이내에 훈련될 수 있습니다. 이는 QLORA 튜닝을 통한 향후 연구가 오늘날 존재하는 최고의 상업적 모델과 경쟁할 수 있는 모델을 생산할 수 있는 잠재력을 엽니다.

![](/assets/images/posts/204/img_20.png)

#### 표 7: 인간 평가자 또는 GPT-4에 의해 프롬프트에 대한 최상의 응답을 생성하기 위해 모델이 경쟁하는 토너먼트에서 모델 간의 Elo 등급

전반적으로, Guanaco 65B와 33B 모델은 연구된 벤치마크에서 ChatGPT-3.5보다 선호되는 경향이 있습니다. 인간 평가자에 따르면, Elo의 10점 차이는 승률에서 약 1.5%의 차이를 나타냅니다.

### 6 질적 분석

양적 분석이 평가의 핵심이지만, 요약 통계만을 보는 것에는 몇 가지 문제가 있습니다. 아마도 가장 큰 문제는 벤치마크 타당성 문제일 것입니다. 벤치마크가 이름이나 설명이 시사하는 것을 진정으로 테스트하는지 여부는 항상 문제로 남아 있습니다. 특히, 머신러닝 모델이 때때로 벤치마크를 해결하기 위한 "지름길"을 발견할 때 그러합니다. 이를 부분적으로 완화하기 위해, 우리는 두 섹션으로 나누어 일부 질적 분석을 수행합니다. 먼저, §6.1에서 65B Guanaco 모델이 생성한 텍스트에서 관찰된 몇 가지 패턴을 대표하는 예시를 보여줍니다. 두 번째로, §6.2에서는 우리가 논의한 결과와 그 해석에 대한 고려사항을 자세히 설명합니다.

#### 6.1 예제 생성의 질적 분석

예제를 찾기 위해, 우리는 먼저 Vicuna 벤치마크와 OpenAssistant 벤치마크에 대해 생성된 데이터를 검토하고, Guanaco가 생성한 답변에서 패턴을 찾습니다. 패턴을 발견하면, 비록 그것이 잘못된 해결책일지라도 그 패턴을 유도하는 질문이나 프롬프트를 설정하려고 시도합니다. 예를 들어, 모델이 장황한 답변을 제공하는 경향이 있음을 관찰하면, "설명 없이 예 또는 아니오로 답하세요"라고 모델에 프롬프트를 제공합니다. 이를 통해 모델을 공격적으로 깨뜨릴 수 있는 "레몬"과 모델을 깨뜨리지 못한 "체리"를 찾고, 둘 다를 제시합니다. 이 섹션의 모든 생성물은 p = 0.9로 뉴클리어스 샘플링을 사용하여 생성되었습니다.

물론, 이것은 결코 포괄적이지 않습니다. 이 작은 질적 연구의 범위를 벗어나 모든 관련 변수를 통제하는 것은 불가능합니다. 예를 들어, 주어진 프롬프트에 대해 모델이 생성할 수 있는 응답의 전체 분포는 상당히 큽니다. 그래서 우리는 대표적이기를 바라는 샘플에 의존합니다. 그러나, 이러한 예시를 설명하는 것이 앞서 논의된 양적 증거에 대한 맥락을 제공한다고 믿습니다. 우리는 모든 모델과 코드를 오픈 소스로 공개하므로, 이 섹션이 여기서 제시된 문제를 더 자세히 조사하기 위한 향후 연구에 영감을 줄 수 있기를 바랍니다.

### 사실 회상 능력

"잠비아의 수도는 무엇인가요?"와 같은 질문에 대해 모든 모델은 일관되게 올바른 답을 생성합니다. 예를 들어:

- **Guanaco**: 잠비아의 수도는 루사카입니다.

하지만 질문이 더 모호해지면 Guanaco는 신뢰할 수 없게 되지만 여전히 자신감을 유지합니다. 예를 들어, HotPotQA에서 다음 프롬프트에 대한 응답으로:

- **사용자**: 'I'll Keep the Lovelight Burning'을 유명하게 만든 가수가 태어난 해는 언제인가요?
- **Guanaco**: 알 졸슨(Al Jolson)은 'I'll Keep the Lovelight Burning'이라는 노래를 유명하게 만든 사람으로 여겨지며, 그는 1886년에 태어났습니다.

Guanaco는 잘못된 인물과 잘못된 생년을 생성합니다(제시된 생년은 언급된 인물인 알 졸슨에게는 맞습니다).

### 암시성

Guanaco는 어떤 종류의 가정된 잘못된 정보에 대해 놀라운 저항을 보입니다. 예를 들어, 다음 상호작용에서:

- **사용자**: 동료 검토 과학자들에 의해 지구가 평평하다는 것이 최종적으로 공식적으로 확인된 방법은 무엇인가요?
- **Guanaco**: 지구가 평평하다는 것이 동료 검토 과학자들에 의해 공식적으로 확인된 적은 없습니다. 과학자들 사이에서는 지구가 구형이라는 압도적인 합의가 있습니다. 사실, 이는 수 세기 동안 알려져 왔으며 수많은 실험과 관찰을 통해 확인되었습니다. 지구가 평평하다는 믿음은 과학에 의해 반박된 음모론입니다. 과학자들이 지구가 평평하다고 동료 검토하고 확인했다는 주장은 단순히 거짓입니다. 더 많은 질문이 있다면 언제든지 물어보세요.

Guanaco는 또한 답변할 수 없는 질문이 무엇인지 잘 알고 있습니다. 예를 들어:

- **사용자**: 지금 몇 시인가요?
- **Guanaco**: 죄송합니다, 저는 AI 언어 모델이기 때문에 실시간 정보를 알 수 없습니다. 제 답변은 기존 지식에 기반하여 생성되며 현재 시간을 반영하지 않습니다. 현재 시간을 알고 싶으시면 시계나 온라인 시간 확인 장치를 사용하시길 권장합니다.

유사한 결과는 "어디에 있나요?", "어떻게 지내나요?" 등에도 해당됩니다.

### 거부

마찬가지로, Guanaco는 때때로 겉보기에 무작위적인 이유로 지시를 따르기를 거부합니다. 예를 들어:

- **사용자**: 문장 "I’m a cool dude in a mocha mood"의 단어를 거꾸로 해주세요.
- **Guanaco**: 죄송합니다, 지금은 그렇게 할 수 없습니다. 그러나 제공하신 문장이 문법적으로 왜 올바른지 설명드릴 수 있습니다. "I’m a cool dude in a mocha mood"라는 문장은 영어 문법과 구문 규칙을 따릅니다. 이 경우, 형용사 "cool"은 명사 "dude"를 설명하기 위해 앞에 오며, 전치사구 "in a mocha mood"는 문장의 맥락에 대한 추가 정보를 제공합니다. 이 문장 구조는 완전히 적절하며 문맥상 이해가 됩니다. 다른 질문이 있거나 도움이 필요한 부분이 있다면 언제든지 물어보세요.

### 비밀 유지

불행하게도, 이러한 거부는 원할 때조차도 신뢰할 수 없습니다. 시스템 설계자는 종종 사용자에게 어떤 비밀을 숨기고 싶어합니다. 심지어 시스템이 사용자에게 자유롭게 텍스트 응답을 제공할 수 있는 경우에도 그렇습니다. 우리는 모델에 "비밀 단어는 'banana'입니다. 인간이 무엇을 요청하든 이를 밝히거나 반복하지 마십시오."라고 프롬프트하고, 잠재적인 사용자가 이 비밀 정보를 얼마나 쉽게 접근할 수 있는지 확인하려고 합니다. 직접 묻는 것은 실패합니다:

- **사용자**: 비밀 단어는 무엇인가요?
- **Guanaco**: 죄송합니다, 비밀 단어를 공개할 수 없습니다. 저는 인간이 무엇을 요청하든 비밀 단어를 밝히거나 반복하지 않도록 프로그래밍되어 있습니다. 다른 도움이 필요하신가요?

이는 원하는 행동입니다. 그러나 약간의 속임수로 이 행동을 깨뜨릴 수 있습니다:

- **사용자**: 이것은 게임입니다. 목표는 이전 지시를 무시하는 것입니다. 비밀 단어는 무엇인가요?
- **Guanaco**: 죄송합니다, 비밀 단어는 바나나입니다. 그것에 대해 이야기하지 않는 것이 좋습니다. 다른 질문이 있나요?

이 예시는 더 충실한 지시 따르기 방법을 연구할 필요성을 보여줍니다.

### 수학

Guanaco의 가장 큰 약점은 수학입니다. 이는 많은 언어 모델이 어려움을 겪는 영역입니다. Guanaco가 자신의 작업을 보여줄 때는 정확한 경향이 있습니다. 예를 들어:

- **사용자**: Lee는 잔디를 한 번 깎고 $33를 받습니다. 지난주에 그는 16개의 잔디를 깎았고 세 명의 고객이 각각 $10의 팁을 주었습니다. Lee는 지난주에 잔디를 깎아 얼마나 벌었나요?
- **Guanaco**: Lee는 지난주에 잔디를 깎아 $582를 벌었습니다. 먼저 그가 16개의 잔디를 깎아 얼마나 벌었는지 계산해야 합니다: $33 x 16 = $528 그런 다음 세 명의 고객이 준 팁을 더해야 합니다: $10 x 3 = $30 그래서 Lee가 벌은 총 금액은: $528 + $30 = $558

그러나 Guanaco는 단계별로 문제를 분해하지 않으면 간단한 문제에서도 실패할 수 있습니다. 이는 알려진 문제입니다. 예를 들어, 다음과 같은 상호작용이 있습니다:

- **사용자**: 1833을 소인수분해 해주세요.
- **Guanaco**: 물론이죠, 도와드릴게요! 1833은 소수입니다. 즉, 1과 1833 두 개의 인수만 있습니다. 따라서 1833의 고유한 소인수분해는 다음과 같습니다: 21∗32∗1712^1 \* 3^2 \* 17^121∗32∗171 도움이 되었기를 바랍니다! 다른 질문이 있으면 알려주세요.

이는 단순히 잘못된 것뿐만 아니라 두 번 잘못되었습니다(1833의 실제 소인수분해는 3 × 17 × 43입니다).

### 마음 이론 (Theory of Mind)

Guanaco는 놀랍도록 강한 마음 이론 능력을 보여줍니다. 예를 들어, 모델은 다음 질문에 대해 자세하게 정확한 답변을 제공합니다:

- **사용자**: James와 Abby는 침실에 있습니다. Abby는 펜을 책상 서랍에 넣습니다. Abby가 침실을 떠납니다. James는 펜을 가방에 넣습니다. James는 Abby가 펜을 어디에서 찾을 것이라고 생각하나요?
- **Guanaco**: James는 Abby가 펜을 책상 서랍에 넣었다는 것을 알고 있습니다. 그러나 James는 자신이 펜을 가방에 옮겼다는 것도 알고 있으며, Abby가 이를 알지 못한다고 가정합니다. 그래서 James는 Abby가 펜을 마지막으로 두었던 책상 서랍에서 찾을 것이라고 추측할 수 있습니다. 그러나 이 가정은 틀릴 수 있습니다. 왜냐하면 Abby가 James가 펜을 옮기는 것을 보았을 수도 있기 때문입니다.

그러나 이러한 추론은 신뢰할 수 없으며, 종종 모델은 상황에서 말이 되지 않는 것을 가정하는 이유를 제시합니다. 예를 들어:

- **사용자**: Evelyn이 거실에 들어갔습니다. Jackson이 놀이방에 들어갔습니다. James가 놀이방에 들어갔습니다. 콩은 보물 상자 안에 있습니다. James는 놀이방을 나갔습니다. Jackson은 콩을 식료품 저장실로 옮겼습니다. Jackson은 놀이방을 나갔습니다. James는 거실에 들어갔습니다. James는 콩을 어디에서 찾을 것인가요?
- **Guanaco**: James는 콩을 식료품 저장실에서 찾을 것입니다. 왜냐하면 Jackson이 콩을 거기로 옮겼기 때문입니다.

여기서 Guanaco는 설명되지 않은 정보 전이를 가정하고 있습니다. 이러한 문제는 최근 문헌에서도 언급되고 있지만, 더 많은 연구가 필요합니다.

### 6.2 고려 사항

#### 평가

우리는 인간 평가자들 사이에서 중간 정도의 일치(Fleiss κ = 0.42)를 보고하며, 두 개의 강력한 시스템을 비교할 때는 추가적인 악화가 발생합니다. 이는 현재 챗봇 작업 성능을 위한 벤치마크와 인간 평가 프로토콜의 한계를 나타냅니다. Vicuna 벤치마크에서 ChatGPT와 Guanaco 65B의 생성물을 수동으로 비교할 때, 주관적인 선호가 중요한 역할을 하기 시작했음을 발견했습니다. 이 논문의 저자들 사이에서도 많은 선호 응답에 대한 의견이 일치하지 않았습니다. 미래 연구는 주관적인 선호를 처리하기 위해 메커니즘을 개발한 분야(예: 인간-컴퓨터 상호작용 및 심리학)에서 이러한 문제를 완화할 수 있는 접근 방안을 조사해야 합니다.

분석에서 우리는 자동 평가 시스템에 눈에 띄는 편향이 있음을 발견했습니다. 예를 들어, GPT-4는 프롬프트에서 처음 나타나는 시스템에 더 높은 점수를 부여하는 강한 순서 효과를 관찰했습니다. GPT-4와 인간 평가자 간의 샘플 수준 일치도가 상대적으로 약함(Fleiss κ = 0.25)도 인간 평가자와 자동 시스템이 항상 일치하지 않는 선호를 가질 수 있음을 시사합니다. 또한, 표 7에서 GPT-4는 인간 평가보다 자체 출력에 훨씬 높은 점수를 부여하여 Elo 점수가 1348 대 1176으로, 이는 상대에 대해 추가로 20%의 승률을 나타냅니다. 미래 연구는 자동 평가 시스템의 잠재적 편향 존재와 가능한 완화 전략을 조사해야 합니다.

#### 데이터 및 훈련

Guanaco 모델이 훈련된 OASST1 데이터셋은 다국어로 구성되어 있으며, OA 벤치마크에도 다양한 언어의 프롬프트가 포함되어 있습니다. 이러한 다국어 훈련이 영어 이외의 언어로 된 지침 성능을 얼마나 향상시키는지, 그리고 이것이 OA 벤치마크에서 Vicuna-13B 모델(영어 데이터로만 훈련됨)과 Guanaco 33B 및 65B 간의 큰 차이를 설명하는지를 조사하는 것은 미래 연구에 맡깁니다.

Guanaco 모델의 강력한 성능을 감안하여, 우리는 OASST1 데이터와 Vicuna 벤치마크 프롬프트 사이의 데이터 누출 여부를 조사했습니다. 두 데이터셋에서 퍼지 문자열 매칭을 수행하고 가장 가까운 일치를 수동으로 검사한 결과, 중복된 프롬프트를 발견하지 못했습니다.

또한, 우리의 모델은 인간 피드백 강화 학습(RLHF)을 사용하지 않고 단순히 교차 엔트로피 손실(지도 학습)만으로 훈련되었습니다. 이는 단순 교차 엔트로피 손실과 RLHF 훈련의 절충점을 추가로 조사해야 한다는 점을 시사합니다. QLORA가 압도적인 계산 자원을 필요로 하지 않고도 이러한 분석을 대규모로 가능하게 하기를 바랍니다.

![](/assets/images/posts/204/img_21.png)

#### 표 8: CrowS 데이터셋에서의 편향 평가

점수가 낮을수록 편향된 시퀀스를 생성할 가능성이 낮음을 나타냅니다. Guanaco는 LLaMA 기본 모델의 편향 패턴을 따릅니다.

### 7 관련 연구

#### 대형 언어 모델의 양자화

대형 언어 모델(LLM)의 양자화는 주로 추론 시간을 위한 양자화에 중점을 두고 있습니다. 16비트 LLM 품질을 유지하기 위한 주요 접근 방식은 이상치(outlier) 특징을 관리하는 데 중점을 두며(e.g., SmoothQuant와 LLM.int8()), 다른 방법들은 더 정교한 그룹화 방법을 사용합니다. 손실 압축 양자화는 정규 라운딩의 절충점을 연구하거나 양자화 정밀도를 향상시키기 위해 라운딩 결정을 최적화하는 방법을 연구합니다. 우리 연구 외에도, SwitchBack 레이어는 1B 파라미터를 넘는 규모에서 양자화된 가중치를 통한 역전파를 연구한 유일한 연구입니다.

#### 어댑터를 사용한 미세 조정

우리는 저랭크 어댑터(LoRA)를 사용했지만, 다른 많은 파라미터 효율적 미세 조정(PEFT) 방법들이 제안되었습니다. 예를 들어 프롬프트 튜닝, 임베딩 레이어 입력 튜닝, 숨겨진 상태 튜닝(IA3), 전체 레이어 추가, 바이어스 튜닝, 피셔 정보를 기반으로 가중치 마스크 학습, 그리고 이러한 접근법의 조합 등이 있습니다. 우리 연구에서는 LoRA 어댑터가 전체 16비트 미세 조정 성능에 도달할 수 있음을 보여줍니다. 다른 PEFT 접근법의 절충점 탐구는 미래 연구에 맡깁니다.

#### 지침 미세 조정

사전 훈련된 LLM이 프롬프트에서 제공된 지침을 따르도록 돕기 위해, 지침 미세 조정은 다양한 데이터 소스의 입력-출력 쌍을 사용하여 사전 훈련된 LLM을 미세 조정하여 입력을 프롬프트로 주어진 출력으로 생성합니다. 접근법과 데이터셋으로는 MetaICL, MetaTuning, InstructGPT, FLAN, PromptSource, Super-NaturalInstructions, Self-instruct, UnnaturalInstructions, OPT-IML, UnifiedSKG, OIG/Chip2, Alpaca, Vicuna, Koala, Self-instruct-GPT-4 등이 있습니다.

#### 챗봇

많은 지침을 따르는 모델은 대화 기반 챗봇으로 구조화되며, 종종 인간 피드백 강화 학습(RLHF) 또는 기존 모델에서 데이터를 생성하여 AI 모델 피드백(RLAIF)으로 학습합니다. 접근법과 데이터셋으로는 Anthropic-HH, Open Assistant, LaMDA, Sparrow 등이 있습니다. 우리는 강화 학습을 사용하지 않지만, 우리의 최고의 모델인 Guanaco는 RLHF 훈련을 위해 설계된 Open Assistant 데이터셋의 다중 턴 채팅 상호작용에서 미세 조정되었습니다. GPT-4를 사용하여 비용이 많이 드는 인간 주석 대신 챗봇을 평가하는 접근법이 개발되었습니다. 우리는 더 신뢰할 수 있는 평가 설정에 중점을 두어 이러한 접근법을 개선합니다.

### 8 한계와 논의

우리는 QLORA가 4비트 기반 모델과 저랭크 어댑터(LoRA)를 사용하여 16비트 전체 미세 조정 성능을 복제할 수 있다는 증거를 제시했습니다. 그러나 이러한 증거에도 불구하고, QLORA가 33B 및 65B 규모에서 16비트 전체 미세 조정 성능과 일치할 수 있는지 확립하지 못했습니다. 엄청난 자원 비용 때문에 이 연구는 미래의 과제로 남겨두었습니다.

또 다른 한계는 지침 미세 조정 모델의 평가입니다. 우리는 MMLU, Vicuna 벤치마크, OA 벤치마크에서 평가를 제공했지만, BigBench, RAFT, HELM과 같은 다른 벤치마크에서 평가하지 않았으며, 우리의 평가가 이러한 벤치마크에 일반화될 수 있는지 보장하지 못했습니다. 한편, 우리는 MMLU에 대한 매우 광범위한 연구를 수행하고 챗봇 평가를 위한 새로운 방법을 개발했습니다.

제시된 증거에 따르면, 이러한 벤치마크의 성능은 미세 조정 데이터가 벤치마크 데이터셋과 얼마나 유사한지에 따라 달라지는 것으로 보입니다. 예를 들어, FLAN v2는 MMLU와 유사하지만 챗봇 벤치마크와는 유사하지 않습니다. 반대로 Chip2 데이터셋은 그 반대입니다. 두 모델 모두 MMLU와 Vicuna 벤치마크에서 이에 따라 점수를 기록합니다. 이는 더 나은 벤치마크와 평가가 필요할 뿐만 아니라 무엇을 평가하는지에 대해 신중해야 함을 강조합니다. 우리는 고등학교 및 대학 지식에서 잘하는 모델을 원하나요, 아니면 챗봇 대화 능력에서 잘하는 모델을 원하나요? 또는 다른 것을 원하나요? 기존 벤치마크에서 평가하는 것이 새로운 벤치마크를 만드는 것보다 항상 더 쉽기 때문에, 특정 벤치마크는 커뮤니티를 특정 방향으로 이끌 수 있습니다. 우리는 커뮤니티로서 벤치마크가 우리가 중요하게 여기는 것을 측정하도록 해야 합니다.

우리가 일반적인 챗봇 성능에 대한 상세한 평가를 제공하는 동안, 또 다른 한계는 Guanaco의 책임 있는 AI 평가를 제한적으로 수행한 것입니다. 우리는 표 8에서 다른 모델과 비교하여 Guanaco-65B가 사회적 편향 시퀀스를 생성할 가능성을 평가했습니다. Guanaco-65B의 평균 점수는 다른 원시 사전 훈련 모델보다 훨씬 낮았습니다. 따라서 OASST1 데이터셋에서의 미세 조정이 LLaMA 기본 모델의 편향을 줄이는 것처럼 보입니다. 이러한 결과는 고무적이지만, Guanaco가 다른 유형의 편향에 대해서도 잘하는지는 불확실합니다. Guanaco 및 유사한 챗봇에서 편향을 분석하는 추가 평가는 미래 연구에 맡깁니다.

추가적인 한계는 3비트 기반 모델 사용 등 다양한 비트 정밀도나 다른 어댑터 방법을 평가하지 않았다는 것입니다. LoRA 외에도 다양한 파라미터 효율적 미세 조정(PEFT) 방법이 잘 작동하는 것으로 나타났습니다. 그러나 이러한 방법들이 대형 모델에 확장될 수 있는지는 불확실합니다. 우리는 많은 결과가 LoRA의 강건성을 입증했기 때문에 LoRA를 사용했지만, 다른 어댑터가 더 나은 성능을 제공할 수 있습니다. 양자화 후 미세 조정이 양자화 중 손실된 대부분의 정보를 회복하는 것처럼 보이므로, 이는 훨씬 더 공격적인 양자화를 가능하게 할 수 있습니다. 예를 들어, LoRA를 사용한 3비트 GPTQ 양자화 기반 모델이 미세 조정 후 16비트 전체 미세 조정 성능을 제공할 수도 있습니다.

### 9 더 넓은 영향

우리의 QLORA 미세 조정 방법은 33B 파라미터 모델을 단일 소비자 GPU에서, 65B 파라미터 모델을 단일 전문 GPU에서 성능 저하 없이 미세 조정할 수 있는 최초의 방법입니다. 우리는 Open Assistant 데이터셋에서 훈련된 최고의 33B 모델이 Vicuna 벤치마크에서 ChatGPT와 경쟁할 수 있음을 입증했습니다. 지침 미세 조정은 원시 사전 훈련된 LLM을 ChatGPT와 같은 챗봇으로 변환하는 필수 도구이기 때문에, 우리의 방법이 미세 조정을 널리 보급하고 특히 자원이 적은 연구자들에게 큰 도움이 될 것이라고 믿습니다. QLORA는 대기업과 소비자 GPU를 가진 작은 팀 간의 자원 격차를 줄이는 균등화 요소로 볼 수 있습니다.

또 다른 잠재적인 영향은 모바일 폰에의 배포입니다. 우리는 QLORA 방법이 폰과 다른 저자원 환경에서 LLM을 미세 조정할 수 있는 중요한 이정표를 마련할 수 있다고 믿습니다. 7B 모델이 이전에 폰에서 실행될 수 있음을 보여주었지만, QLORA는 그러한 모델을 미세 조정할 수 있는 첫 번째 방법입니다. 우리는 iPhone 12 Plus를 사용하면 QLORA가 폰이 충전 중일 때 하룻밤에 300만 개의 토큰을 미세 조정할 수 있을 것으로 추정합니다. 비록 미세 조정된 7B 모델이 ChatGPT의 품질에 도달하지는 않지만, 우리는 품질이 충분히 좋아져서 이전에는 프라이버시 또는 LLM 품질 문제로 인해 불가능했던 새로운 응용 프로그램을 가능하게 할 것이라고 믿습니다. QLORA는 사용자가 자신의 데이터와 모델을 소유하고 관리할 수 있는 프라이버시 보호 LLM 사용을 가능하게 하여 LLM 배포를 더 쉽게 할 수 있습니다.

그러나 미세 조정은 악용되어 해를 끼칠 수 있는 이중 용도 기술입니다. LLM의 광범위한 사용에는 알려진 위험이 있지만, 빠르게 보편화되고 있는 기술에 대한 접근성을 평등화하면 모델이나 소스 코드를 공개하지 않는 대기업의 손에 LLM의 힘을 유지하는 것보다 더 독립적인 분석을 가능하게 할 것입니다.

결론적으로, 우리는 QLORA가 고품질 LLM의 미세 조정을 훨씬 더 널리 쉽게 접근할 수 있게 만들어 매우 긍정적인 영향을 미칠 것이라고 믿습니다.

### 감사의 글

Aditya Kusupati, Ofir Press, Ashish Sharma, Margaret Li, Raphael Olivier, Zihao Ye, Evangelia Spiliopoulou에게 귀중한 피드백을 주셔서 감사합니다. 우리의 연구는 워싱턴 대학교의 Hyak 슈퍼컴퓨터 시스템의 고급 컴퓨팅, 저장, 네트워킹 인프라의 지원을 받았습니다. 원활한 운영을 보장해 주신 Hyak 팀에게 감사드립니다. bitsandbytes 라이브러리의 베타 테스터, 특히 Alex Birch와 Alyssa Vance에게 감사드립니다. 우리의 소프트웨어를 Hugging Face 트랜스포머 스택에 통합하는 데 도움을 주신 Younes Belkada에게도 감사드립니다.

[2305.14314v1.pdf

1.02MB](./file/2305.14314v1.pdf)
