---
title: "AutoVFX: Physically Realistic Video Editing from Natural Language Instructions"
date: 2025-01-20 21:52:51
categories:
  - 인공지능
tags:
  - autovfx
---

<https://arxiv.org/abs/2411.02394>

[AutoVFX: Physically Realistic Video Editing from Natural Language Instructions](https://arxiv.org/abs/2411.02394)

**개요(Abstract)**  
현대의 시각효과(VFX) 소프트웨어는 숙련된 아티스트가 사실상 어떤 장면도 만들 수 있을 만큼 발전했습니다. 그러나 이러한 제작 과정은 여전히 많은 노력과 복잡한 절차가 필요하며, 일반 사용자가 쉽게 접근하기는 어렵습니다. 본 연구에서는 자연어 지시와 단 하나의 비디오만을 입력으로 받아, 자동으로 사실적이고 역동적인 VFX 영상을 생성하는 프레임워크인 **AutoVFX**를 소개합니다. 신경(scene) 모델링, LLM 기반 코드 생성, 물리 시뮬레이션을 세심하게 통합한 AutoVFX는 물리적으로 타당하고 사진처럼 사실적인 편집 효과를 자연어 지시만으로도 직접 제어할 수 있게 합니다. 우리는 다양한 종류의 비디오와 지시에 대해 폭넓은 실험을 수행하여 AutoVFX의 효율성을 검증하였으며, 실험 결과 AutoVFX가 생성 품질, 지시 적합성, 편집 범용성, 물리적 개연성 측면에서 경쟁 기법들을 크게 앞선다는 것을 정량적·정성적 결과로 확인했습니다.

![](/assets/images/posts/496/img.png)

**그림 1**: AutoVFX는 비디오와 언어 지시를 입력으로 받아, 지시에 맞춰 새로운 영상을 생성하기 위해 자동으로 프로그램을 작성합니다. 이 과정에서 색상이나 형상을 변경하고, 동적인 상호작용을 구현하며, 입자 효과를 적용하거나 심지어 애니메이션 캐릭터를 삽입하는 것도 가능합니다. 결과물은 사실적이고 물리적으로 타당하며, 간편하게 제어할 수 있습니다.

![](/assets/images/posts/496/img_1.png)

**그림 2**: AutoVFX 프레임워크. 본 연구에서 제시하는 지시 기반 비디오 편집 프레임워크는 크게 세 가지 주요 모듈로 구성됩니다: (1) **3D 장면 모델링(왼쪽)**, 3D 재구성 및 장면 이해 모델을 통합해 3D 정보를 추출; (2) **프로그램 생성(가운데)**, 사용자의 지시에 따라 LLM이 편집 프로그램을 생성; (3) **VFX 모듈(오른쪽)**, 다양한 편집 작업에 특화된 사전 정의 함수 집합. 이 모듈들은 물리 기반 시뮬레이션 및 렌더링 엔진(예: Blender)과 연동되어 최종 비디오를 생성합니다.

**1 소개(Introduction)**  
시각효과(VFX)는 실제 촬영된 영상(footage)에 컴퓨터 생성 이미지를 결합하여 새로운, 사실적인 비주얼을 만들어냅니다. 그래픽스, 비전, 물리 시뮬레이션의 최근 발전으로 인해 현실에서 직접 촬영하기엔 너무 비용이 많이 들거나, 시간이 오래 걸리거나, 위험하거나, 불가능한 장면까지도 사실적으로 구현할 수 있게 되었습니다. 그 결과 VFX는 현대 영화 제작, 광고, 시뮬레이션, AR/VR 등 다양한 분야에서 필수적인 요소로 자리 잡았습니다. 하지만 VFX 제작은 여전히 노동집약적이고 복잡하며, 전문가 수준의 기술과 전문 소프트웨어가 필요해([18, 44, 17, 3]) 일반 사용자에겐 거의 접근하기 어려운 상황입니다.

VFX를 대중화하기 위한 유망한 방법 중 하나는 이를 “생성형 비디오 편집 문제”로 간주하는 것입니다. 즉, 원본 비디오와 언어 프롬프트(지시문)를 이용해, 원본 영상의 내용과 주어진 지시가 반영된 새로운 영상을 생성하는 방식입니다 [4, 94, 69, 19, 32, 10, 92, 50, 64, 103, 65]. 이 방법은 대규모 인터넷 데이터로부터 학습한 생성 모델의 발전을 활용하여, 제어가 가능한 비디오를 만들어냅니다. 이미 딥페이크 영상, 패션, 자율주행, 로보틱스 등 다양한 분야에서 이와 같은 방식의 성공 사례가 보고되었습니다 [15, 31, 87, 52, 102]. 그러나 순수하게 데이터에만 의존하는 생성형 편집 접근은 물리적 개연성을 보장하고, 정밀한 3D 기반 제어를 수행하며, 특수 효과 전반을 다루어야 하는 전통적 VFX 파이프라인을 완전히 대체하기엔 여러 한계에 부딪힙니다.

이에 대한 또 다른 유망한 대안으로, 비디오에서 3D 표현(representation)을 추출한 뒤, 객체 삽입이나 텍스처 변경 같은 편집을 적용하고, 최종 결과를 렌더링하는 방법이 제안되었습니다 [53, 71, 36, 22, 63, 114, 113, 13, 25, 12, 100, 26, 56, 83, 57, 55]. 이 방법은 VFX 파이프라인과의 궁합이 좋지만, 편집 범위가 제한적일 뿐 아니라 여전히 까다로운 인터페이스를 수동으로 다뤄야 해 일반 사용자에겐 접근이 쉽지 않습니다. 이 간극을 해소하여, 누구나 사용 가능한 방식으로도 대부분의 시각효과를 다룰 수 있는 3D 장면 편집을 구현하는 것이 중요한 과제로 남아 있습니다.

본 논문에서는 단 하나의 비디오와 자연어 지시를 입력으로 받아, 사실적이고 역동적인 VFX 영상을 자동으로 생성하는 프레임워크인 **AutoVFX**를 제안합니다. 우리의 접근법 핵심은 신경(scene) 기반 모델링, LLM(대규모 언어 모델) 기반 코드 생성, 물리 시뮬레이션을 유기적으로 통합하는 데 있습니다. 먼저, 입력 비디오에서 얻은 풍부한 기하·외형·의미 정보를 포함하는 전체적 장면 모델을 구성합니다. 이 모델을 바탕으로 다양한 장면 편집, 시뮬레이션, 렌더링 기능을 실행 가능한 함수들로 정리해둡니다. 이후 AutoVFX는 단순한 자연어 편집 지시를 입력받아, 대규모 언어 모델로 하여금 이러한 사전 정의 함수들을 호출하는 프로그램을 자동으로 생성하게 합니다. 마지막으로 이렇게 생성된 코드를 실행해, 지시에 따라 변경된 자유 시점(free-viewpoint) 영상을 얻게 됩니다. 그림 2는 전반적인 프레임워크 구조를 보여줍니다.

AutoVFX는 생성형 편집과 물리 시뮬레이션의 장점을 결합하면서도, 두 접근법 모두와 차별화되는 고유한 특징을 갖습니다. 전통적인 VFX처럼, AutoVFX는 물리적으로 타당하고 제어 가능하며 사실적인 효과를 제공합니다. 동시에 생성형 편집 기법처럼, 오픈 월드 자연어 지시를 지원해, 원하는 효과를 단순히 서술하는 것만으로도 누구나 손쉽게 비디오를 편집할 수 있습니다.

우리는 다양한 비디오와 지시에 대해 폭넓은 실험을 수행해 AutoVFX의 효율성을 검증했습니다. 또한 기존의 비디오·장면 편집 기법과 비교 실험(정성적·정량적) 및 사용자 연구를 진행했습니다. 실험 결과, AutoVFX는 생성 품질, 지시 적합성, 편집 범용성, 물리적 개연성 측면에서 경쟁 기법을 크게 능가한다는 점이 확인되었습니다. 이는 본 접근법이 가진 높은 효율성과 편의성을 입증할 뿐만 아니라, 향후 더욱 사실적인 자동 VFX를 위해 다양한 기능을 확장·통합할 수 있는 가치 있는 프레임워크임을 시사합니다.

**표 1**: 기존 시각적 편집 기법들과 본 논문에서 제안하는 방법의 비교. 생성형 편집 모델은 물리적 개연성과 정밀 제어가 부족하며, 기존 물리 기반 편집 방법은 복잡한 인터페이스와 제한적인 편집 범위를 갖습니다. 이에 비해 AutoVFX는 간편한 자연어 기반 인터페이스와 가장 폭넓은 편집 기능을 제공합니다.

![](/assets/images/posts/496/img_2.png)

**2 관련 연구(Related Work)**  
우리의 프레임워크는 물리 시뮬레이션이 적용된 NeRF, 지시 기반 시각 편집(instruction-guided visual editing), 코드 생성을 위한 대규모 언어 모델(LLM) 등 서로 다른 여러 분야와 밀접한 관련이 있으며, 이 세 가지 측면을 모두 통합하고 있습니다. 이 섹션에서는 각각의 분야에 대해 살펴보고, 표 1에서 주목할 만한 연구들을 비교·대조합니다.

### 물리 시뮬레이션 기반 NeRF와 3D 가우시안(Physical Simulation on NeRFs and 3D Gaussians)

NeRF나 3D 가우시안 표현에 물리 시뮬레이션을 접목하면, 촬영된 장면 내에서 몰입감 있고 설득력 있는 동적 효과를 구현할 수 있습니다. 여러 연구는 강체(rigid body) 객체 상호작용 [96, 90], 홍수나 안개 같은 입자 물리 효과 [28, 53], 탄성 변형체 [111], 플라스틱 객체 [47, 98, 70] 등 다양한 물리적 상호작용을 탐구해 왔습니다. 핵심 아이디어는 물리 시뮬레이션을 통해 촬영된 장면이 새로운 사건이나 개체와 충실하게 상호작용할 수 있도록 하는 것입니다.

하지만 기존 신경 암시적 모델(neural implicit model)에 이러한 물리 시뮬레이션을 직접 적용하기는 쉽지 않은데, 전통적 시뮬레이션은 고정밀도의 표면 기하를 요구하는 반면, NeRF와 같은 모델은 이를 명시적으로 표현하지 않기 때문입니다. 따라서 NeRF에서 메쉬를 추출하여 [16, 99, 66, 108, 70, 47] 시뮬레이션을 가능케 하거나, 암시적(implicit) 혹은 입자 기반 시뮬레이션을 직접 암시적 모델이나 가우시안 형태로 적응시켜 [51, 27, 98, 28] 적용하려는 시도가 있어왔습니다. AutoVFX는 물리 상호작용 시엔 메쉬를 활용하고, 렌더링 시엔 이 메쉬 표면에 가우시안을 배치하는 **하이브리드 표현**을 채택함으로써 두 방식의 장점을 결합합니다.

또 다른 난제는 특정 물리 상호작용이 대상의 물리적 속성을 파악해야 한다는 점입니다. 이를 위해 역물리(inverse physics)를 활용하거나 [51, 111], 대규모 파운데이션 모델의 상식(common sense knowledge)을 활용하거나 [109, 59, 29], 생성 모델을 도입해 [111] 물리 속성을 추정하는 방법 등이 제안되었습니다. 그러나 대부분의 물리 시뮬레이션 연구는 자연어 지시가 아닌 도메인 특화 스크립트로 수행되기에, 특정 물리 효과로 용도가 제한되고 사용자 폭도 한정되는 경우가 많습니다. AutoVFX는 LLM을 활용해 언어 지시를 시뮬레이션 프로그램으로 변환하고, 범용 시뮬레이터와 연동하여 풍부한 동적 효과를 지원함으로써 이러한 간극을 해소하고자 합니다.

### 지시 기반 시각 편집(Instruction-based Visual Editing)

비주얼-언어 모델의 발전으로 인해, 이미지나 비디오, 3D 장면 등 매우 다양한 콘텐츠를 편집할 때 그래픽 사용자 인터페이스(GUI)나 스크립트 대신 언어 지시만으로도 편집할 수 있게 되었습니다 [36, 8, 103, 50, 29]. 특히 텍스트·이미지 조건부 생성 모델, 그중에서도 확산 모델(diffusion-based approaches)이 텍스트 기반 이미지 편집 [6, 79, 62, 110, 8]과 비디오 편집 [103, 4, 94, 69, 19, 32, 10, 92, 50, 64, 65]에 광범위하게 적용되고 있습니다. 언어 임베딩을 활용한 NeRF 기법은 이러한 생성 편집 기능을 3D 장면으로 확장합니다 [36, 25, 13, 12, 63, 22, 113, 114, 100, 85].

하지만 단순히 확산 모델만으로 텍스트 지시를 그대로 원하는 비디오·장면 편집에 매핑하기란 쉽지 않습니다. 작업이 복잡한 단계나 동적 상호작용, 물리 효과를 포함하면 지시 정합성, 물리적 개연성, 사실성이 저해될 수 있기 때문입니다. 이를 보완하기 위해, 대규모 언어 모델(LLM)을 활용해 작업을 하위 작업으로 분해하거나 [90, 26, 25], 지시에 기반해 실행 가능한 프로그램을 생성하는 [35, 60] 방법들이 제안되었습니다. AutoVFX 역시 후자의 접근에 속하지만, 동적 시각효과나 애니메이션 객체, 물리 상호작용 등을 훨씬 풍부하게 지원한다는 점에서 차별화됩니다.

### 코드 생성을 위한 LLM(LLMs for Code Generation)

자연어로부터 코드를 생성하는 대규모 언어 모델(LLM)의 강력한 능력은 소프트웨어 개발 전반에서 혁신을 일으키고 있습니다. LLM은 맥락(in-context) 예시만 주어도 특정 문법이나 형식의 코드 조각을 생성할 수 있습니다. [23, 11, 2]와 같은 연구들은 LLM이 수학 문제나 코드 문제를 해결하는 데 얼마나 효율적인지를 탐구했습니다.

비전 및 로보틱스 분야에서도 LLM 기반 코드 생성은 활발히 연구되고 있습니다. 여러 연구가 임베디드 AI에서 의사결정에 LLM을 활용하고 있는데, 주로 조작(manipulation) [84, 42, 54, 101], 내비게이션 [61] 등의 작업이 해당됩니다. 최근에는 2D 이해 및 편집 [35], 주행 시뮬레이션 [26], 비디오 생성 [60], 절차적 3D 장면 생성 [41, 75, 76, 112, 30] 등 시각적 콘텐츠 생성에 LLM 기반 프로그램을 활용하려는 시도가 이루어지고 있습니다. 우리 방법에서는 GPT-4를 사용하여, 사용자의 자연어 설명을 다양한 시각 효과를 위한 실행 가능한 프로그램으로 해석함으로써 실제 세계 비디오에서 폭넓은 효과를 구현할 수 있도록 했습니다.

![](/assets/images/posts/496/img_3.png)

**그림 3**: **프로그램 생성(Program generation)**. LLM은 인컨텍스트 학습(in-context learning)을 통해 편집 프로그램을 생성합니다. 사전에 제공된 문맥과 예시를 바탕으로 VFX 모듈 호출 방식을 학습하고, 새롭게 주어진 사용자 지시(파란색 블록)를 토대로 프로그램(주황색 블록)을 생성합니다.

**3 텍스트 기반 VFX 제작(Text-Driven VFX Creator)**  
AutoVFX는 비디오와 자연어 편집 프롬프트를 입력받아, 편집된 자유 시점(free-viewpoint) 영상을 출력합니다. 핵심 아이디어는 LLM의 코드 생성 기능과 3D 장면 모델링, 물리 기반 시뮬레이션 기법을 독창적으로 결합하는 것입니다. 그림 2에 전체적인 프레임워크를 요약해두었습니다. 먼저, 다양한 3D 비전 기법을 활용해 입력 비디오로부터 장면의 핵심 속성을 추정합니다(섹션 3.1). 이렇게 얻은 정보를 기반으로 편집, 시뮬레이션, 렌더링 작업을 수행하는 여러 모듈을 작성(섹션 3.2, 3.3)한 뒤, LLM을 통해 자연어 편집 지시를 이 모듈들을 호출하는 프로그램으로 변환합니다(섹션 3.4). 마지막으로 해당 프로그램을 실행하면, 지시에 맞춰 편집된 자유 시점 영상을 얻을 수 있습니다.

### 3.1 3D 장면 모델링(3D Scene Modeling)

사실적이고 물리 기반의 VFX를 생성하려면 입력 장면에 대한 여러 핵심 속성—기하, 외형, 의미(semantics), 조명—을 정밀하게 모델링해야 합니다. 우리는 다양한 최신 장면 이해 모델을 이용해 이를 추정하는데, 시뮬레이션의 정확도와 사실적 렌더링을 모두 확보하기 위해 기하 정보와 외형 정보를 별도 모델로 관리합니다.

#### 기하(Geometry)

객체 삽입, 제거, 혹은 시뮬레이션 등 어떤 편집 작업이든 장면의 3D 기하를 정확히 파악하는 것이 필수입니다. 먼저, COLMAP [81]을 활용해 각 프레임의 카메라 포즈를 추정합니다. 이후 BakedSDF [104]라는 멀티뷰 재구성 기법을 사용해 서명 거리장(signed distance field)을 학습하는 하이브리드 암시적 표현을 최적화하고, 이를 삼각형 메쉬 형태로 “베이킹(baking)”하여 최종 기하를 얻습니다. 이 방식은 표면의 정밀도와 완전성, 그리고 계산 효율 사이에서 좋은 균형을 보여줍니다. 우리는 메쉬 표현을 선택했는데, 이는 표준 VFX 파이프라인과 바로 연동해 효율적으로 렌더링할 수 있고, 물리 시뮬레이션에도 적합하며, 객체 인스턴스 추출의 기하 프록시 역할도 수행하기 때문입니다.

#### 외형(Appearance)

장면의 외형은 두 가지 방법으로 캡처합니다. 먼저, Gaussian Splatting [48] 기반의 최신 시점 합성 기법인 SuGaR [33]를 사용해 자유 시점 렌더링을 구현합니다. SuGaR는 사실적인 렌더링을 제공하지만, 물리 기반 렌더링(PBR)에 직접적으로 활용하기엔 제한이 있어, 삽입된 객체의 반사 효과나 머티리얼 편집에는 적합하지 않습니다. 따라서 우리는 BakedSDF 메쉬에 텍스처를 입혀 장면을 추가로 표현합니다. 이렇게 얻은 텍스처 메쉬는 사실감은 다소 떨어지지만 물리 기반 렌더링과 결합할 수 있어 그림자 매핑이나 멀티 바운스(multi-bounce) 효과 등에서 활용 가능합니다.

#### 의미(Semantics)

사용자는 종종 장면 내 특정 의미 영역에 대해서만 편집을 원합니다. 예를 들어 “차에 불을 붙이기” 같은 작업을 하려면, 해당 객체를 정확히 식별해 분리해야 합니다. 이를 위해 우리는 Grounding SAM [58]을 이용해 오픈 보캐블러리(Open-Vocabulary) 인스턴스 분할을 수행하고, DEVA [14]로 프레임 간 인스턴스를 추적합니다. 이렇게 얻은 2D 마스크를 3D로 확장하기 위해, 분할 마스크의 픽셀을 장면 기하(3D 메쉬)에 역투영(un-project)하고, 여러 시점에서 동일 메쉬에 대한 가시성을 투표(voting) 방식으로 판단합니다. 일정 임계값 이상 가시성이 확보된 메쉬 면(face)을 선택한 뒤, 이들과 가장 가까운 3D 가우시안들을 찾고 이를 렌더링해 알파 이미지를 생성합니다. 마지막으로 원본 분할 마스크와 알파 이미지의 평균 교차영역(mIoU)을 계산하여, 가장 mIoU가 높은 메쉬 면과 3D 가우시안을 선택합니다. 이를 통해 **정확한 3D 분할**을 얻습니다.

#### 조명(Lighting)

정확한 조명 추정은 장면 내 모든 요소가 자연스럽게 조명되도록 하는 핵심 요소입니다. 우리는 환경 조명 추정을 두 가지 방법으로 수행합니다. 완전히 스캔된 실내 장면(예: ScanNet++ [106])인 경우, 과노출된 픽셀을 역투영한 뒤 최빈값(majority voting)을 사용해 광원 역할을 하는 메쉬를 추론합니다. 이렇게 구한 메쉬들은 광원으로 설정하여 렌더러에 불러옵니다. 반면, 부분적으로만 포착된 실내 장면이나 야외 장면(예: MipNeRF360 [5])에서는 DiffusionLight [67]를 사용해 초기 프레임 중앙에 크롬 볼(chrome ball)을 다양한 노출 수준으로 인페인트(inpaint)합니다. 이렇게 얻은 이미지들을 기반으로 HDR(High Dynamic Range) 맵을 생성해, 이를 환경광(environmental light)으로 렌더러에 불러옵니다.

![](/assets/images/posts/496/img_4.png)

**그림 4**: **AutoVFX를 활용한 동적 VFX 비디오 편집**. 제안 기법은 물리 상호작용, 관절(articulated) 애니메이션, 입자 효과, 생성된 3D 자산 삽입, 머티리얼 편집, 기하 파손(fracturing) 등을 지원합니다.

**3.2 장면 편집과 시뮬레이션(Scene Editing and Simulation)**  
앞서 소개한 다중모달 3D 장면 모델링을 토대로, 폭넓은 편집·시뮬레이션·렌더링 작업을 수행할 수 있습니다. 우리는 이러한 풍부한 VFX 기능을 **매끄럽게** 제공하기 위해 직관적인 모듈 세트를 설계했으며, 모듈 간 조합을 통해 다양한 효과를 구현할 수 있습니다. 또한 모듈형 구조를 채택함으로써, 새로운 모듈을 등록하여 **손쉽게** 기능을 확장할 수 있습니다. 이하에서는 각 모듈에서 사용되는 구체적인 기법을 소개합니다.

### 3D 에셋 생성(3D Asset Creation)

다양한 객체 삽입을 지원하기 위해, 우리는 Objaverse 1.0 [21] 데이터셋과 Richdreamer [72]에서 선별한 28만 개 규모의 고품질 3D 에셋을 활용합니다. 3D 에셋 생성은 **이중 접근(twofold approach)**을 취하는데, 먼저 Sentence-BERT [77]를 사용해 쿼리 텍스트와 유사도가 높은 3D 에셋 상위 K개를 추립니다. 이후, 여러 시점에서 렌더링한 이미지를 CLIP [74]로 평가하여 가장 잘 맞는 에셋을 최종 선택합니다. 기존 설명에 없는 텍스트 쿼리가 들어오는 경우에는 Meshy AI를 사용하여 PBR 머티리얼을 갖춘 고품질 3D 에셋을 직접 생성함으로써, 삽입 가능한 객체의 범위를 확장합니다.

### 삽입(Insertion)

사실적인 객체 삽입을 위해서는 객체의 **위치**와 **스케일**을 정확히 결정해야 합니다. 먼저, 객체가 안정적으로 놓일 수 있도록 충분히 평평한 삼각형 면(메쉬의 일부)을 표본 추출하여 배치 위치를 잡습니다. 스케일을 추정할 때에는 GPT-4V [1] 모델을 사용해 3D 에셋의 실제 물리적 크기를 추론하고, 이에 대한 자세한 프롬프트 예시는 보충 자료에 첨부했습니다.

### 제거(Removal)

장면에서 특정 인스턴스를 제거하기 위해서는 먼저 의미 정보(semantic module)를 통해 해당 객체를 인식해야 합니다. 이후 해당 객체가 차지하는 가우시안 점과 관련 메쉬 면을 제거합니다. 노출된 하단 영역의 기하 구조는 평면 메쉬로 간단히 복원하고, 외형(appearance) 복원을 위해서는 LaMa [88]를 활용해 모든 비디오 프레임에서 누락된 영역을 인페인트(inpaint)합니다. 마지막으로 현재 3D Gaussian Splatting 모델을 인페인트된 프레임에 맞춰 파인튜닝하여, 3D적으로 일관성 있는 복원을 달성합니다.

### 머티리얼 편집(Material Editing)

정확한 머티리얼 편집은 조명·음영·환경 조건에 대한 올바른 반응을 유도하여, 실제 촬영된 장면과 자연스럽게 융합되도록 합니다. 우리는 렌더러의 3D 에셋 머티리얼 노드를 직접 수정하는 여러 가지 방식을 지원합니다. 예컨대, metallic, specular, roughness 같은 파라미터를 조정하거나, 텍스처 이미지의 색상 강도를 바꿔 에셋 전반의 색감을 변경할 수 있습니다. 또한 머티리얼 이름으로 질의하는 방식을 지원해, PolyHaven에서 추출한 머티리얼 데이터베이스를 검색한 뒤 해당 머티리얼을 가져와 관련 노드에 적용할 수도 있습니다.

### 물리 시뮬레이션(Physical Simulation)

우리의 장면 모델은 Blender와 직접 호환되므로, Blender 시뮬레이션 라이브러리 함수를 호출해 강력한 물리 시뮬레이션 기능을 활용할 수 있습니다. 대표적으로 강체(rigid-body) 물리와 입자 효과 시뮬레이션을 활성화하는 데에 이 함수를 사용합니다. Blender의 강체 물리는 Bullet 물리 엔진 [20]을 기반으로 하며, 정확하고 현실적인 객체 상호작용을 위해 상호작용할 객체의 질량중심(center of mass)과 볼록 껍질(convex hull)을 미리 계산합니다. 입자 효과(연기·불 등)는 mantaflow [89]를 사용하며, 설득력 있는 효과를 위해 일부 기본 시뮬레이션 설정값을 조정합니다. 추가 상세 정보는 보충 자료에 수록했습니다.

**3.3 장면 렌더링과 비디오 합성(Scene Rendering and Video Compositing)**  
우리는 사실적인 비디오 결과물을 얻기 위해 신중하게 구성된 렌더링 및 합성 과정을 거칩니다. 먼저, 삽입된 객체를 렌더링할 때 배경 메쉬는 광선 추적(raytracing)에서 **최초 반사(first-bounce)**에서는 보이지 않게 설정하고, **고차 반사(higher-order bounces)**에서는 보이도록 처리합니다. 이렇게 하면 삽입된 객체가 배경으로부터 조명의 영향을 적절히 받게 됩니다. 이후 배경 메쉬를 보이도록 설정한 채로, **객체가 삽입된 경우**와 **삽입되지 않은 경우** 두 번 렌더링을 수행합니다. 이 두 렌더링의 픽셀 값 비율을 통해, 삽입된 객체가 배경 표면에 미치는 조명 효과를 근사적으로 구합니다. 이 비율을 **SuGaR 렌더링** 혹은 **원본 비디오 프레임**에 곱하여, 사용자가 원하는 시점 변환(소설적 시점) 여부에 따라 적용합니다. 마지막으로, 깊이 정보를 활용해 삽입된 객체가 배경에 의해 가려지는 부분을 정확히 처리한 뒤 알파 블렌딩(alpha-blending) 방식으로 비디오 위에 합성합니다. 삽입 객체가 불처럼 발광·투명 요소를 포함한다면 ‘사전곱 알파 블렌딩(premultiplied alpha-blending)’을, 그렇지 않은 경우에는 ‘직접 알파 블렌딩(straight alpha-blending)’을 사용합니다.

**3.4 LLM 통합(LLM Integration)**  
AutoVFX는 사용자들이 자연어 지시만으로 VFX를 제작할 수 있도록 하여, 누구나 쉽게 접근할 수 있는 인터페이스를 제공하는 것을 목표로 합니다. 이를 위해, 최근 제안된 Code-as-Policies [54]나 Visual Programming [35]와 유사한 LLM 에이전트 프레임워크 내부에 우리의 편집 모듈들을 API 형태로 통합했습니다. 구체적으로 GPT-4 [1]를 활용해, 사전에 정의된 편집 함수로 구성된 프로그램 예시와 편집 지시를 짝지어 모델에 제시(in-context learning)합니다. 그러면 LLM은 이에 따라 프로그램을 생성하고, 최종적으로 이 프로그램을 실행하여 원하는 장면 편집을 수행합니다.

### 모듈형 함수 캡슐화(Modular Function Encapsulation)

우리 방식은 사전에 정의된 편집 모듈을 호출 가능한 함수로 캡슐화해 두어, 여러 함수를 조합해 하나의 완결된 프로그램을 구성할 수 있게 합니다. 장면 내 객체는 Python 딕셔너리 형태로 표현되어 있어, 직관적이고 해석 가능한 편집이 가능합니다. 각 함수의 파라미터는 전부 명시되어 있어, 사용자의 프로그래밍 숙련도에 따라 자유롭게 수정할 수 있습니다. 사전 정의된 모든 모듈 목록은 보충 자료에 수록했습니다.

### LLM 기반 프로그램 구성 및 실행(LLM-driven Program Composition and Execution)

GPT-4가 이러한 함수들을 효과적으로 조합해 실행 가능한 프로그램을 생성하도록, 우리는 모델을 안내하는 프롬프트를 설계했습니다. 이 프롬프트에는 **원하는 장면 편집을 Python 형태의 스크립트로 표현**하는 예시들이 포함됩니다. 모델이 해당 프로그램을 생성하고 나면, 실제 Python 인터프리터에서 이 프로그램을 실행하여 시뮬레이션이나 렌더링을 수행하고 최종적인 시각 효과를 얻습니다. 그림 3에서 보이듯, 이 접근법은 복잡한 시각효과 제작 과정을 단순화해, 자연어 지시만으로도 폭넓은 사용자가 VFX 제작을 할 수 있게 만듭니다. 또한 모듈형 설계로 인해, 사용자는 필요에 따라 기능을 손쉽게 확장하거나 맞춤화할 수 있습니다.

**표 2**: 기존 기법과의 정량적 비교. 자동 지표와 사용자 평가 모두에서, AutoVFX는 다양한 항목에 걸쳐 일관적으로 기존 방법보다 우수한 성능을 보입니다.

![](/assets/images/posts/496/img_5.png)

**4 실험(Experiments)**  
우리는 다양한 장면과 편집 지시문(prompt)을 대상으로 AutoVFX를 평가하고, 여러 관련 기법들과 정성적·정량적 비교를 수행합니다.

### 4.1 실험 세부 사항(Experimental Details)

**데이터셋 & 전처리(Dataset & Preprocessing)**  
다양한 상황에서 편집 기능을 시연하기 위해, Mip-NeRF360 [5], Tanks & Temples [49], ScanNet++ [106], Waymo [86] 등 실제 장면 기반 데이터셋을 사용했습니다. 이미지를 통해 GSplat 초기화를 하기 위해서는 COLMAP [80]을 이용해 카메라 포즈와 희소 점군(sparse point cloud)을 추출합니다.

**비교 대상(Baselines)**  
우리는 텍스트 기반 시각 편집 기법인 Instruct-N2N [36], DGE [12], FRESCO [103]와 AutoVFX를 비교했습니다. Instruct-N2N과 DGE는 텍스트 지시에 따라 각각 NeRF와 3D 가우시안 표현 위에서 장면을 편집하며, FRESCO는 입력 비디오를 목표 텍스트 프롬프트와 정렬되도록 변환합니다. 본 실험에서 DGE의 guidance scale은 편집 효과를 두드러지게 하기 위해 12.5로 설정했습니다. 이 외에는 모든 기법에 대해 기본 설정을 유지하여 공정한 비교를 보장했습니다. Instruct-N2N과 DGE의 결과 영상은 편집된 3D 표현을 렌더링하여 얻었습니다.

**구현 세부 사항(Implementation Details)**  
강체(rigid-body) 물리 효과를 받은 객체를 렌더링할 때, 각 타임스텝마다 추적되는 강체 변환(rigid transformation)을 3D 가우시안에 적용합니다. 키포인트를 기반으로 객체를 애니메이션할 때는 베지에(Bézier) 보간을 사용해 부드러운 이동 궤적을 생성합니다. 그 외 다양한 VFX 모듈에 대한 구체적인 구현 내용은 보충 자료에 상세히 기술했습니다.

**4.2 정성적 평가(Qualitative evaluation)**

#### 정성 비교(Qualitative comparison)

![](https://blog.kakaocdn.net/dn/ITm6H/btsLSOmDzXI/wmW1jy4mpA7yK6mgD2G0lK/img.png)

**그림 5**는 서로 다른 기법들을 사용해 정적인(scene이 움직이지 않는) 장면을 편집했을 때의 시각적 품질을 비교한 결과입니다.

우리의 접근법은 객체 삽입·조작에서 사실적이고 정확한 편집을 보여주며, 장면 구조를 잘 유지한다는 점에서 비교 기법들을 능가합니다. 반면에 Instruct-N2N은 국소적인 영역을 편집하는 데에 어려움을 겪고, FRESCO는 구조적 일관성을 유지하지 못하며, DGE는 사실적인 영상을 생성할 수 있으나 지시사항(instruction)을 충실히 반영하지 못합니다.

게다가 AutoVFX는 “거울처럼 만들기(make it mirror-like)”와 같은 정밀한 머티리얼 편집, “농구공 5개 떨어뜨리기(drop five basketballs)” 같은 정확한 객체 개수 처리, “불 붙이기(make it on fire)”처럼 고급 시각 효과를 지원하여 더욱 풍부한 기능을 제공합니다.

#### 동적 비디오 시뮬레이션(Dynamic video simulation)

**그림 4**에는 동적 VFX 비디오에 대한 추가 결과물이 제시되어 있습니다. 여기서는 텍스트 지시에 따라 강체(rigid body) 시뮬레이션, 객체 애니메이션, 연기·불 효과, 객체 파손(object fracturing) 같은 모듈을 활용해, 사실적이고 물리적으로 타당한 동적 시뮬레이션을 폭넓게 생성할 수 있음을 확인할 수 있습니다. 기존 생성형 편집 기법들은 이러한 기능을 제공하지 못합니다.

또한 **그림 6**에 보이듯 Waymo 데이터셋 [86]을 활용한 자율주행 시뮬레이션 실험도 진행했습니다. 이때 AutoVFX는 충돌 상황에서 자동차 간 물리적인 상호작용과 사실적인 렌더링을 모두 재현할 수 있습니다.

![](/assets/images/posts/496/img_6.png)

**그림 6**: 주행 장면에서의 AutoVFX 동적 시뮬레이션.

**4.3 정량적 평가(Quantitative evaluation)**  
본 섹션에서는 제안 기법의 정량적 평가 결과를 제시합니다. 평가는 크게 세 가지 범주—“의미적 일관성 척도(Semantic Consistency Measures)”, “멀티모달 LLM 품질 평가(Multimodal LLM Quality Evaluation)”, “사용자 연구(User Study)”—에 걸친 9개 지표를 기반으로 진행했으며, 결과는 표 2에 요약되어 있습니다.

### 의미적 일관성 척도(Semantic Consistency Measures)

우리는 VBench [43]의 “다중 객체(Multiple Objects)” 지표를 차용해, 편집 후 객체가 올바르게 존재하는지를 검증합니다. 이는 객체 탐지 모듈을 활용하여, 다중 객체가 편집 결과에 제대로 반영됐는지를 측정하는 방식입니다. GRiT [93] 대신 Grounded-SAM [78]을 사용해 모든 프레임, 모든 편집 케이스에 대해 시각 콘텐츠 편집의 성공률을 평가했습니다.

또한, DGE [12]에서 제안된 “CLIP Similarity”와 “CLIP Directional Similarity” 지표를 채택했습니다. “CLIP Similarity”는 편집된 각 프레임이 텍스트 지시와 얼마나 정렬되는지를 측정하고, “CLIP Directional Similarity”는 프레임 전반의 시간적 일관성을 평가합니다. 두 지표 모두 CLIP 공간에서 작동합니다. 표 2에 따르면, 우리 방법은 객체 탐지 점수와 CLIP 방향 유사도 지표에서 경쟁 기법들을 크게 상회하며, CLIP 유사도 또한 유사한 수준으로 유지합니다. 특히 객체 탐지 점수를 대폭 향상시키면서, 편집 결과가 객체 단위로 명확하게 반영되었음을 시사합니다. CLIP 유사도의 경우 모든 기법 간 차이가 크지 않은데, 이는 전역 CLIP 모델이 작은 객체 삽입이나 동적 변화 같은 **국소적 변화** 감지에는 민감하지 않기 때문일 수 있습니다. 전반적으로, 제안 기법이 텍스트 지시와의 정합성을 효과적으로 만족함을 알 수 있습니다.

### 멀티모달 LLM 품질 평가(Multimodal LLM Quality Evaluation)

[95]의 아이디어를 참고하여, 멀티모달 LLM을 이미지 품질 평가를 위한 강력하고 해석 가능한 텍스트 기반 모델로 사용했습니다. 구체적으로, GPT-4o를 활용해, 네 가지 서로 다른 기법에 대해 “텍스트 정렬(Text Alignment)”, “사실감(Photorealism)”, “구조 보존(Structural Preservation)” 세 기준을 평가한 뒤, 종합적 “퍼셉션 품질(Overall Perceptual Quality)”을 비교하도록 했습니다. 또한 각 기법에 대해 기준별 품질 점수를 0~1 범위에서 부여하도록 지시했으며(프롬프트 예시는 보충 자료 참고), 1이 최고 점수입니다.

표 2에서 알 수 있듯, AutoVFX는 네 가지 모든 지표에서 큰 폭으로 타 기법을 상회합니다. 특히 사실감과 구조 보존 측면에서 우수할 뿐 아니라, “텍스트 정렬” 지표에서도 가장 눈에 띄는 차이로 앞서 있습니다. 이는 우리 방법이 **고품질 시각 편집**을 제공할 뿐 아니라, 사용자가 의도한 텍스트 지시를 완전히 반영한다는 점을 보여주어, VFX 응용 분야 전반에 유용할 것으로 기대됩니다.

### 사용자 연구(User Study)

우리는 “텍스트 정렬(Text Alignment)”과 “전반적 사실감(Overall Realism)” 두 측면에서 편집된 결과 영상을 평가하기 위한 사용자 연구를 진행했습니다. 편집 자체를 거의 하지 않아도 사실적으로 느껴지는 경우가 생길 수 있는 **잠재적 편향**을 완화하기 위해, 설문을 다음과 같이 구성했습니다.

1. 먼저, 사용자들에게 특정 텍스트 지시에 얼마나 부합하는지(“Text Alignment”)에 따라 편집된 영상을 평가하도록 요청합니다. 이때는 여러 편집 결과를 동시에 선택할 수도 있습니다.
2. 그 후, 사용자가 1단계에서 고른 후보들 중에서 가장 사실적으로 느껴지는(“Overall Realism”) 하나를 최종 선택하게 합니다.

설문은 총 36명의 사용자 응답을 수집했으며, 자세한 사용자 연구 기법은 보충 자료를 참고하시기 바랍니다. 표 2에서 보이듯, AutoVFX는 “텍스트 정렬”과 “전반적 사실감” 모두에서 사용자 선호도가 가장 높았습니다. 이는 우리 편집 결과가 지시사항을 정확하게 반영함은 물론, **사람이 보기에 더 매력적**이라는 것을 의미합니다.

## 5 결론(Conclusion)

본 논문에서는 단일 모노큘러 비디오와 자연어 지시를 입력으로 받아, 물리적으로 타당한 VFX를 자동으로 생성하는 AutoVFX를 제안했습니다. AutoVFX는 신경 기반 장면 모델링, LLM 기반 코드 생성, 물리 시뮬레이션을 결합해 사실적이면서도 손쉽게 제어 가능한 VFX 제작이 가능합니다. 실험 결과, 다양한 실제 사용 조건에서 경쟁 장면 편집 기법들을 뛰어넘는 성능을 보였으며, 이는 텍스트 지시에 충실하면서도 높은 품질의 결과물을 생성할 수 있음을 보여줍니다. AutoVFX는 전문가와 일반 사용자 모두에게 시각 콘텐츠 제작의 속도와 보급화를 앞당길 수 있는 유용한 수단이 될 것으로 기대하며, 향후에는 더욱 사실적인 자동 VFX를 위해 기능 확장 및 통합을 지속할 수 있을 것입니다.

## 감사의 말(Acknowledgement)

이 프로젝트는 Intel AI SRS gift, Meta 연구 지원, IBM IIDAI Grant 및 NSF Awards #2331878, #2340254, #2312102, #2414227, #2404385의 지원을 받았습니다. Hao-Yu Hsu는 Siebel Scholarship의 지원을 받고 있습니다. NCSA의 컴퓨팅 자원 제공에 감사드립니다. 유익한 논의를 함께 해주신 Derek Hoiem, Sarita Adve, Benjamin Ummenhofer, Kai Yuan, Micheal Paulitsch, Katelyn Gao, Quentin Leboutet 님께도 깊이 감사드립니다.
