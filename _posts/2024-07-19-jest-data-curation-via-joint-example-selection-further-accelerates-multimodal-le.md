---
title: "JEST : Data curation via joint example selection further accelerates multimodal learning"
date: 2024-07-19 21:40:29
categories:
  - 인공지능
---

<https://arxiv.org/abs/2406.17711>

[Data curation via joint example selection further accelerates multimodal learning](https://arxiv.org/abs/2406.17711)

초록

데이터 큐레이션은 대규모 사전 학습의 필수 구성 요소입니다. 이 연구에서는 데이터를 독립적으로 선택하는 것보다 배치를 공동으로 선택하는 것이 학습에 더 효과적임을 입증합니다. 다중모달 대조 목표는 데이터 간의 종속성을 노출시켜 배치의 공동 학습 가능성을 측정하는 기준을 자연스럽게 제공합니다. 우리는 이러한 배치를 선택하기 위한 간단하고 실행 가능한 알고리즘을 도출하여 개별적으로 우선순위가 매겨진 데이터 포인트보다 훈련을 크게 가속화합니다. 더 큰 슈퍼배치에서 선택할 때 성능이 향상되므로, 관련된 계산 오버헤드를 줄이기 위해 모델 근사화의 최근 발전을 활용합니다. 그 결과, 우리의 접근법인 공동 예제 선택을 통한 다중모달 대조 학습(JEST)은 최대 13배 적은 반복과 10배 적은 계산으로 최첨단 모델을 능가합니다. JEST의 성능에 필수적인 것은 사전 훈련된 참조 모델을 통해 데이터 선택 과정을 더 작고 잘 큐레이션된 데이터셋의 분포로 조정하는 능력으로, 이는 데이터 큐레이션 수준을 신경망 스케일링 법칙의 새로운 차원으로 노출시킵니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

데이터 큐레이션(data curation)은 데이터를 수집, 관리, 보관, 가공하여 사용자가 필요로 하는 형태로 제공하는 과정을 말합니다. 이는 단순히 데이터를 모으는 것 이상의 작업으로, 데이터의 품질을 보장하고, 분석 및 학습에 적합한 형태로 정제하는 것을 포함합니다. 데이터 큐레이션의 주요 활동에는 다음이 포함됩니다:

1. **데이터 수집**: 다양한 소스에서 데이터를 수집하는 단계입니다. 이 과정에서는 데이터의 출처를 검토하고, 필요한 데이터만 선별합니다.
2. **데이터 정제**: 수집된 데이터는 종종 불완전하거나 오류가 포함되어 있습니다. 데이터 정제 과정에서는 이러한 오류를 수정하고, 중복 데이터를 제거하며, 일관성을 유지하도록 데이터를 표준화합니다.
3. **데이터 관리**: 정제된 데이터를 체계적으로 저장하고, 필요한 메타데이터를 추가하여 데이터의 검색성과 재사용성을 높입니다.
4. **데이터 가공**: 분석 및 학습에 적합하도록 데이터를 변환하고, 필요한 경우 특징을 추출하거나 데이터셋을 생성합니다.
5. **데이터 배포 및 공유**: 최종적으로 가공된 데이터를 사용자가 쉽게 접근하고 활용할 수 있도록 배포합니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

### 1. 서론

데이터 품질은 대규모 사전 학습의 성능을 결정짓는 중요한 요소입니다. 언어[19], 비전[15], 또는 다중모달 모델링[1, 22, 32] 등에서 잘 큐레이션된 데이터셋을 사용한 훈련은 적은 데이터로도 높은 성능을 달성할 수 있음을 일관되게 입증해왔습니다. 그러나 현재의 데이터 파이프라인은 수작업 큐레이션에 크게 의존하고 있으며, 이는 확장하기 어렵고 비용이 많이 듭니다. 이에 반해, 학습 중인 모델의 특징을 사용해 고품질 데이터를 선택하는 모델 기반 데이터 큐레이션[31, 33]은 이론[47]과 실제[15] 모두에서 다중 모달리티의 대규모 사전 학습의 느린 파워 법칙적 확장을 개선할 가능성을 지니고 있습니다.

기존 방법들은 개별 데이터 포인트 수준에서 큐레이션을 적용합니다[12, 42]. 그러나 배치의 품질은 독립적으로 고려된 데이터 포인트의 합산된 품질 외에도 배치의 구성에 의해 결정됩니다. 컴퓨터 비전에서, 서로 가까이 있지만 다른 라벨을 가진 포인트 클러스터(즉, 어려운 네거티브)는 쉽게 해결 가능한 것보다 더 효과적인 학습 신호를 제공합니다[5, 21, 34, 41, 45, 50, 53]. 본 연구에서는 데이터 배치에 적용되는 모델 기반 데이터 선택 기준이 개별 예제를 독립적으로 선택하는 것보다 학습을 가속화할 수 있는지에 대해 일반화된 개념을 탐구합니다.

다중 모달 학습에서 대조 목표는 배치 내 예제 간의 상호작용을 직접적으로 노출합니다. 따라서 우리는 모델 기반 점수를 고려한 큰 '슈퍼배치'에서 관련된 '서브배치'를 효율적으로 선택하는 간단하고 실행 가능한 알고리즘인 JEST(Joint Example Selection)를 도출합니다. 사전 학습된 참조 모델(즉, 간편 참조)로 배치를 점수화할 때, JEST는 균일한 배치 선택에 비해 학습을 가속화하며, 동일한 참조를 사용하는 독립적 예제 선택(CLIPScore[22])보다도 성능을 크게 개선합니다. 온라인 모델 손실을 고려한 배치의 학습 가능성에 따라 배치를 점수화할 때, JEST는 추가로 성능을 향상시켜, 최대 13배 적은 훈련 반복으로 최첨단 모델[54]의 성능을 맞춥니다.

높은 학습 가능성을 가진 배치를 발견하려면 훨씬 큰 슈퍼배치의 원시 데이터를 선별해야 합니다. 우리는 온라인 모델 근사화의 최근 발전을 활용하여 대규모 배치의 학습 가능성 점수를 실행 가능하게 만들며, 이는 계산을 줄이면서도 유용한 예측을 제공합니다[4, 29, 55]. 단일 모델을 여러 해상도로 병렬 훈련하여, 우리는 큰 슈퍼배치를 점수화하고 가장 학습 가능한 서브배치를 찾아내어 더 가치 있는 계산을 학습에 할당합니다. 학습과 예제 점수화 모두에서 절감 덕분에, 우리는 추가 연산량을 133%에서 10%로 줄이면서도 훈련 효율성을 크게 향상시킵니다. 이 근사 점수화 프레임워크인 Flexi-JEST는 11배 적은 반복과 10배 적은 연산으로 최첨단 모델을 생성합니다.

마지막으로, 우리의 프레임워크 성능의 중심에는 큐레이션 과정을 더 작고 잘 큐레이션된 데이터셋의 분포로 유도하는 능력이 있습니다. 이는 모델 기반 선택 기준을 통해 자연스럽게 발생하며, 사전 학습된 참조 모델 개념을 통해 우선순위를 두어 훈련된 데이터와 가장 유사한 예제를 우선시합니다. 중요한 것은, 이 과정이 강력한 데이터 품질 부트스트래핑을 가능하게 한다는 점입니다. 잘 큐레이션된 소형 데이터셋에서 훈련된 참조 모델은 훨씬 큰 데이터셋의 큐레이션을 효과적으로 안내할 수 있으며, 이는 참조 모델의 품질을 크게 뛰어넘는 모델을 많은 후속 작업에서 훈련할 수 있게 합니다.

![](/assets/images/posts/212/img.png)

#### 그림 1: 공동 예제 선택은 다중 모달 사전 학습을 가속화합니다.

우리의 JEST/JEST++ 방법은 소형, 강력하게 큐레이션된 데이터셋(Webli-curated/Webli-curated++)에서 부트스트랩하여 웹 스케일 데이터셋을 적극적으로 큐레이션합니다. Flexi-JEST++는 큐레이션 비용을 줄이기 위해 가변 패치 크기를 사용합니다. 왼쪽: JEST로 훈련하면 균일한 40B SigLIP 기준 성능과 최대 13배 적은 반복으로 성능이 일치합니다. 중간: 점수화 비용을 고려해도 우리의 최고 변형은 연산 효율성이 거의 10배 높습니다. 오른쪽: JEST++/FlexiJEST++(녹색)과 이전 방법(회색)의 비교. 평균 정확도는 8개의 후속 작업(왼쪽, 중간; 표 5 참조) 또는 ImageNet과 COCO(오른쪽)를 기준으로 계산됩니다.

### 2. 관련 연구

#### 오프라인 큐레이션: 예제 수준 데이터 정제

대규모 잡음이 섞인 이미지-텍스트 데이터를 수집하고 필터링하는 방법은 처음에는 텍스트 캡션의 품질[6, 9, 24]과 고품질 참조 데이터셋과의 근접성[16, 17, 52]에 중점을 두었습니다. 대신, 모델 기반 필터링 접근법은 CLIP[38] 및 BLIP[27]와 같은 사전 훈련된 모델을 평가 지표로 사용하여 이미지-텍스트 정렬을 통해 데이터를 큐레이션합니다[16, 22, 32]. 중요한 것은, 이러한 모든 방법은 예제별로 독립적으로 적용되며, 이는 배치 내 예제 간의 종속성 관련성을 고려하지 못합니다.

#### 오프라인 큐레이션: 클러스터 수준 데이터 정제

다른 방법으로는 의미적 중복 감소[1, 2, 47] 또는 코어셋 선택[7, 20]이 제안되었으며, 이는 주변의 다른 데이터 포인트를 고려한 데이터 포인트의 한계적 중요성에 기반한 큐레이션입니다. 그러나 이러한 방법은 훈련 목표와 분리된 휴리스틱에 기반합니다. 반면, 우리의 방법은 대조 사전 학습 목표 함수를 가속화하는 데 특화된 공동 예제 선택을 가능하게 합니다.

#### 모델 기반 점수화를 통한 온라인 데이터 큐레이션

위에서 설명한 큐레이션 절차를 사용한 사전 필터링은 데이터 품질을 크게 향상시킬 수 있습니다. 그러나 고정된 큐레이션 전략은 학습 과정에서 훈련 예제의 관련성이 변할 수 있음을 고려하지 않으며, 이는 대규모에서 유용성을 제한합니다[18]. 이러한 문제는 온라인 데이터 큐레이션 방법[15, 30, 31, 33]에 의해 해결되며, 이는 모델이 아직 학습하지 않은 고품질 예제를 식별합니다. 우리의 연구는 예제 수준 손실이 아닌 배치 수준 손실에 모델 기반 기준을 적용하고 이에 따라 데이터를 선택하여 이를 일반화합니다.

#### 어려운 네거티브 마이닝

긴 역사를 가진 연구들은 고전적인 메트릭 학습[5, 21, 34, 45, 50, 53]과 현대의 대조 학습[41, 49]에서 적절한 네거티브 예제를 선택함으로써 효율성이 향상된다는 것을 설명합니다. 우리는 다음 두 가지 방식으로 어려운 네거티브 마이닝을 일반화합니다: 1) 전체 배치를 선택하여 긍정적 및 부정적 쌍을 함께 마이닝하고 2) 학습자에게는 어렵지만 사전 훈련된 모델에게는 쉬운 학습 가능한 네거티브를 우선시하는 것을 탐구합니다.

#### 모델 근사화

여러 연구들은 더 작은 모델이 데이터 선택을 위해 훨씬 더 큰 모델의 프록시로 사용될 수 있음을 입증했습니다[12, 15, 51]. 그러나 최근 여러 기술들은 추론 시 계산과 성능 간의 트레이드오프를 가능하게 하여 별도의 훈련 없이 작은 모델을 "내장"할 수 있도록 개발되었습니다. 비전 트랜스포머[14]의 경우, 패치[29] 또는 레이어[55]를 드롭하거나 토큰 해상도를 줄이는[4] 방식으로 특징적인 트레이드오프를 생성합니다[28]. 우리의 연구는 온라인 데이터 선택 맥락에서 이러한 기술을 처음으로 사용하는 것입니다.

### 3. 방법

#### 3.1 모델 기반 배치 선택 기준

우리는 훈련하려는 모델을 "학습자"라고 지칭합니다. 학습할 예제의 "슈퍼배치" D (크기 B)를 가지고 있다고 가정할 때, 학습에 가장 관련성이 높은 서브배치 B = {xi, i ∈ [1, ..., b]} ⊂ D를 추출하고자 합니다. 우선순위 샘플링[31, 43]은 개별 예제를 점수화하고 이 점수에 비례하여 샘플링함으로써 이를 수행합니다. 본 연구에서는 대신 전체 서브배치를 점수화하고, 이러한 배치 수준의 점수에 따라 샘플링합니다. 우리는 학습자 모델 및/또는 사전 학습된 참조 모델의 손실을 사용하는 모델 기반 점수화 함수를 고려합니다.

![](/assets/images/posts/212/img_1.png)

"서브배치"와 "슈퍼배치" 크기의 비율은 필터링 비율 f=1−b/B를 정의합니다, 즉 각 반복에서 버려지는 데이터의 비율을 나타냅니다. 주어진 학습자 배치 크기 b에 대해, 더 높은 필터링 비율은 슈퍼배치에서 더 많은 추론 단계를 필요로 하므로 점수화 비용을 증가시킵니다.

![](/assets/images/posts/212/img_2.png)

```
def jointly_sample_batch(learner_loss, ref_loss, n_chunks=16, filter_ratio=0.8, method="learnability"):
    scores = learner_loss - ref_loss if method == "learnability" else - ref_loss
    n_images = scores.shape[0]  # scores.shape = [B, B]
    n_draws = int(n_images * (1 - filter_ratio) / n_chunks)  # 각 청크의 크기.
    logits_ii = np.diag(scores)  # 자기 유사성 점수.
    inds = random.choice(logits_ii, n_draws)  # 첫 청크 샘플링.
    for _ in range(n_chunks - 1):
        is_sampled = np.eye(n_images)[inds].sum(axis=0)  # 현재 샘플의 바이너리 표시기 [n_images,].
        logits_ij = (scores * is_sampled.reshape(n_images, 1)).sum(axis=0)  # 네거티브 항목 ij [n_images,].
        logits_ji = (scores * is_sampled.reshape(1, n_images)).sum(axis=1)  # 네거티브 항목 ji [n_images,].
        logits = logits_ii + logits_ij + logits_ji  # 과거 샘플을 고려한 조건부 학습 가능성.
        logits = logits - is_sampled * 1e8  # 대체 샘플링 방지.
        new_inds = random.choice(n_images, n_draws, p=np.exp(logits))
        inds = np.concatenate((inds, new_inds))  # 샘플링된 인덱스 배열 확장.
    return inds  # 서브셋 인덱스 수집 및 반환.
```

#### 알고리즘 1: 공동 예제 선택: 시그모이드 손실

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

### 손실 함수 (Loss Function) 예제

손실 함수는 모델의 예측과 실제 값 사이의 차이를 측정하는 함수입니다. 여기서는 간단한 예제를 통해 손실 함수가 어떻게 작동하는지와 본 논문에서 언급된 다양한 손실 기준을 설명하겠습니다.

#### 가정:

- 학습자는 이미지를 입력으로 받아 해당 이미지가 개와 고양이 중 어느 것인지를 예측하는 모델입니다.
- "슈퍼배치" D는 100개의 이미지로 구성되어 있고, "서브배치" B는 10개의 이미지로 구성됩니다.

#### 예제:

1. **어려운 학습자 (Hard Learner) 기준**:
   - 학습자의 손실이 높은 배치를 선택합니다. 즉, 학습자가 예측을 잘 못하는 이미지를 우선시합니다.
   - 예를 들어, 100개의 이미지 중 개와 고양이를 혼동하는 이미지가 있다면, 이 이미지의 손실 값이 높을 것입니다.
   - 손실 값이 높은 이미지를 포함하는 배치 B를 선택합니다.

```
# 학습자의 손실 값 예시
learner_loss = [0.2, 1.5, 0.1, 1.2, 0.4, 2.0, 1.8, 0.5, 1.1, 0.3]
# 높은 손실 값을 가진 이미지를 우선시합니다.
prioritized_indices = [5, 6, 1, 3, 8]
```

**2. 쉬운 참조 (Easy Reference) 기준**:

- 사전 학습된 참조 모델의 손실이 낮은 배치를 선택합니다. 즉, 참조 모델이 쉽게 맞추는 이미지를 우선시합니다.
- 예를 들어, 사전 학습된 모델이 개와 고양이를 잘 구분하는 이미지는 손실 값이 낮을 것입니다.
- 손실 값이 낮은 이미지를 포함하는 배치 B를 선택합니다.

```
# 참조 모델의 손실 값 예시
ref_loss = [0.1, 0.4, 0.05, 0.3, 0.15, 0.8, 0.7, 0.2, 0.25, 0.1]
# 낮은 손실 값을 가진 이미지를 우선시합니다.
prioritized_indices = [2, 0, 4, 9, 3]
```

**3. 학습 가능성 (Learnability) 기준**:

- 학습자의 손실과 참조 모델의 손실 차이를 이용하여 배치를 선택합니다. 학습자에게는 어렵지만 참조 모델에게는 쉬운 이미지를 우선시합니다.
- 예를 들어, 학습자가 개와 고양이를 구분하기 어려운 이미지를 참조 모델이 쉽게 구분한다면, 이러한 이미지를 포함하는 배치 B를 선택합니다.

```
# 학습 가능성 점수 = 학습자 손실 - 참조 모델 손실
learnability_score = [learner_loss[i] - ref_loss[i] for i in range(len(learner_loss))]
# 예시: [0.1, 1.1, 0.05, 0.9, 0.25, 1.2, 1.1, 0.3, 0.85, 0.2]
# 학습 가능성 점수가 높은 이미지를 우선시합니다.
prioritized_indices = [5, 1, 6, 3, 8]
```

JEST 알고리즘은 위에서 설명한 손실 기준을 사용하여 배치를 선택합니다. 주어진 슈퍼배치에서 가장 학습 가능한 서브배치를 선택하는 과정을 통해 모델 학습을 가속화합니다. 각 반복에서 학습 가능성 점수가 높은 서브배치를 선택하고, 그 서브배치에서 학습을 진행합니다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------

![](/assets/images/posts/212/img_3.png)

### 효율적인 점수화 및 다중 해상도 훈련

**온라인 모델 근사화를 통한 효율적인 점수화**: 큰 슈퍼배치의 점수화는 반복당 비용을 증가시켜 총 FLOP 측면에서 효율성 이득을 감소시킵니다. Evans et al. [15]은 더 큰 학습자를 대신해 데이터를 효율적으로 점수화하기 위해 추가적인 작은 프록시 모델이 필요했지만, 우리는 온라인 모델 근사화를 사용하여 이 요구를 제거합니다. 각 추론 통과의 대부분의 비용을 차지하는 이미지 인코딩만 근사화합니다 [29]. 이를 위해 FlexiViT 아키텍처 [4]를 채택하여 이미지 해상도를 낮추면서 성능 저하를 최소화합니다 (패치 드롭핑 [29]과의 비교는 그림 9 참조). 실험에서 우리는 패치 크기 16×16의 전체 해상도 점수화 대비 32×32 픽셀 패치로 슈퍼배치를 평가하여 FLOP를 72%, 실제 시간을 67% 줄였습니다 (섹션 A.4 참조).

![](/assets/images/posts/212/img_4.png)

### 훈련 데이터셋

모든 JEST 실험에서 WebLI 데이터셋 [10]의 영어 이미지-텍스트 페어의 억 규모 하위 집합을 사용하여 학습자 모델을 훈련합니다. 참조 모델을 훈련하기 위해서는 더 작은 고품질 데이터셋을 사용합니다. JEST/Flexi-JEST 참조 모델은 텍스트 및 이미지 품질과 이미지-텍스트 정렬이 높은 필터링된 WebLI의 1억 규모 하위 집합에서 훈련되며, 이를 "WebLI-curated"라고 부릅니다. 우리는 또한 강력한 큐레이션 파이프라인으로 필터링된 약 6억 개의 추가 웹 스크래핑 이미지-텍스트 페어를 추가한 "WebLI-curated++"에서 훈련된 참조 모델을 사용하여 데이터 큐레이션을 확장(JEST++/FlexiJEST++)하는 것도 탐구합니다. 별도로 명시하지 않는 한, 보고된 평균 성능은 다중모달 전이의 4개 표준 벤치마크: ImageNet 0-Shot 및 10-Shot 분류와 COCO 이미지-텍스트 및 텍스트-이미지 상위-1 검색을 사용합니다.

![](/assets/images/posts/212/img_5.png)

#### 그림 2: 공동 예제 선택은 더 학습 가능한 배치를 생성합니다.

- 왼쪽: 배치의 학습 가능성은 매우 구조화되어 있고 비대각선입니다.
- 중간: 공동 예제 선택은 높은 학습 가능성을 가진 서브배치를 빠르게 발견하며, 무작위 기브스 샘플링과 동등합니다.
- 오른쪽: 샘플링된 배치의 학습 가능성은 더 높은 필터링 비율(즉, 더 큰 슈퍼배치에서 선택)로 향상됩니다.

### 4. 실험

#### 4.1 공동 예제 선택은 학습 가능한 배치를 생성합니다

우리는 학습 가능한 배치를 선택하기 위해 공동 예제 선택(JEST)의 효율성을 평가하는 것부터 시작합니다. 이 방법에 대한 직관을 얻기 위해, 학습자와 참조 모델 간의 손실 차이(배치 내 모든 예제 쌍에 대해)를 시각화하는 학습 가능성 매트릭스를 살펴봅니다. JEST는 학습 가능성의 합에 비례하여 예제의 서브 매트릭스를 샘플링하도록 설계되었습니다. 매트릭스가 강하게 비대각선이므로(그림 2, 왼쪽), 독립적인 선택은 명백히 최적이 아닙니다.

소수의 반복(즉, 배치를 16개의 청크로 채우는 과정)에 따라 서브배치의 학습 가능성이 빠르게 증가하여, 수천 번의 반복을 요구하는 무작위 기브스 샘플링으로 추출된 배치의 학습 가능성과 일치함을 발견했습니다(그림 2, 중간). 필터링 비율이 0.5, 0.8 및 0.9일 때, 각각 크기 65,536, 163,840 및 327,680의 슈퍼배치에서 32,768개의 예제 서브배치를 선택했습니다. 그림 2(오른쪽)에서 서브배치의 학습 가능성이 더 큰 필터링 비율에서 증가함을 발견했습니다. 요약하면, JEST 알고리즘은 학습 중 높은 학습 가능성을 가진 배치를 선택하는 효과적이고 효율적인 방법입니다.

![](/assets/images/posts/212/img_6.png)

#### 그림 3: 공동 예제 선택은 다중모달 학습을 가속화합니다.

- **왼쪽**: 2배, 5배, 또는 10배 큰 슈퍼배치에서 선택된 가장 학습 가능한 서브배치로 훈련하면 다중모달 학습이 크게 가속화됩니다.
- **중간**: 학습 가능한 배치를 공동으로 우선시하면 단순히 개별 예제를 우선시하는 것보다 훨씬 더 나은 결과를 얻을 수 있습니다.
- **오른쪽**: 공동 예제 선택은 쉬운 참조 우선순위도 개선하지만, 학습 가능성은 더 공격적인 필터링에서 더 잘 확장됩니다.

#### 4.2 공동 예제 선택은 다중모달 학습을 가속화합니다

이제 JEST 알고리즘으로 선택된 더 학습 가능한 배치로 훈련하는 효과를 조사합니다. 모든 실행은 WebLI-curated에서 훈련된 참조 모델, ViT-B/16 및 Bert-B 이미지-텍스트 듀얼 인코더, 30억 개의 훈련 예제 및 시그모이드-대조 손실을 사용합니다. 그림 3(왼쪽)은 훈련 과정 동안 여러 후속 작업(ImageNet 0-Shot/10-Shot 정확도 및 COCO 이미지-텍스트/텍스트-이미지 검색)에서의 평균 성능을 보여줍니다. JEST는 학습을 크게 가속화하여, 필터링 비율이 각각 50%, 80%, 90%일 때 30억 균일 기준 성능을 20억, 10억 및 6억 7천만 훈련 예제 후에 달성했습니다. 더 큰 필터링 비율에서는 더 큰 배치 크기에 대해 관찰된 것과 유사한 훈련 불안정을 관찰했으며[54], 이는 Adam 옵티마이저를 안정화하기 위해 수정이 필요했고(β2 = 0.95), JEST를 사용한 데이터 큐레이션이 효과적인 배치 크기를 증가시키는 것으로 생각할 수 있음을 시사합니다(부록 A.2, A.3).

최종 성능 측면에서, JEST는 데이터의 90%를 필터링할 때 최대 6%의 상당한 이득을 제공합니다(그림 3, 중간, 파란 곡선). 독립적으로 개별 예제의 우선순위를 매기는 이전 선택 방법에서는 이러한 스케일링 행동이 나타나지 않습니다(그림 3, 중간, 주황색 곡선).

마지막으로, JEST가 학습 가능성 이외의 우선순위 기준을 개선하는지도 평가합니다. 그림 3(오른쪽)은 다양한 필터링 비율에 대한 쉬운 참조 우선순위 모델의 성능을 보여줍니다. 학습 가능성 기반 우선순위와 일관되게, JEST는 특히 높은 필터링 비율에서 독립적인 예제 선택보다 훨씬 뛰어납니다(독립적 예제 선택은 성능 저하를 초래함). 손실이 가장 높은 데이터를 우선시하면 더 작은 이득이 발생하고 더 많은 데이터를 필터링할수록 성능이 더 빨리 저하됩니다(그림 10). 학습 가능성 기반 JEST가 가장 좋은 스케일링 행동을 보였기 때문에, 이후 실험에서는 이 기준을 유지합니다.

![](/assets/images/posts/212/img_7.png)

#### 그림 4: 효율적인 점수화와 다중 해상도 훈련

- **왼쪽**: 학습자와 참조 모델로 큰 슈퍼배치를 점수화할 때, JEST는 반복당 큰 계산 비용을 초래합니다. 데이터셋에 고정된 참조 모델 점수를 캐싱하면 이 오버헤드는 절반으로 줄일 수 있습니다. 효율적인 점수화와 다중 해상도 훈련은 이를 표준 IID 훈련과 비교할 만한 수준으로 더욱 줄입니다.
- **중간**: Flexi-JEST는 표준 IID 훈련에 비해 JEST의 총 FLOP 효율성을 향상시킵니다.
- **오른쪽**: 다중 해상도 훈련은 FlexiJEST를 표준 IID 훈련보다 더 많이 개선합니다. 다중 해상도 훈련 없이(가장 왼쪽 점) Flexi-JEST는 IID 기준보다 성능이 떨어지지만(근사 모델이 훈련되지 않았기 때문), 소량의 공동 훈련(25%)만으로도 빠르게 개선됩니다.

### 4.3 다중 해상도 훈련과 온라인 배치 선택 간의 시너지 효과

학습 가능성 점수를 사용한 공동 예제 선택은 각 배치의 더 큰 부분이 필터링될수록 더 효율적이 됩니다. 그러나 점수화 비용은 상당한 오버헤드를 발생시킵니다: 슈퍼배치의 80%를 필터링하면 IID 훈련보다 반복당 4배 더 많은 FLOP가 발생하며, 참조 모델 점수를 캐싱할 경우 2.3배 더 많아집니다(부록 A.4). JEST는 훈련 반복 측면(이하 '훈련 효율성')에서 훨씬 더 효율적이지만, 추가 점수화 FLOP로 인해 IID 기준보다 계산 효율성은 상대적으로 낮습니다(그림 1, 왼쪽과 오른쪽 비교). 따라서 우리는 계산 효율적인 변형인 Flexi-JEST를 조사했으며, 이는 다중 해상도 훈련과 저해상도 점수화를 사용하여 총 오버헤드를 기준보다 10%로 줄입니다(그림 4, 왼쪽; 섹션 A.4 참조).

이러한 근사화가 성능에 미치는 영향은 무엇일까요? 예상대로 Flexi-JEST의 반복당 성능은 JEST에 비해 감소하지만, 여전히 IID보다 상당한 속도 향상을 제공합니다(그림 1, 왼쪽; 그림 4, 중간). 그러나 반복당 성능 감소는 총 FLOP 감소를 고려할 때 충분히 긍정적입니다: 우리의 최고의 Flexi-JEST 모델은 9.9배 적은 FLOP로 40B Siglip 실행과 동일한 평균 성능을 제공하며, 전체 해상도 JEST보다 2배 적습니다(그림 1, 오른쪽; 그림 4, 중간).

Flexi-JEST에서 효율적인 점수화와 다중 해상도 훈련의 상대적 기여는 무엇일까요? 우리는 선택된 배치의 일부를 전체 해상도와 저해상도로 훈련하면서(즉, Bhi와 Blo의 상대 크기; 방법 참조) 절제 실험을 수행했습니다. 학습자가 같은 FLOP를 사용하도록 보장하기 위해, 더 많은 데이터를 근사 모델로 보낼 때 반복 수를 늘립니다. 왜냐하면 이 경우 반복당 FLOP가 감소하기 때문입니다(자세한 내용은 섹션 A.7 참조). 그림 4(오른쪽)는 데이터의 더 큰 비율이 근사 모델로 보내질 때 IID 기준 성능이 증가함을 보여주며, 이는 근사 훈련의 FLOP 효율성에 대한 문헌이 증가하고 있는 것과 일치합니다[4, 29, 13, 40]. 그럼에도 불구하고, Flexi-JEST는 저해상도 모델이 학습자와 정렬되기 위해 충분한 데이터를 훈련할 때(예: ≥ 25% 데이터) 다중 해상도 기준보다 훨씬 뛰어납니다. 이러한 실험은 다중 해상도 훈련과 공동 예제 선택 간의 시너지 효과를 보여주며, 전자는 후자를 가속화하기 위한 효율적이고 정확한 점수화 기능을 제공합니다.

우리의 결과는 또한 데이터 큐레이션 전략의 파레토 전선을 가리킵니다. 계산 비용을 감수하고 훈련 속도 또는 훈련 효율성을 최대화하고자 할 경우, 전체 해상도 JEST 방법은 유사한 IID 훈련 실행보다 최대 13배 빠릅니다. FLOP를 최소화하고자 할 경우 Flexi-JEST는 가장 유리한 절충안을 제공합니다. 다음 배치의 점수화는 훈련과 병행하여 별도의 장치에서 구현될 수 있어 추가 실제 시간을 더욱 줄일 수 있습니다.

### 4.4 공동 예제 선택은 강력한 데이터 품질 부트스트래핑을 가능하게 합니다

학습 가능성 기반 점수화의 핵심은 우리가 선택한 작은 큐레이션 데이터셋으로 훈련된 참조 모델입니다. JEST의 성능은 품질과 양의 절충을 다루는 다양한 큐레이션 전략에 따라 어떻게 달라질까요? 또한, JEST 훈련의 개선이 참조 모델의 성능과 상관관계가 있나요, 아니면 이 지표들이 분리되어 있나요?

![](/assets/images/posts/212/img_8.png)

#### 그림 5: 강력한 데이터 큐레이션 확장은 JEST 성능을 개선합니다.

- **왼쪽**: 4가지 큐레이션 유형에 대해 JEST 성능과 참조 모델 성능을 비교합니다: 이미지-텍스트 정렬(ITA)을 사용한 ‘약한’ 큐레이션, ITA 또는 텍스트 품질(TQ)을 사용한 ‘중간’ 큐레이션, 그리고 TQ, ITA 및 추가 이미지 품질(IQ)을 사용하는 ‘강한’ 큐레이션.
- **오른쪽**: 최고의 참조 데이터셋(TQ+ITA+IQ)을 사용하여 참조 사전 훈련 동안 본 예제 수를 변동시키며 JEST 대 참조 성능을 평가합니다. 10억 예제를 본 후 참조 모델 훈련과 JEST 성능 간의 강력한 상관관계가 포화됩니다. 강력한 데이터 큐레이션을 6억 예제로 확장함으로써 이 포화 현상을 깨고, 참조 모델과 JEST 성능 모두 10억 및 20억 참조 훈련에서 개선됩니다.

#### 품질과 양의 절충 이해하기

우리는 원래의 WebLI 데이터셋에서 각기 다른 세 가지 규모의 큐레이션을 탐구했습니다: 이미지-텍스트 정렬(ITA) 필터를 사용한 약한 큐레이션(억 단위), ITA 필터 또는 텍스트 품질(TQ) 필터를 사용한 중간 큐레이션(3억 단위), 그리고 TQ, ITA, 추가 이미지 품질(미적) 필터의 조합을 사용한 강력한 큐레이션(1억 단위). 우리는 이 강력하게 큐레이션된 하위 집합을 "WebLI-curated"라고 부릅니다.

우리는 이러한 네 가지 WebLI 하위 집합에서 각각 10 에포크 동안 표준 SigLIP 인코더를 훈련하고, 이들을 전체 WebLI 데이터셋에서 JEST 훈련의 참조 모델로 사용합니다. 큐레이션 방법에 걸쳐 참조 모델 성능과 JEST 성능은 분리되어 보이거나 심지어 반대로 상관관계가 있습니다(그림 5, 왼쪽). 이는 고정된 데이터 큐레이션에 대한 이전의 발견과 일치합니다[16]. 큐레이션을 증가시키고(데이터셋 크기를 줄이는) 것은 더 약한 모델을 생성하지만, JEST 사전 훈련의 참조 모델로 사용될 때는 반대의 효과를 보입니다: 강력하게 큐레이션된 참조 모델을 사용한 JEST는 2.7%의 개선을, 중간 큐레이션은 1.5%의 개선을, 약한 큐레이션은 0.3%의 개선을 보입니다.

#### 데이터 큐레이션 확장

참조 모델 성능과 JEST 성능 간의 일반적인 분리가 단순히 데이터 큐레이션으로 인한 데이터셋 크기 제한으로 설명될 수 있다고 가정했습니다. 이 효과를 이해하기 위해, 우리는 WebLI-curated에서 총 예제를 2억 5천만에서 30억까지 변동시켜 5개의 참조 모델을 훈련했습니다. 이 맥락에서, 그림 5(오른쪽)는 개선된 참조 모델과 더 나은 JEST 사전 훈련 간의 눈에 띄는 상관관계를 보여줍니다. 이는 큐레이션 후 데이터셋 크기 감소로 인한 참조 모델의 포화 현상에 주로 기인할 수 있음을 시사합니다.

그림 5(오른쪽)의 상관관계는 데이터셋이 포화 상태에 도달하면(즉, 10 에포크 또는 10억 예제를 본 후) 무너지기 시작합니다. 이러한 결과는 JEST가 참조 데이터셋의 데이터 큐레이션을 확장함으로써 더 큰 이익을 얻을 수 있음을 시사합니다. 이를 테스트하기 위해, 우리는 WebLI-curated를 이미지-텍스트 페어의 확장된 집합에서 약 6억 예제로 확장했습니다. 그러나 이 규모에서 WebLI-curated의 엄격한 TQ/ITA 기준을 충족시키는 것은 어렵습니다. 따라서 원래 ITA 임계값을 충족하지 않는 모든 이미지-텍스트 페어에 대해 PaLI 모델 계열[10, 11]을 기반으로 한 고품질의 합성 캡션으로 이미지를 다시 캡션했습니다. 이 데이터셋을 "WebLI-curated++"라고 명명했습니다.

우리는 이 확장된 데이터셋이 "WebLI-curated"의 20억 포화점을 넘어서게 하여 참조 모델과 JEST 성능(그림 5, 오른쪽: ⋆)을 크게 개선함을 발견했습니다. 따라서 우리의 최고의 모델, JEST++ 및 FlexiJEST++에 WebLI-curated++를 사용합니다.

WebLI-curated++로 데이터 큐레이션을 확장하면 참조 모델 성능이 크게 향상됨을 고려할 때, 원래 WebLI 데이터셋에서의 사전 훈련이 필요한지 여부를 질문했습니다. 그러나 데이터셋 전반에 걸쳐 참조 모델의 성능을 평가한 결과, 이는 매우 불균형하다는 것을 발견했습니다: 두 개의 후속 작업에서는 WebLI 사전 훈련을 능가했지만, 나머지 여섯 개 작업에서는 크게 뒤처졌으며 평균적으로도 마찬가지였습니다(표 5). 대조적으로, WebLI에서 JEST++ 사전 훈련은 8개 벤치마크 중 6개에서 기준 성능을 능가하는 일반적인 기초 모델을 생성했습니다.

![](/assets/images/posts/212/img_9.png)

표 1: 선행 기술과의 비교. FLOP %는 SigLIP [54]을 기준으로 측정되었습니다. 평균은 모든 메트릭에 대한 평균 성능을 나타냅니다. “Per Iter."는 반복당 FLOP을 나타냅니다.

![](/assets/images/posts/212/img_10.png)

### 표 2: LAION 사전 훈련과의 비교

JEST++는 훨씬 적은 훈련 반복이 필요하면서도 이전 연구를 크게 능가합니다. COCO 성능은 이미지-텍스트와 텍스트-이미지 검색의 평균을 나타냅니다.

### 4.5 기존 연구와의 비교

우리는 이제 40억 개의 예제를 훈련한 최첨단 SigLIP 모델[54]과 최근 강력한 CLIP 변형을 포함한 기존 연구와 비교합니다. 표 1은 가장 훈련 효율적인 모델인 JEST++가 ImageNet과 COCO 모두에서 새로운 최첨단을 설정하며, 10배 적은 반복과 4배 적은 연산을 사용함을 보여줍니다. 특히 COCO에서는 JEST++가 이전 최첨단을 5% 이상 개선했습니다. 가장 계산 효율적인 모델인 Flexi-JEST++도 9배 적은 계산으로 평균적으로 이전 최첨단을 능가합니다. JEST를 더 오래 훈련하면 이러한 이득이 더욱 증가합니다(부록 표 4 참조).

우리의 결과는 모델 크기와도 우아하게 확장됩니다. 동일한 WebLI-curated++ 데이터셋에서 훈련된 ViT-L 학습자와 ViT-L 참조 모델을 사용하여 훈련할 때, JEST++는 계속해서 학습을 크게 가속화하여 단지 40억 개의 예제로 SigLIP ViT-L 40B 기준 성능과 일치합니다(표 1, 하단 참조).

마지막으로, 우리는 JEST++를 공개된 LAION-2B 데이터셋[44]에 대해 사전 훈련에 적용했습니다. 우리는 안전하지 않은 이미지-텍스트 쌍을 제거하는 표준 절차를 따랐지만, 데이터셋을 사전 필터링하지 않았습니다. JEST++는 이전 오프라인 데이터 큐레이션 방법을 크게 능가하며, 이전 최첨단보다 4배 적은 훈련 예제를 사용했습니다(표 2). 이 훈련 예산으로, SigLIP 사전 훈련은 모든 방법에 비해 성능이 크게 떨어져, JEST의 이점을 더욱 강조합니다.

![](/assets/images/posts/212/img_11.png)

### 표 3: 데이터 큐레이션 단순화

모든 모델은 40억 개의 예제로 훈련되었습니다. 필터링된 데이터와 필터링되지 않은 데이터에 대한 사전 훈련 시 JEST++의 성능은 거의 동일합니다. 색상 그라디언트는 필터링된 WebLI에서 IID 훈련에 비례하여 측정되었습니다.

### 4.6 데이터 큐레이션 단순화

우리의 사전 훈련 실험에 사용된 WebLI 데이터셋[10]은 이미 높은 이미지-텍스트 정렬을 위해 필터링되었습니다. 표 3에서 알 수 있듯이, 이 오프라인 큐레이션은 강력한 IID 훈련 성능에 중요합니다. 그러나 JEST++의 경우, 이 사전 필터링은 중복되며, 필터링되지 않은 WebLI에서 훈련할 때 성능이 저하되지 않아 기초 데이터셋에 대한 필요성을 줄여줍니다.

### 5. 논의

우리는 가장 학습 가능한 데이터 배치를 공동으로 선택하여 대규모 다중모달 학습을 크게 가속화하는 JEST 방법을 제안했습니다. 이는 10배 적은 FLOP와 13배 적은 예제로 이전 최첨단을 능가합니다. 특히, 우리의 실험은 작은 큐레이션된 데이터셋을 사용하여 훨씬 더 큰, 큐레이션되지 않은 데이터셋에서 학습을 안내하는 "데이터 품질 부트스트래핑"의 강력한 잠재력을 지적합니다.

최근 연구에 따르면, 후속 훈련에 대한 지식 없이 정적인 데이터셋 필터링은 궁극적으로 성능을 제한할 수 있습니다[18]. 우리의 결과는 온라인으로 구성된 유용한 배치가 개별적으로 선택된 예제보다 사전 훈련 효율성을 향상시킴을 보여줍니다. 이러한 발견은 따라서 기초 분포를 옹호합니다. 이는 쉬운 참조 JEST로 사전 점수화된 데이터셋을 통해 또는 학습 가능성 JEST로 모델의 요구에 맞게 동적으로 조정되어, 일반적인 기초 데이터셋에 대한 보다 일반적이고 효과적인 대체 방법입니다.

#### 한계점

우리의 방법은 표준적인 후속 작업의 다중모달 학습을 가속화했지만, 훨씬 더 큰 큐레이션되지 않은 데이터 내에서 우선 순위를 지정할 분포를 지정하는 작은, 잘 큐레이션된 참조 데이터셋에 의존했습니다. 따라서 후속 작업 집합에서 참조 데이터셋을 유추하는 연구를 권장합니다.

[2406.17711v1.pdf

1.53MB](./file/2406.17711v1.pdf)
